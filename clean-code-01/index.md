# 클린코드 - 1장 클린코드 & 2장 의미있는 이름


> 🧹🧹🧹 클린코드 읽고 정리하기 🧹🧹🧹

## 목표
- 좋은 코드와 나쁜 코드를 구분하기
- 좋은 코드를 작성하는 방법 익히기
- 나쁜 코드를 좋은 코드로 바꾸는 실력 쌓기

## 나쁜 코드
**성능이 나쁜 코드** 
  - 불필요한 연산이 들어가서 개선의 여지가 있는 코드

**의미가 모호한 코드** 
  - 이해하기 어려운 코드. 네이밍과 그 내용이 다른 코드

**중복된 코드** 
  - 비슷한 내용인데 중복되는 코드들은 버그를 낳는다.

### 나쁜 코드가 나쁜 이유 
**깨진 유리창 법칙**
- 나쁜 코드는 깨진 유리창처럼 계속 나쁜 코드가 만들어지도록 한다.

**생산성 저하**
- 코드를 고칠 때 엉뚱한 곳에서 문제 발생
- 간단한 변경은 없음
- 얽히고 설킨 코드를 해독하고 설킨 코드를 더함

**(결국) 새로운 시스템을 만들어야 한다.**
- 신규 투입된 인력은 시스템 설계에 조예가 깊지 못함
- 설계 의도에 맞는 변경과 설계 의도에 변경을 구분하지 못함
- 현 시스템을 유지보수하며 대체할 새로운 시스템 개발은 현실적으로 매우 어렵다.

### 나쁜 코드를 짜는 이유
- 일정이 촉박해서
  - 일정 안에 새로운 기능을 완성해야한다.
  - 나쁜 코드는 생산성을 저하하기 때문에 오히려 일정을 맞추지 못한다.
- 영향 범위가 넓어서
  - 다른 부분에 버그 발생을 우려
  - 기술 부채는 부메랑처럼 우리에게 돌아온다.

### 나쁜 코드를 짜지 않으려면
- 언제나 코드를 최대한 깨끗하게 유지하는 습관을 들여야한다.
- 어떤 코드가 깨끗한지 나쁜 코드인지 코드감각을 활용
- 절제와 규율을 적용해 나쁜 코드와 좋은 코드를 바꾸는 전략도 파악

## 클린 코드
- **성능이 좋은 코드**
- **의미가 명확한 코드 = 가독성이 좋은 코드**
- **중복이 제거된 코드 = 명료한 코드**

### 프로그래밍 대가의 의견

**바야네 스트롭스트룹** _C++ 창시자이자 C++ programming language 저자_

- 우아하고 효율적인 코드 - (효율은 속도 뿐만 아니라 CPU 자원을 낭비하지 않는 것)
- 논리가 간단해야 한다.
- 의존성을 최대한 줄여야 유지보수가 쉽다.
- 오류는 명백한 전략에 의거 철저히 처리
- **한 가지를 제대로 한다.**

**그래디 부치** _객체지향의 짱_
- 깨끗한 코드는 단순하고 직접적
- 잘 쓴 문장처럼 읽힌다.
- 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다.
- 오히려 명쾌한 추상화와 단순한 제어문으로 가득

{{<admonition type=note title="보이스카우트 룰">}}
- 캠프장은 처음 왔을 때 보다 더 깨끗하게 해놓고 떠나라
  -> 전보다 더 깨끗한 코드로 만들어야 한다.
{{</admonition>}}

## 의미있는 이름 짓기

**의도를 분명히 밝히기**
- 변수(혹은 함수나 클래스)가 존재하는 이유?
- 수행 기능은 무엇인가?
- 사용 방법은 어떻게 되는가?
- 의도가 드러나는 이름을 사용하면 코드 이해와 변경이 쉬워짐
- 코드의 단순성 보다는 코드의 함축성이 드러나야함
- 코드 맥락이 코드 자체에 명시적으로 드러나는 코드

**그릇된 정보는 피하기**
- 코드의 의미를 흐리는 그릇된 단서를 남겨서는 안된다. 
- 일관성이 떨어지는 표기법은 지양한다.
- 소문자 `l`, 대문자 `O` 사용시 주의

**의미있게 구분하기**
- 아무런 정보를 제공하지 않는 이름은 적절하지 못함
- 불용어 사용 지양

```java
public static void copyChars(char a1[], char a2[]) {
	for(int i = 0; i < a1.length; i++) {
		a2[i] = a1[i];
	}
}
```
```java
public static void copyChars(char source[], char destination[]) {
	for(int i = 0; i < source.length; i++) {
		destination[i] = source[i];
	}
}
```

**발음하기 쉬운 이름 사용하기**
- 발음하기 어려운 이름은 토론시 어려움

**검색하기 쉬운 이름 사용하기**
- 문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않음
- 이름 길이는 범위 크기에 비례
  - 전역변수 : 전역으로 사용되는 변수는 검색하기 명확한 단어로 
  - 예시) `EX WORK_DAYS_PER_WEEK`

**인코딩을 피하기**
- 변수명에 타입, 범위, 정보를 넣지 않는다.
- 헝가리식 표기법이나 멤버 변수에 접두어를 붙이지 않는다.
- 인터페이스와 구현 클래스 이름이 인코딩되어 있으면 과도한 정보
  - 주로 구현 클래스에 인코딩 정보를 포함하는 것이 일반적
  - `IShapeFactory` -> `ShapeFactoryImpl`

**자신만 아는 이름 피하기**
- 예외로 루프에서 사용하는 `i`, `j`, `k` 는 OK (이것은 전통적이므로)
- 루프의 범위가 작고 다른 이름과 충돌하지 않을 때만 괜츈
- advanced for 문을 사용하면 더욱 좋다.

**한 단어의 개념만 사용**
- 똑같은 메서드를 클래스마다 `fetch`, `retrieve`, `get` 으로 제각 사용하면 혼란쓰
- 어느 클래스에 어떤 이름을 썼는지 기억 어려움
- 메서드 이름은 독자적이고 일관적이어야함

**해법 영역에서 가져온 이름을 사용**
- 코드를 읽는 사람도 결국 프로그래머이다.
  - 전산용어, 알고리즘, 패턴, 수학 용어의 이름을 사용
  - 모든 문제를 도메인 영역에서 가져올 필요는 없다.
**클래스 이름**
- 클래스, 객체 이름은 명사나 명사구가 적합
- `Customer`, `WikiPage`, `Account`, `AddressParser`
- `Manager`, `Processor`, `Data`, `Info` : 되도록 사용하지 않기

**메서드 이름**
- 동사, 동사구 적합
- `postPayment`, `deletePage`, `save` 등
- 접근자, 변경자, 조건자는 javabean 표준에 따라 `get`, `set`, `is` 붙임

