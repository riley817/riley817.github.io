[{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS RDS RDS는 관계형 데이터 베이스 서비스 Relational Database Service 를 나타내며 SQL 쿼리 언어를 사용하는 데이터베이스를 위한 서비스이다. RDS에서 제공하는 데이터베이스 Postgres MySQL MariaDB Oracle Microsoft SQL Server Aurora - AWS Proprietary database EC2에 DB를 운용하지 않고 RDS 사용했을 때 이점 프로비저닝 및 OS 패치 자동화 지속적 백업과 특정 timestamp 기준 복구 (Point Time Restore) 대시보드 모니터링 읽기 성능 향상을 위한 읽기 전용 복제본 재해복구 DZ(Disaster Recovery)를 위한 Multi AZ 셋업 가능 업그레이드를 위한 유지보수 확장성 (vertical and horizontal) EBS 스토리지 백업 (gp2 or io1) Warning 그러나 인스턴스에 SSH를 따로 가질 수는 없다. ","date":"2022-08-06","objectID":"/aws-rds/:0:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS Backup RDS에서는 자동으로 백업이 실행된다. ","date":"2022-08-06","objectID":"/aws-rds/:1:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS 자동백업 매일 수행되는 데이터베이스 전체에 대한 백업 RDS에 의해 트랜잭션 로그가 5분 마다 백업된다. → 원하는 시점으로 복원할 수 있는 기능 (가장 오래된 백업의 5분 전으로) 보존기간은 7일 (최대 35일까지 늘릴 수 있다.) ","date":"2022-08-06","objectID":"/aws-rds/:1:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"DB 스냅샷 사용자에 의해 수동으로 트리거 된다. 원하는 기간 동안 백업을 보존할 수 있다. ","date":"2022-08-06","objectID":"/aws-rds/:1:2","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS - Storage Auto Scaling RDS DB 인스턴스의 스토리지를 동적으로 늘릴 수 있도록 지원한다. RDS가 사용 가능한 데이터베이스 스토리지가 부족함을 감지하면 자동으로 확장 데이터베이스의 스토리지를 수동 확장 방지 Maximum Storage Threshold 최대 스토리지 임계값(최대 제한) 을 설정해야 한다. 예측할 수 없는 워크로드 unpredictable workloads 가 있는 애플리케이션에 적합 모든 RDS 데이터베이스 엔진을 지원 (MariaDB, MySQL, PostgreSQL, SQL Server, Oracle) 자동으로 스토리지가 변경되는 경우 사용가능한 스토리지가 할당된 스토리지의 10% 미만임 최소 5분 이상 지속됨 마지막 수정 후 6시간이 지남 ","date":"2022-08-06","objectID":"/aws-rds/:1:3","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"읽기 전용 복제본 Read Replicas 최대 5개 까지 가능 AZ 내, AZ 교차, 리전 교차 읽기 복제본의 복제는 ASYNC 읽기 결과는 일관된다. 읽기 복제본은 자체 DB로 승격가능 애플리케이션에서는 읽기 복제본을 활용하기 위해서는 연결 문자열을 업데이트 해야 한다. ","date":"2022-08-06","objectID":"/aws-rds/:2:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS 읽기 복제본 사용 사례 애플리케이션 분석을 실행하기 위한 애플리케이션을 실행하려는 경우 읽기 복제본을 생성 후 새로운 워크로드에서 실행하려는 경우 프로덕션의 응용프로그램은 영향받지 않음 읽기 복제본은 SELECT 유형의 문에만 사용 (INSERT, UPDATE, DELETE는 사용불가능) ","date":"2022-08-06","objectID":"/aws-rds/:2:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"네트워크 비용 AZ간 데이터가 이동할 때 네트워크 비용이 발생한다. RDS 읽기 복제본를 사용하면 같은 리전이면 복제본의 수수료를 지불하지 않는다. ","date":"2022-08-06","objectID":"/aws-rds/:2:2","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"다중 AZ(Disaster Recovery) 동기식SYNC 으로 복제 하나의 DNS 이름을 가지고 자동으로 standby 데이베이스에 복구 가용성 증가 가용영역의 네트워크가 손실되는 경우 스토리지를 복구한다. 애플리케이션에 수동 개입이 없음 Multi-AZ 복제본은 비용이 발생하지 않음 Info 읽기 복제본은 재해 복구를 위해 다중 AZ로 설정된다. ","date":"2022-08-06","objectID":"/aws-rds/:3:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"단일 AZ에서 다중 AZ로 DB 중지가 불필요하다 -\u003e downtime이 없는 운영이 가능 내부적으로 발생하는 절차 스냅샷이 생성 스냅샷에서 새로운 데이터베이스가 AZ에 복원 두 데이터베이스간 동기화 설정 ","date":"2022-08-06","objectID":"/aws-rds/:3:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS 보안 ","date":"2022-08-06","objectID":"/aws-rds/:4:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"암호화 At-Rest 암호화 AWS KMS로 마스터 데이터베이스 및 읽기 전용 데이터베이스 AES-256 암호화 암호화 실행 시간을 정의 해야 한다. 마스터 데이터베이스를 암호화하지 않으면 읽기 전용 데이터베이스도 암호화 할 수 없다 Oracle 및 SQL Server에서 TED(Transparent Data Encryption) 사용 가능하다. -\u003e 데이터 암호화의 대안 제안 In-flight 암호화 SSL 인증서를 통한 데이터 전송중 암호화 데이터베이스를 연결 할 때 신뢰할 수 있는 인증서로 SSL 옵션을 제공하여 SSL을 제공할 수 있다. 모든 클라이언트가 SSL 사용하게 하려면 PostgreSQL: AWS RDS Console (Parameter Groups) rds.force_ssl=1 MySQL: 데이터베이스 내부에서 실행 GRANT USAGE ON *.* TO 'mysqluser'@'%' REQUIRE SSL; ","date":"2022-08-06","objectID":"/aws-rds/:4:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"암호화 옵션 RDS 백업 암호화 암호화 된 RDS 데이터베이스만 스냅샷이 암호화 됨 스냅샷을 암호화 된 스냅샷으로 복사할 수 있음 암호화되지 않은 RDS 데이터베이스 암호화 암호화되지 않은 데이터베이스의 스냅샷을 생성한다. 생성한 스냅샷을 복사하고 복사한 스냅샷에 대한 암호화를 활성화 한다. 암호화 된 스냅샷에서 데이터베이스를 복원한다. 응용프로그램에서 새 데이터베이스로 마이그레이션 후 이전 데이터베이스는 삭제한다. ","date":"2022-08-06","objectID":"/aws-rds/:4:2","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Network \u0026 IAM 네트워크 보안 RDS는 일반적으로 프라이빗 서브넷에 구축된다. RDS 보안은 보안 그룹을 통해 RDS와 통신할 수 있는 IP와 보안 그룹을 제어 접근 제어 관리 데이터베이스의 username과 password 로그인을 사용하거나 RDS MySQL \u0026 PostgreSQL에서는 IAM 기반의 인증을 사용할 수 있다. RDS IAM Authentication RDS MySQL \u0026 PostgreSQL에서만 IAM 데이터베이스 인증이 가능하다. 패스워드는 필요하지않고 RDS API를 통해 IAM으로 인증 토큰을 얻을 수 있다. 인증 토큰은 15분의 수명시간을 갖는다. 장점 네트워크의 in/out은 SSL을 통해 암호화된다. IAM에서 DB 대신에 사용자를 관리 IAM 역할 및 EC2 인스턴스 프로파일을 활용하여 손쉽게 통합 가능하다. ","date":"2022-08-06","objectID":"/aws-rds/:4:3","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS 보안 요약 ","date":"2022-08-06","objectID":"/aws-rds/:5:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AT-REST 암호화 DB 인스턴스를 처음 생성할 때만 수행 암호화 되지 않은 DB =\u003e 스냅샷 생성 =\u003e 스냅샷을 암호화된 것으로 복사 =\u003e 스냅샷에서 DB 생성 ","date":"2022-08-06","objectID":"/aws-rds/:5:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"사용자가 해야할 일 데이터베이스 보안그룹의 ports/ip/security group 인바운드 규칙 확인한다. 데이터베이스 내 모든 사용자 생성 및 권한을 관리 (IAM을 통한) public 액세스가 없는 데이터베이스를 생성 파라미터 그룹과 데이터베이스가 SSL 연결만 허용하도록 구성하여 암호화되는지 확인 ","date":"2022-08-06","objectID":"/aws-rds/:5:2","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS 하는일 SSH 액세스가 발생하지 않게 함 사용자가 수동으로 DB 패치를 하지 않아도 됨 사용자가 수동으로 OS 패치를 하지 않아도 됨 사용자가 기본 인스턴스를 확인하지 않아도 됨 Amazon Aurora Aurora는 AWS의 독점 기술 (오픈소스는 아님) Postgres 그리고 MySQL만 호환된다. 드라이버가 Postgres, mysql 데이터베이스인 것처럼 작동하는 것을 의미 AWS 최적화. RDS에 비해 3배 향상된 성능 스토리지는 자동으로 10GB, 최대 128 TB 까지 증가 MySQL을 5개의 복제본만 가질 수 있는 반면 Aurora는 15개의 복제본을 가질 수 있다. 복제 프로세스가 더 빠르다 즉각적인 장애 복구. native high availability (HA) RDS에 비해 비용이 20% 높지만 규모가 클 경우 더 효율적 ","date":"2022-08-06","objectID":"/aws-rds/:5:3","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"고가용성과 읽기 확장성 6개의 데이터 복제본은 3개의 AZ에 걸쳐 저장 쓰기 시 4개의 복제본만 있으면 됨 읽기 시 3개의 복제본만 있으면 됨 P2P(Peer-to-Peer) 복제를 통한 자가 복구 수백개의 볼륨을 걸쳐 스트라이핑 쓰기 가능 마스터 하나 30초 이내에 자동으로 마스터 장애 복구 실행 마스터 + 최대 15개의 읽기 전용 리전 간 읽기 전용 복제 지원 ","date":"2022-08-06","objectID":"/aws-rds/:6:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora DB Cluster Writer 엔드포인트를 제공 : 항상 마스터를 가리킴 읽기 전용 오토 스케일링 Reader 엔드포인트 : 오토 스케일링 된 읽기 전용 복제본 로드 밸런싱 ","date":"2022-08-06","objectID":"/aws-rds/:7:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora의 기능 장애복구 자동화 백업과 복원 격리 및 보안 업계 규정 준수 푸시 버튼 스케일링 자동화 된 무중단 패치 향상된 모니터링 정기 유지보수 Bactrack : 백업을 사용하지 않고 언제든지 데이터를 복원 ","date":"2022-08-06","objectID":"/aws-rds/:8:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora 보안 RDS와 비슷한 수준의 보안 (같은 엔진을 사용) KMS 사용한 At-Rest 암호화 자동화된 백업, 스냅샷 그리고 암호화된 복제본 SSL을 사용한 전송중 암호화 (MySQL, Postgres와 같은) IAM 토큰을 사용한 인증이 가능 (RDS와 같은 방식) 사용자는 보안그룹을 통해 인스턴스를 보호해야 한다. SSH에 접근할 수 없다. ","date":"2022-08-06","objectID":"/aws-rds/:9:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora 복제본 ","date":"2022-08-06","objectID":"/aws-rds/:10:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Auto Scaling Aurora 인스턴스 3개가 있다고 가정 Writer Endpoint : 1개 Reader Endpoint : 2개 Case 많은 읽기 요청으로 CPU사용량 증가 Aurora 복제본이 추가되고 자동으로 Reader Endpoint가 새 복제본을 포함하도록 확장 CPU 사용량을 낮추기 위해 분산된 방식으로 새로운 복제본이 트래픽 수신 ","date":"2022-08-06","objectID":"/aws-rds/:10:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Custom Endpoints Aurora 두 종류 복제본이 있다고 가정 복제본 db.r3.large : 2개 복제본 db.r5.xlarge : 2개 - 용량이 더 큼 Case: 특정 읽기전용 데이터베이스에 분석 쿼리 실행 용량이 더 큰 인스턴스 서브셋을 사용자 endpoint로 정의 ","date":"2022-08-06","objectID":"/aws-rds/:10:2","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Serverless 자동화 된 데이터베이스 인스턴스 및 실제 사용량을 기반으로 한 오토 스케일링 제공 간헐적이거나 예측할 수 없는 워크로드에 적합 용량 측정이 필요 없다 초당 비용 지불. 비용측면에서는 효과적 Serverless - 동작방식 Aurora에서 관리하는 Proxy Fleet과 통신 백엔드에서는 서버리스 방식으로 워크로드를 기반으로 한 Aurora 인스턴스 생성 ","date":"2022-08-06","objectID":"/aws-rds/:10:3","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Multi-Master 쓰기 전용 마스터에 즉각적인 장애 조치가 필요한 경우.(Writer 노드에 고가용성이 필요한 경우) 모든 노드가 읽기와 쓰기 작업을 진행 쓰기 노드가 다운될경우 읽기 본제본을 새로운 마스터로 승격 ","date":"2022-08-06","objectID":"/aws-rds/:10:4","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"글로벌 Aurora Aurora 리전 간 읽기 복제 재해복구에 유용 간단하게 구현 Aurora Global Database(추천) 하나의 읽기/쓰기 기본 리전 Primary Region 5개까지 보조 리전 설정 가능 : 읽기 전용이며, 보조 리전당 랙은 1초 미만 리전당 최대 16개의 읽기 전용 복제본을 가질 수 있다. 대기 시간 단축에 도움 RTO가 있으므로 복구 시간 목표는 1분 미만 ","date":"2022-08-06","objectID":"/aws-rds/:10:5","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora Machine Learning SQL을 통해 ML 기반의 예측을 애플리케이션에 추가 Aurora와 AWS ML 서비스를 쉽고, 최적화, 안전하게 통합할 수 있다. 지원되는 서비스 Amazon SageMaker (use with any ML model) Amazon Comprehend (for sentiment analysis) ML 경험이 없어도 된다. 사용사례 사기탐지, 광고 타게팅, 감정분석, 제품 추천 Amazon ElastiCache 캐시는 높은 성능과 낮은 지연 시간을 가진 in-memory 데이터베이스를 의미한다. RDS 동일한 방식으로 관계형 데이터베이스를 관리 Redis와 Memcached와 같은 캐시 기술 관리 읽기 집약적인 워크로드 부하를 줄일 수 있다. 애플리케이션에서 상태를 관리하지 않아도 된다. OS 운영, 패치, 최적화, 설치, 구성, 모니터링, 장애복구, 백업등의 기능을 AWS에서 주관한다. ElasticCache를 사용하면 애플리케이션 코드를 향상시킬 수 있다. ","date":"2022-08-06","objectID":"/aws-rds/:10:6","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"ElastiCache Solution Architecture ","date":"2022-08-06","objectID":"/aws-rds/:11:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"DB Cache 애플리케이션은 ElasticCache에서 쿼리 할 수 없는 경우 RDS에서 가져와 ElasticCache에 저장한다. RDS에 부하 완화 지원 캐시에는 최신 데이터만 사용 할 수 있도록 무효화 전략 필요 ","date":"2022-08-06","objectID":"/aws-rds/:11:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"사용자 세션 저장 사용자의 세션 데이터를 ElasticCache에 저장 애플리케이션은 ElasticCache에서 직접 사용자의 세션캐시를 검색 다른 인스턴스로 접근시에도 사용자 재로그인이 필요 없음 ","date":"2022-08-06","objectID":"/aws-rds/:11:2","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Redis vs Memcached ","date":"2022-08-06","objectID":"/aws-rds/:12:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Redis 자동화 된 재해 복구 + 다중 AZ 읽기 복제본을 통한 읽기 확장 및 고 가용성 AOP 지속성을 이용한 내구성 백업 및 복원 기능 ","date":"2022-08-06","objectID":"/aws-rds/:12:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Memcached 데이터를 파티셔닝 한 다중 노드 (sharding) 가용성이 낮음 복제 X. 지속성 X 백업 및 복원 기능 없음 다중 스레드 설계 분산 캐시 ","date":"2022-08-06","objectID":"/aws-rds/:12:2","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Cache Security IAM authentication 지원하지 않음 ElasticCache는 AWS API 수준 보안에서만 사용 ","date":"2022-08-06","objectID":"/aws-rds/:13:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Redis Auth 레디스 클러스터를 생성할 때 비밀번호나 토큰을 설정할 수 있다. 이는 security group에 대한 추가적인 수준의 보안 SSL 전송 중 암호화 지원 ","date":"2022-08-06","objectID":"/aws-rds/:13:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Memcached SASL 기반 인증 지원 ","date":"2022-08-06","objectID":"/aws-rds/:13:2","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"데이터 로드 패턴 ","date":"2022-08-06","objectID":"/aws-rds/:14:0","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Lazy Loading 모든 데이터를 읽은 후 캐시한 데이터를 로딩 할 수 있다. ","date":"2022-08-06","objectID":"/aws-rds/:14:1","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Write Through DB에 데이터를 쓸 때 캐시 데이터 추가 및 업데이트 요청 ","date":"2022-08-06","objectID":"/aws-rds/:14:2","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Session Store 임시 세션 데이터를 캐시에 저장 (TTL 기능 사용) ","date":"2022-08-06","objectID":"/aws-rds/:14:3","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Redis Use Case 게이밍 리더보드 계산 Redis Sorted set은 고유성과 순서 모두를 보장한다. 새 요소가 추가 될 때마다 실시간으로 순위 책정 ","date":"2022-08-06","objectID":"/aws-rds/:14:4","tags":["elasticsearch"],"title":"Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon S3 Amazon S3은 AWS의 주요한 서비스 중 하나이다. 무한 확장infinitely scaling 가능한 storage 많은 웹사이트에서 Amazon S3을 backbone으로 사용한다. AWS의 다수의 서비스에서도 Amazon S3 통합하여 사용할 수 있다. ","date":"2022-08-01","objectID":"/aws-s3/:1:0","tags":["elasticsearch"],"title":"Amazon S3","uri":"/aws-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon S3 Overview ","date":"2022-08-01","objectID":"/aws-s3/:2:0","tags":["elasticsearch"],"title":"Amazon S3","uri":"/aws-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Buckets Amazon S3에서는 object(files) 을 buckets(directories) 에 저장할 수 있다. 버켓은 반드시 전역적으로 유일globally unique name 해야 한다. 버켓은 region level 정의된다. (S3는 전역서비스지만 버켓은 리전리소스) Naming convention 대문자 불가 _ 불가 길이는 3~63 자리 IP 주소가 아닐 것 반드시 소문자로 또는 숫자로 시작 ","date":"2022-08-01","objectID":"/aws-s3/:2:1","tags":["elasticsearch"],"title":"Amazon S3","uri":"/aws-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Objects Object는 파일이며 키를 가짐 key는 전체경로full path를 나타낸다 s3://my-bucket/my_file.txt : my_file.txt이 키 값을 나타낸다. s3://my-bucket/my_folder1/another_folder/my_file.txt : my_folder1/another_folder/my_file.txt전체 경로가 키 값을 나타낸다. 키는 prefix + object name으로 구성되어있음. s3://my-bucket/my_folder1/another_folder/my_file.txt prefix : my_folder1/another_folder/ object name : my_file.txt 버켓에는 디렉토리 개념이 없다. (UI만 그럴뿐) 슬래시(\"/\")가 포함된 긴 이름만 키로 사용가능하다. Object의 값은 컨텐츠의 내용을 나타낸다. 최대 Object 크기는 5TB(5000GB) 5GB 이상 업로드하는 경우 Multi-part 업로드를 사용해야 한다. Metadata : 키/값 쌍으로 정의된 리스트. 시스템 또는 사용자 메타데이터로 사용 Tags : Unicode 키/값 쌍. 최대 10개까지 정의. 보안, lifecycle 정보를 지정시 유용 Version ID : versioning을 활성화 한 경우 Object의 버전별로 ID로 관리 ","date":"2022-08-01","objectID":"/aws-s3/:2:2","tags":["elasticsearch"],"title":"Amazon S3","uri":"/aws-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Versioning Amazon S3은 파일에 버전을 설정할 수 있다. 버켓 수준에서 활성화 가능 같은 키로 object를 overwrite 했을 때 버전이 증가된다. 버켓에는 버전을 지정하는 것을 권장한다. 버켓에 버전을 지정해야 하는 이유 의도하지 않은 삭제로부터 보호. 버전 복원 가능 이전 버전으로 쉽게 롤백이 가능하다. Note versioning을 활성화하기 전 저장되어 버전이 지정되지 않은 파일의 경우 버전은 “null\"이다. 버전 관리를 일시 중단해도 이전 버전은 삭제되지 않음. ","date":"2022-08-01","objectID":"/aws-s3/:2:3","tags":["elasticsearch"],"title":"Amazon S3","uri":"/aws-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"S3 Object의 암호화 ","date":"2022-08-01","objectID":"/aws-s3/:3:0","tags":["elasticsearch"],"title":"Amazon S3","uri":"/aws-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"S3 Object 암호화 방식 Amazon S3에 업로드 된 object는 AWS 서버내에 존재하므로 객체로 접근이 불가능하게 보호해야 한다. object의 암호화를 통해 보안을 강화할 수 있다. 방법 설명 SSE-S3 AWS에서 objects에서 사용하는 키를 처리 및 관리 SSE-KMS AWS Key Management Service를 통해 암호화 키를 관리 SSE-C 사용자가 자신의 암호화 키를 관리 Client Side Encryption 클라이언트에서 암호화 처리 SSE-S3 Amazon S3가 암호화 시 사용할 키를 처리 및 관리 Object는 서버 측에서 암호화 된다. 유형은 AES-256 알고리즘을 사용 SSE-S3 암호화를 사용하려면 아래 헤더를 반드시 설정해야 한다. “x-amz-server-side-encryption\": “AES256” 암호화 키는 S3가 소유하고 S3가 관리한다. SSE-S3 암호화 과정 Object HTTP/S로 헤더값을 지정하여 업로드 헤더를 통해 Amazon S3가 관리하는 데이터키를 통해 object를 encryption하여 버켓에 저장 SSE-KMS AWS Key Management Service(KMS)가 암호화 시 사용할 키를 처리 및 관리한다. KMS에서 사용자 제어 및 감시를 추적한다. Object는 서버 측에서 암호화 된다. SSE-KMS 암호화를 사용하려면 아래 헤더를 반드시 설정해야 한다. “x-amz-server-side-encryption\": ”aws:kms\" SSE-KMS 암호화 과정 Object HTTP/S로 헤더값을 지정하여 업로드 헤더를 통해 Amazon S3에서는 KMS의 사용자의 마스터키를 사용 KMS에서 가져오느 사용자의 마스터키로 object를 encryption하여 버켓에 저장 SSE-C AWS 밖에서 고객이 관리하는 키를 사용하여 서버측에서 데이터를 암호화 고객이 제공하는 암호화 키를 Amazon S3에서는 저장하지 않음 HTTPS를 반드시 사용 암호화 키는 매 요청시 마다 HTTP 헤더에 반드시 추가하여 전송 SSE-C 암호화 과정 Object는 반드시 HTTPS 만 가능하며 헤더에는 고객이 관리하는 암호화 키를 포함 사용자가 제공한 암호화 키로 Object를 암호화 하여 버켓에 저장 버켓에서 obejct를 가져올 때에는 저장당시 암호화 했던 키를 제공 Client Side Encryption Amazon S3 Encryption Client와 같은 라이브러리를 사용하여 클라이언트 측에서 암호화. S3로 전송하기 전에 클라이언트가 직접 데이터를 암호화해야 한다. 데이터를 검색할 때 클라이언트가 직접 데이터를 복호화해야 한다. 고객은 모든 키와 암호화 싸이클은 직접 관리 해야한다. ","date":"2022-08-01","objectID":"/aws-s3/:3:1","tags":["elasticsearch"],"title":"Amazon S3","uri":"/aws-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"전송 암호화 Encryption in transit (SSL/TLS) Amazon S3 endpoint HTTP endpoint : 암호화되지 않음 HTTPS endpoint : encryption in flight 원하는 endpoint를 자유롭게 선택할 수 있지만 HTTPS를 사용하는 것을 권장 대부분의 클라이언트는 HTTPS endpoint를 기본으로 사용한다. SSE-C 방식에서는 반드시 HTTPS가 필수사항 전송계층 상의 암호화를 SSL/TLS 라고 한다. ","date":"2022-08-01","objectID":"/aws-s3/:4:0","tags":["elasticsearch"],"title":"Amazon S3","uri":"/aws-s3/"},{"categories":["AWS Certified Solutions Architect Associate"],"content":"IAM:Identity and Access Management Global Service로 리전 상관없이 설정함 사용자Users는 조직내 사용자이며 그룹화 할 수 있다. 그룹Group는 오직 사용자users만 포함할 수 있고 다른 그룹은 포함할 수 없다. 사용자는 그룹에 속하지 않을수도 있고 여러 그룹에 속할 수도 있다. ","date":"2022-07-17","objectID":"/archives/devops/aws/aws/aws-iam/:0:0","tags":["AWS","solutions architect associate","IAM"],"title":"AWS IAM","uri":"/archives/devops/aws/aws/aws-iam/"},{"categories":["AWS Certified Solutions Architect Associate"],"content":"Permissions AWS 서비스 및 리소스를 액세스하고 사용하도록 허용하기 위해서는 권한을 부여해야한다. 사용자 또는 그룹에 정책policies이라고 하는 JSON 문서를 지정하게 된다. 정책은 사용자의 권한permissions을 정의한다. AWS에서는 최소 권한 원칙(least privilege principle)을 적용한다. 사용자에게 필요 이상의 권한을 부여하지 않는 것을 권장한다. ","date":"2022-07-17","objectID":"/archives/devops/aws/aws/aws-iam/:1:0","tags":["AWS","solutions architect associate","IAM"],"title":"AWS IAM","uri":"/archives/devops/aws/aws/aws-iam/"},{"categories":["AWS Certified Solutions Architect Associate"],"content":"Global Infrastructure Note AWS Regions AWS Availability Zones AWS Data Centers AWS Edge Locations / Points of Presence ","date":"2022-07-17","objectID":"/archives/devops/aws/aws/aws-regions-az/:0:0","tags":["AWS","solutions architect associate"],"title":"AWS Overview","uri":"/archives/devops/aws/aws/aws-regions-az/"},{"categories":["AWS Certified Solutions Architect Associate"],"content":"AWS Regions 데이터 센터의 집합 cluster of data centers 대부분의 AWS 서비스들은 특정 리전에 국한region-scoped되어 있다. 각 Region은 최소 두 개 이상의 개별 가용 영역Availability Zones로 구성 ","date":"2022-07-17","objectID":"/archives/devops/aws/aws/aws-regions-az/:1:0","tags":["AWS","solutions architect associate"],"title":"AWS Overview","uri":"/archives/devops/aws/aws/aws-regions-az/"},{"categories":["AWS Certified Solutions Architect Associate"],"content":"AWS Region을 선택하는 방법 Compliance with data governance and legal requirements : 데이터의 법률 준수 및 요구사항 Proximity to customers: : 고객과의 접근성. 대기시간 단축 Available services within a Region : 특정 리전에서만 가능한 AWS 서비인지 확인 Pricing : 비용은 지역에 따라 가격이 다르다. ","date":"2022-07-17","objectID":"/archives/devops/aws/aws/aws-regions-az/:1:1","tags":["AWS","solutions architect associate"],"title":"AWS Overview","uri":"/archives/devops/aws/aws/aws-regions-az/"},{"categories":["AWS Certified Solutions Architect Associate"],"content":"AWS Availability Zones 각각의 리전은 많은 가용영역으로 구성 (보통은 3개 최소 2개 최대 6개로 구성) ap-southeast-2a ap-southeast-2b ap-southeast-2c 다른 가용영역(AZ)의 장애로부터 격리되어 있다. 고대역폭, 초저지연 네트워킹으로 서로 연결되어 리전을 형성. ","date":"2022-07-17","objectID":"/archives/devops/aws/aws/aws-regions-az/:2:0","tags":["AWS","solutions architect associate"],"title":"AWS Overview","uri":"/archives/devops/aws/aws/aws-regions-az/"},{"categories":["AWS Certified Solutions Architect Associate"],"content":"AWS Points of Presence (Edge Locations) Amazon CloudFront에서는 현재 410개 넘는 상호 접속위치(POP)(엣지 로케이션 400개 이상, 리전별 중간 티어 캐시 13개)로 구성된 글로벌 네트워크를 사용 최종 사용자에게 짧은 지연 시간과 높은 처리량의 컨텐츠를 제공할 수 있다. [출처] https://aws.amazon.com/ko/cloudfront/features/ ","date":"2022-07-17","objectID":"/archives/devops/aws/aws/aws-regions-az/:3:0","tags":["AWS","solutions architect associate"],"title":"AWS Overview","uri":"/archives/devops/aws/aws/aws-regions-az/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon EC2 EC2는 AWS에서 제공하는 가장 인기있는 서비스 Elastic Compute Cloud = Infrastructure as a service 구성할 수 있는 기능 가상 머신 임대 (EC2) 가상 드라이브에 데이터를 저장 (EBS) 시스템 간 부하 분산 (ELB) auto-scaling group(ASG)를 사용하여 서비스 확장 ","date":"2022-07-13","objectID":"/aws-ec2/:1:0","tags":["aws","ec2"],"title":"AWS Elastic Compute Cloud (EC2)","uri":"/aws-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 sizing \u0026 configuration options Operating System(OS) : Linux, Windows or Mac OS 컴퓨터 성능과 코어양 선택 가능 (CPU) random-access memory (RAM) 스토리지 용량 Network-attached (EBS \u0026 EFS) hardware (EC2 Instance Store) Network card: 네트워크 카드 속도, 공용 IP 주소 방화벽 규칙 : security group Bootstrap script (configure at first launch): EC2 User Data ","date":"2022-07-13","objectID":"/aws-ec2/:1:1","tags":["aws","ec2"],"title":"AWS Elastic Compute Cloud (EC2)","uri":"/aws-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 User Data EC2 User Data를 사용하여 인스턴스를 부트스트랩 가능 bootstrapping이란 머신을 시작할 때 명령을 실행하는 것을 의미한다. 스크립트는 인스턴스 처음 시작시 한번만 실행 EC2 user data에서 자동화 할 수 있는 작업: 소프트웨어 및 업데이트 설치 인터넷으로 부터 공용파일 다운로드 등 EC2 User Data Script는 루트 계정으로 실행 ","date":"2022-07-13","objectID":"/aws-ec2/:1:2","tags":["aws","ec2"],"title":"AWS Elastic Compute Cloud (EC2)","uri":"/aws-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 인스턴스 종류 Amazon EC2 인스턴스 유형 AWS는 다음과 같은 네이밍 규칙을 따른다. m5.2xlarge m : 인스턴스 class 5 : 세대generation (AWS는 시간이 지남에 따라 개선 ) 2xlarge : 인스턴스 클래스 사이즈 ","date":"2022-07-13","objectID":"/aws-ec2/:1:3","tags":["aws","ec2"],"title":"AWS Elastic Compute Cloud (EC2)","uri":"/aws-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Users \u0026 Groups IAM = Identity and Access Management → Global 서비스 Root 계정으로 생성 Users 는 조직의 사용자이며 그룹으로 묶을 수 있다. Groups는 user를 포함할 수 있고 다른 그룹은 포함할 수 없다. user는 여러 그룹에 속할 수 있다. ","date":"2022-07-13","objectID":"/aws-iam/:1:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Permissions Users or Groups 은 JSON 문서형태로 정책을 할당 정책 polices는 사용자의 permissions을 정의 AWS에서는 최소 권한 원칙을 적용한다 → 사용자가 필요로 하는 것보다 더 많은 권한을 부여하지 않는다. ","date":"2022-07-13","objectID":"/aws-iam/:2:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Policies inheritance 인라인 정책 : 그룹에 속해있지 않아도 정책을 바로 사용자에게 연결 가능 ","date":"2022-07-13","objectID":"/aws-iam/:3:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Policies Structure { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"ec2:Describe*\", \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": \"elasticloadbalancing:Describe*\", \"Resource\": \"* }, { \"Effect\": \"Allow\", \"Action\": [ \"cloudwatch:ListMetrics\", \"cloudwatch:GetMetricStatistics\", \"cloudwatch:Describe*\" ], \"Resource\": \"*\" } ] } ","date":"2022-07-13","objectID":"/aws-iam/:4:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"요소 Version : 정책 버전 Id : 정책을 식별할 수 있는 식별자 - 옵션 Statement : 하나 혹은 여러개 (필수사항) ","date":"2022-07-13","objectID":"/aws-iam/:4:1","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Statements 요소 Sid : statement 의 식별자 (옵션) Effect : 특정 statement에 접근은 허용 여부 (Allow 또는 Deny)를 나타냄 Principal : 정책이 적용 될 대상 (계정, 사용자, 역할) Action : 정책의 허용 또는 거부되는 호출 리스트 목록 Resource : 정책이 적용될 리소스 목록 Condition : statement가 언제적용될지 결정 (옵션) ","date":"2022-07-13","objectID":"/aws-iam/:4:2","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Password Policy 강력한 비밀번호 → 계정에 대한 높은 보안 AWS에서는 설정가능한 패스워드 정책 패스워드 최소 길이 특수문자 포함 필수 입력 : 대소문자, 숫자, 특수문자 IAM 계정 사용자들의 패스워드 변경 허용 또는 금지 패스워드 만료 지정 패스워드 재사용 금지 ","date":"2022-07-13","objectID":"/aws-iam/:5:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"MFA - Multi Factor Authentication MFA = 패스워드(사용자만 알고있는) + 보안 장비(사용자가 소유하고 있는) ","date":"2022-07-13","objectID":"/aws-iam/:6:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"MFA devices options in AWS ","date":"2022-07-13","objectID":"/aws-iam/:7:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Virtual MFA device 하나의 디바이스에서 여러 토큰을 지원 Google Authenticator → phone only Authy → Multi device ","date":"2022-07-13","objectID":"/aws-iam/:7:1","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Universal 2nd Factor(U2F) Security Key YubiKey 하나의 키로 루트 그리고 IAM 사용자 지원 ","date":"2022-07-13","objectID":"/aws-iam/:7:2","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"기타 Hardware Key Fob MFA Device Hardware Key Fob MFA Device for AWS GovCloud (US) ","date":"2022-07-13","objectID":"/aws-iam/:7:3","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS 액세스 하는 방법 ","date":"2022-07-13","objectID":"/aws-iam/:8:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS 액세스하는 방법 AWS Management Console : 패스워드 + MFA 사용 AWS Command Line Interface CLI : access key 사용 AWS Software Developer Kit SDK : access key 사용 Access Key는 AWS 콘솔을 통해 생성할 수 있다. → 사용자 마다 생성 및 관리 Access Key는 패스워드와 같으므로 공유해서는 안된다. Access Key ID ~= username Secret Acees Key ~= password ","date":"2022-07-13","objectID":"/aws-iam/:8:1","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS CLI 커맨드라인 쉘에서 명령어를 사용하여 AWS 서비스와 상호작용 할 수 있도록 해주는 도구 CLI를 사용하면 AWS의 공용 API로 직접 액세스 가능 리소소를 자동화하여 관리할 수 있다. https://github.com/aws/aws-cli (오픈소스) AWS 관리 콘솔 대신 사용 가능 ","date":"2022-07-13","objectID":"/aws-iam/:9:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS SDK AWS Software Development Kit 특정 언어로 된 라이브러리 집합 프로그래밍으로 AWS에 액세스를 액세스하고 관리 응용 프로그램에 포함 지원 SDKs (Javascript, Python, PHP, .NET, Ruby, Java, Go, Node.js, C++) Mobile SDKs (Android, iOS…) IoT Device SDKs (Embedded C, Arduino…) ","date":"2022-07-13","objectID":"/aws-iam/:10:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Roles for Service 사용자 대신 작업을 수행하기 위한 IAM 역할을 가진 AWS 서비스에 사용자 권한을 할당 ","date":"2022-07-13","objectID":"/aws-iam/:11:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"공통역할 EC2 인스턴스 Roles Lambda Function Roles Roles for CloudFormation ","date":"2022-07-13","objectID":"/aws-iam/:11:1","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Security Tools ","date":"2022-07-13","objectID":"/aws-iam/:12:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Credentials Reports (account-level) 계정의 모든 사용자와 다양한 자격증명 상태를 나열하는 보고서 ","date":"2022-07-13","objectID":"/aws-iam/:12:1","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Access Advisor (user-level) 관리자는 사용자에게 부여된 서비스 권한과 마지막 액세스한 시기를 표시 이 정보를 활용하여 정책을 수정 할 수 있다. ","date":"2022-07-13","objectID":"/aws-iam/:12:2","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM 가이드라인 \u0026 모범 사례 루트 계정은 AWS 계정을 설정할 때를 제외하고 사용하지 않는다. 실제 유저 한명 = 하나의 AWS 유저 사용자를 그룹에 할당하고 그룹에 권한을 할당 강력한 패스워드 정책 사용 MFA(Multi Factor Authentication) 인증 사용 및 적용 AWS 서비스에 대한 사용 권한을 부여하는 역할 Roles 을 생성 및 사용 프로그래밍 방식의 액세스 키 사용 (CLI / SDK) IAM 자격증명 보고서를 사용한 계정 감사 IAM 유저와 액세스키 공유는 절대 하지 않는다 ","date":"2022-07-13","objectID":"/aws-iam/:13:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Summary Users AWS 콘솔에 대한 비밀번호를 갖는 실제사용자와 매핑 Gropus 오직 사용자만 그룹에 포함할 수 있다. 다른 그룹은 포함할 수 없다. Policies 사용자나 그룹이 할 수 있는 권한을 알려주는 문서이다. JSON 형태로 되어있다. Roles EC2와 같은 AWS 서비스에서 무언가를 할 수 있게 하는 권한을 주려고 할때 IAM Role을 만들어야 한다. Security 모범 사례는 MFA + Password Access Key AWS의 CLI, SDK 접근하기 위해 사용하는 자격증명 값이다. Audit IAM Credential Reports -\u003e IAM 자격증명 보고서 사용자 자격증명 내역 확인 IAM Access Advisor -\u003e IAM 액세스 관리자 최근 권한 사용내역 확인 ","date":"2022-07-13","objectID":"/aws-iam/:14:0","tags":["aws","iam"],"title":"AWS Identity and Access Management","uri":"/aws-iam/"},{"categories":["TIL \u0026 Issue Note"],"content":"개발 협업 가이드 우리 팀에서 내부 및 외부 공동 작업자가 개발 협업하기 위한 방법으로 애자일의 Scrum 방법론을 사용합니다. Scrum 관리를 위한 도구로는 GitLab의 이슈 시스템과 칸반보드 기능을 활용합니다. GitLab에 등록되는 이슈(Task)는 시스템 개발과 관련된 작업만 작성하도록 합니다. 프로젝트 계약 등 개발작업이 아닌 작업의 경우 Microsoft Planner의 칸반보드를 사용합니다. PBTeam – Microsoft Planner 사용가이드 GitLab은 Git 원격 저장소 관리, CI/CD, 이슈 관리, 테스트 등 소프트웨어 개발과 운영의 전반적인 라이프사이클을 관리할 수 있는 통합 툴입니다. Git과 GitLab에 익숙하지 않다면 아래 문서를 참고하여 숙지하시기 바랍니다. Git 간편 안내서 GitLab Documentation – GitLab basics ","date":"2022-06-27","objectID":"/archives/til/20220627/:0:0","tags":null,"title":"개발협업 가이드 Sample","uri":"/archives/til/20220627/"},{"categories":["TIL \u0026 Issue Note"],"content":"우리 팀이 Scrum을 진행하는 순서 PO(Product Owner)는 제품의 요구 기능(User Story)을 바탕으로 큰 틀 작업(Epic)을 정의합니다. PO는 Epic의 우선순위와 제품 개발 범위를 적용하여 Product Blacklog를 작성하고 팀원과 조율합니다. 개발 팀원은 스프린트 목표를 세우고 Product Blocklog를 linked issue하는 Sprint Backlog를 작성합니다. 우리 팀의 스프린트는 2주 단위로 진행합니다. 스크럼 마스터는 전반적인 스크럼 관리를 담당하게 됩니다. 매회의 스프린트가 종료할 때마다 스프린트 리뷰를 통해 만들어진 제품을 검토하고 개선사항을 토론하는 스프린트 리뷰를 갖습니다. 스프린트 리뷰가 끝나면 스프린트 회고를 통해 팀의 개발문화에 대한 개선 시간을 갖습니다. 다음 스프린트에서 수행할Backlog를 PO와 필요 인원이 모여 선정하고 계획합니다. ","date":"2022-06-27","objectID":"/archives/til/20220627/:1:0","tags":null,"title":"개발협업 가이드 Sample","uri":"/archives/til/20220627/"},{"categories":["TIL \u0026 Issue Note"],"content":"GitLab을 이슈를 통한 Scrum 관리 방법 GitLab의 이슈 시스템과 칸반보드로 Scrum을 관리합니다. 이슈를 통하여 아이디어 제안, 문제 해결, 작업 계획을 합니다. 작업자가 이슈를 제안하고 토론할 수 있습니다. 등록하는 사례는 아래와 같습니다. 새로운 아이디어 구현 논의 Task 및 상태 추적 기능 제안, 질문, 지원 요청 또는 버그 리포트 코드 구현 설명 [예시] Epic 유형의 이슈 이슈를 생성할 때 이슈 유형을 반드시 라벨로 추가해야 합니다. 이슈의 Description 항목에서 이슈 유형에 따른 템플릿을 선택할 수 있습니다. 이슈 유형은 다음과 같습니다. Issue(Task) 유형 Issue Type 정의 Epic(에픽) 작업의 큰 틀. 여러 작업의 모음 Task (작업) 작업, 업무, 해야할 일 Change (변경) 기존 기능의 변경 Improvement (개선) 기존 기능의 성능, 품질 개선 New Feature (새 기능) 새로운 아이디어 기능 제안 Document (문서 작업) 문서화 작업 Incident (장애) 장애 처리 Problem (문제) 결과값에 문제는 없지만 문제가 되는 상황 Bug(버그) 기존 기능의 오류 보고 Issue(Task) 생성시 필수 입력 사항 Milestone (Sprint backlog task) Label Assignee Linked issue 하나의 Task를 처리하는 과정에서 추가 Task가 발생하는 경우 또는 Task의 작업 규모가 생각했던 것 보다 커지는 경우 보다 작은 규모의 Task를 나누어져야 할 필요가 종종 발생합니다. 이런 경우 새로운 Task를 생성하고 작업중이던 Task를 linked issue로 설정합니다. ","date":"2022-06-27","objectID":"/archives/til/20220627/:2:0","tags":null,"title":"개발협업 가이드 Sample","uri":"/archives/til/20220627/"},{"categories":["TIL \u0026 Issue Note"],"content":"Git-Workflow 이슈는 Workflow에 따라 특정 status 값을 관리합니다. 전체적인 Workflow는 아래와 같습니다. Issue Workflow status 정의 Product Backlog 해야 할 과제.PO 관점에서 고객 요구사항(User Story)을 상세히 기술. 최초 작성은 PO가 진행 Sprint Backlog(To Do) Product Backlog의 Task 중 현재 스프린트 동안 구현하기로 결정 된 개발 작업 단위의 Task. Sprint Backlog에는 1day~3day 내에 처리할 수 있는 sub task를 담당자가 작성 Task가 3day 초과 시 새로운 task를 생성하고 작업 중인 task를 linked issue로 설정 Doing 진행 중(배포 대기중 포함) Done 과제가 끝남. 최종 확인자 확인 대기 Confirmed 최종 확인자 확인 완료 Cancel Task 취소 Reject 최종 확인자 반려 ","date":"2022-06-27","objectID":"/archives/til/20220627/:3:0","tags":null,"title":"개발협업 가이드 Sample","uri":"/archives/til/20220627/"},{"categories":["TIL \u0026 Issue Note"],"content":"Issue Workflow status에 따른 칸반보드 ","date":"2022-06-27","objectID":"/archives/til/20220627/:3:1","tags":null,"title":"개발협업 가이드 Sample","uri":"/archives/til/20220627/"},{"categories":["TIL \u0026 Issue Note"],"content":"브랜치 규칙 우리 팀은 Git-flow 브랜치 전략을 사용합니다. 브랜치는 5가지 종류의 브랜치를 사용합니다. master : 제품으로 출시될 수 있는 브랜치 develop : 다음 출시 버전을 개발하는 브랜치 feature : 기능을 개발하는 브랜치 release : 이번 출시 버전을 준비하는 브랜치 hotfix : 출시 버전에서 발생한 버그를 수정 하는 브랜치 ","date":"2022-06-27","objectID":"/archives/til/20220627/:4:0","tags":null,"title":"개발협업 가이드 Sample","uri":"/archives/til/20220627/"},{"categories":["TIL \u0026 Issue Note"],"content":"작업 순서 1. Bakclog이슈에 해당하는 feature 브랜치를 생성합니다. feature/issue-\u003c이슈번호\u003e 형식으로 브랜치를 생성합니다. feature 브랜치는 develop 브랜치에서부터 시작합니다. git 명령어를 이용하거나 GitLab이슈 수정 \u003e Create Branch 버튼으로도 생성할 수 있습니다. 2. 작업 브랜치에서 소스 코드 수정 후 변경사항을 커밋합니다. 3. 작업 브랜치를 origin에 푸시합니다. 4. GtiLab에 작업 브랜치를develop 브랜치로 merge하는 Pull Request를 생성합니다. 작업 브랜치 개발이 끝나면 작업브랜치의 Merge Request를 작성합니다. 타겟 브랜치는 develop을 선택합니다. Documentation 이슈 템플릿을 선택하여 내용을 작성합니다. Assignee는 MR을 등록하는 계정으로 지정하고 Reviewer는 동료 개발자 혹은 소스리뷰 담당자를 지정합니다. Sprint Backlog의 경우 Milestone을 선택합니다. Labels는 Documentation 지정합니다. 작성이 완료되면 Create Merge Request 버튼을 클릭합니다. 5. Merge Request 코드 리뷰 후 merge 같은 feature를 개발하는 동료에게 리뷰 승인을 받은 후 자신의 Pull Request를 merge합니다. 만약 혼자 feature를 개발한다면 1~2명의 동료에게 리뷰 승인을 받은 후 Pull Request를 merge 합니다. 리뷰어는 코드리뷰 후 승인버튼을 클릭합니다 리뷰어의 승인이 완료되면 merge 버튼을 클릭하여 develop 브랜치까지 merge 작업 완료합니다. ","date":"2022-06-27","objectID":"/archives/til/20220627/:5:0","tags":null,"title":"개발협업 가이드 Sample","uri":"/archives/til/20220627/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 개념의 등장 블록체인은 1991년 Stuart Haber와 W. Scott Stornetta가 1991년에 발표한 논문에서 블록체인의 개념을 처음으로 소개했다. 코인 혹은 블록체인이란 용어는 Satoshi Nakamoto의 논문 이후에 등장했다. How to time-stamp a digital document A blockchain is a growing list of records, called blocks, that are securely linked together using cryptography. - Wikipedia 위키피디아는 블록체인을 지속적으로 증가하는 데이터, 즉 블록이라고 불리는 데이터를 암호학을 통해 보호하고 연결하는 기술이라고 정의한다. ","date":"2022-06-20","objectID":"/archives/what-is-a-blockchain/:1:0","tags":["blockchain"],"title":"What is a Blockchain","uri":"/archives/what-is-a-blockchain/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록 ","date":"2022-06-20","objectID":"/archives/what-is-a-blockchain/:1:1","tags":["blockchain"],"title":"What is a Blockchain","uri":"/archives/what-is-a-blockchain/"},{"categories":["TIL \u0026 Issue Note"],"content":"HASH anders94 해싱 알고리즘 요구사항 단방향 (One) ","date":"2022-06-20","objectID":"/archives/what-is-a-blockchain/:2:0","tags":["blockchain"],"title":"What is a Blockchain","uri":"/archives/what-is-a-blockchain/"},{"categories":["TIL \u0026 Issue Note"],"content":" ECMAscript 모듈 Scope 관련 문제 Functions not working when type=\"module\" or import ","date":"2022-06-03","objectID":"/archives/til/20220603/:1:0","tags":["TIL","javascript","ECMAScript"],"title":"[TIL \u0026 Issue Note] 20220603","uri":"/archives/til/20220603/"},{"categories":["docker/kubernetes"],"content":" 시작하세요! 도커/쿠버네티스 책 정리 🐳🐳🐳 ","date":"2022-05-24","objectID":"/archives/docker-kubernetes/kubernetes/:0:0","tags":["kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 5. 쿠버네티스 설치","uri":"/archives/docker-kubernetes/kubernetes/"},{"categories":["docker/kubernetes"],"content":" 시작하세요! 도커/쿠버네티스 책 정리 🐳🐳🐳 ","date":"2022-05-23","objectID":"/archives/docker-kubernetes/chapter2-2-docker-engine/:0:0","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진 - 도커 네트워크","uri":"/archives/docker-kubernetes/chapter2-2-docker-engine/"},{"categories":["docker/kubernetes"],"content":"2.7 도커 네트워크 ","date":"2022-05-23","objectID":"/archives/docker-kubernetes/chapter2-2-docker-engine/:1:0","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진 - 도커 네트워크","uri":"/archives/docker-kubernetes/chapter2-2-docker-engine/"},{"categories":["docker/kubernetes"],"content":"도커 네트워크 구조 도커는 컨테이너 내부 IP를 순차적으로 할당한다. 이 IP는 컨테이너를 재시작 할 때마다 변경 될 수 있다. 각 컨테이너에 외부와의 네트워크를 제공하기 위해 각 컨테이너마다 가상 네트워크 인터페이스를 호스트에 생성한다. 이름은 veth(virtual eth)로 시작한다. docker0 브리지는 각 veth 인터페이스와 바인딩 되어 호스트의 eth0 인터페이스와 이어주는 역할을 한다. /// ","date":"2022-05-23","objectID":"/archives/docker-kubernetes/chapter2-2-docker-engine/:1:1","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진 - 도커 네트워크","uri":"/archives/docker-kubernetes/chapter2-2-docker-engine/"},{"categories":["docker/kubernetes"],"content":"도커 네트워크 기능 컨테이너를 생성하면 기본적으로 docker0 브릿지를 통해 통신한다. 도커가 자체적으로 제공하는 네트워크로는 bridge, host, none, container, overlay 가 있다. weave, flannel, openvswitch 등의 서드파티 플러그인 솔루션을 활용하여 확장된 네트워크를 구성할 수 있다. 도커 네트워크를 다루는 명령어 - docker network ","date":"2022-05-23","objectID":"/archives/docker-kubernetes/chapter2-2-docker-engine/:1:2","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진 - 도커 네트워크","uri":"/archives/docker-kubernetes/chapter2-2-docker-engine/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. ☁️ AWS Workshop 링크 : https://catalog.us-east-1.prod.workshops.aws/workshops/9c0aa9ab-90a9-44a6-abe1-8dff360ae428/ko-KR/ ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:0:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"인그레스 Ingress 클러스터 내의 서비스에 대한 외부 요청을 어떻게 처리할 것인지 네트워크 7계층 레벨에서 정의하는 쿠버네티스 오브젝트이다. 인그레스 오브젝트의 기본 기능은 다음과 같다. 외부 요청의 라우팅 : 특정 경로로 들어온 요청을 어떤 서비스로 전달할지 정의하는 라우터 규칙 설정 가상 호스트 기반의 요청 처리 : 같은 IP에 대해 다른 도메인 이름으로 요청했을 때 어떻게 처리할 것인지 정의 SSL/TLS 보안 연결 처리 : 요청을 라우팅 할 때, 보안 연결을 위한 인증서 적용 ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:1:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"인그레스를 사용하는 이유 쿠버네티스 서비스 타입 중 NodePort 혹은 LoadBalancer 타입의 서비스를 사용해도 외부로 노출할 수 있지만, 인그레스 없이 서비스를 사용할 경우 SSL/TLS 보안 연결 등의 상세 옵션을 각각의 서비스와 디플로이먼트에 대해 일일이 설정을 해야 한다. ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:1:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"인그레스 컨트롤러 인그레스는 요청을 처리하는 규칙을 정의하는 선언적 오브젝트이며 이런 인그레스 컨트롤러(Ingress Controller) 라는 서버에 적용해야만 그 규칙을 사용할 수 있다. 따라서 쿠버네티스의 인그레스는 반드시 인그레스 컨트롤러와 함께 사용해야 한다. kube-controller-manager의 일부로 실행되는 다른 컨트롤러와 달리 인그레스 컨트롤러는 클러스터와 함께 생성되지 않으므로, 직접 구현해야 한다. [출처] https://kubernetes.io/ko/docs/concepts/services-networking/ingress/ ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:2:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Load Balancer 컨트롤러 만들기 쿠버네티스 프로젝트에서는 AWS Load Balancer, GCE, Nginx Ingress 등의 인그레스 컨트롤러 프로젝트를 지원하고 있다. 워크샵 실습에는 AWS Load Balancer로 인그레스 컨트롤러를 생성했다. 사실 머선말인지는 잘 모르겠다… 조금 더 공부를 해야겠다능 🫠🫠🫠 AWS Load Balancer 컨트롤러는 쿠버네티스 ingress를 생성할 때 ALB(Application Load Balancer)와 NLB(Network Load Balancer)를 생성하고 관리한다. 쿠버네티스 Ingress를 생성할 때 Application Load Balancer으로 프로비저닝된다. 쿠버네티스 로드 밸런스 타입의 Service를 생성할 때, Network Load Balancer으로 프로비저닝된다. [출처] https://aws.amazon.com/blogs/opensource/kubernetes-ingress-aws-alb-ingress-controller/ Ingress 리소스가 kubernetes API에서 생성될 때 alb-ingress-controller는 변경 사항을 관찰한다. alb-ingress-controller는 ingress 리소스에 추가된 어노테이션을 기반으로 AWS ALB를 생성한다. 대상 그룹은 ingress 리소스에 지정된 각 back-end에 대해 생성된다. ALB URL은 경로 또는 쿼리 매개변수를 사용하여 액세스한다. Ingress 리소스에 구성된 규칙에 따라 요청은 특정 대상 그룹으로 리다이렉션되고 ClustIP 또는 NodePort를 사용하여 Pod 서비스에 도달한다. ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:3:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"ALB(Application Load Balancer) OSI 모델 Layer7에서 부하분산을 지원한다. HTTP, HTTPS 트래픽을 로드밸런싱해서 내부 인스턴스에 전달한다. IP주소 + 포트번호 + 패킷내용을 보고 로드밸런서 스위칭이 일어난다. 여러 도메인, 호스트, 경로 기반의 라우팅이 가능하다. ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:3:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"NLB(Network Load Balancer) OSI 모델 Layer4에서 부하분산을 지원한다. TCP/UDP 트래픽을 로드밸런싱해서 내부 인스턴스에 전달한다. 내부로 들어온 트래픽을 처리하고, 내부의 인스턴스로 트래픽을 전송한다. IP주소 + 포트번호로 로드밸런서 스위칭이 일어난다. ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:3:2","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"IAM OIDC(OpenID Connect) Identity Provider 생성 OpenID Connect Tokens 나중에 알아보자… AWS Load Balancer 컨트롤러가 워커 노드 위에서 동작하기 때문에 IAM permission을 통해 AWS ALB/NLB 리소스에 접근 가능한 OIDC를 먼저 생성해야 한다. ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:4:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"1. IAM OIDC(OpenID Connect) Identity Provider 생성 eksctl utils associate-iam-oidc-provider --region ap-northeast-2 \\ --cluster eks-demo \\ --approve 2022-05-08 22:46:25 [ℹ] eksctl version 0.95.0 2022-05-08 22:46:25 [ℹ] using region ap-northeast-2 2022-05-08 22:46:26 [ℹ] will create IAM Open ID Connect provider for cluster \"eks-demo\" in \"ap-northeast-2\" 2022-05-08 22:46:27 [✔] created IAM Open ID Connect provider for cluster \"eks-demo\" in \"ap-northeast-2\" ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:4:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"생성한 IAM OIDC Identity Provider 확인하기 (IAM 콘솔) IAM 자격 증명 공급자 콘솔(Identity Providers in IAM Console) 에서 클러스터에 대한 OIDC 자격증명 공급자를 확인할 수 있다. ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:4:2","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"2. AWS Load Balancer Controller에 부여할 IAM Policy 생성 IAM 정책은 AWS Load Balancer Controller가 사용자를 대신하여 AWS API를 호출하도록 허용한다. AWS 로드밸런서 컨트롤러의 IAM 정책 다운로드 curl -o /Users/riley/environment/manifests/alb-ingress-controller/iam_policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/main/docs/install/iam_policy.json AWSLoadBalancerControllerIAMPolicy라는 IAM Policy 생성 aws iam create-policy \\ --policy-name AWSLoadBalancerControllerIAMPolicy \\ --policy-document file:///Users/riley/environment/manifests/alb-ingress-controller/iam_policy.json ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:4:3","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"3. AWS Load Balancer Controller를 위한 Service Account 생성 AWS Load Balancer Controller에 쿠버네티스 서비스 계정에 대한 IAM 역할을 연결한다. - --attach-policy-arn=arn:aws:iam::$ACCOUNT_ID:role/$IAM_ROLE_NAME 자세한 내용은 문서를 참고 : IAM 역할을 서비스 계정에 연결 eksctl create iamserviceaccount \\ --cluster eks-demo \\ --namespace kube-system \\ --name aws-load-balancer-controller \\ --attach-policy-arn arn:aws:iam::$ACCOUNT_ID:policy/AWSLoadBalancerControllerIAMPolicy \\ --override-existing-serviceaccounts \\ --approve AWSLoadBalancerControllerIAMPolicy의 IAM Role을 갖는 EKS ServiceAccount 생성하고 Ingress와 Service에 ALB와 NLB를 각각 생성하고 관리할 수 있게 되었다. ","date":"2022-05-08","objectID":"/archives/devops/aws/aws-5-ingress-controller/:4:4","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/archives/devops/aws/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. ☁️ AWS Workshop 링크 : https://catalog.us-east-1.prod.workshops.aws/workshops/9c0aa9ab-90a9-44a6-abe1-8dff360ae428/ko-KR/ ","date":"2022-05-07","objectID":"/archives/devops/aws/aws-4-ecr/:0:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/archives/devops/aws/aws-4-ecr/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"Amazon ECR 리포지토리 생성 및 이미지 올리기 Amazon ECR(Elastic Container Registry) 은 도커 컨테이너의 이미지를 저장하는 Repository 서비스이다. Docker hub의 기능과 동일하다. ","date":"2022-05-07","objectID":"/archives/devops/aws/aws-4-ecr/:1:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/archives/devops/aws/aws-4-ecr/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS CLI로 이미지 리포지토리 생성 aws ecr create-repository \\ --repository-name demo-flask-backend \\ --image-scanning-configuration scanOnPush=true \\ --region ap-northeast-2 명령어가 수행되면 리포지토리에 대한 정보가 출력되며 Amazon ECR 콘솔창에서도 생성된 리포지토리를 확인할 수 있다. ","date":"2022-05-07","objectID":"/archives/devops/aws/aws-4-ecr/:1:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/archives/devops/aws/aws-4-ecr/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"이미지를 리포지토리로 푸시 이미지를 푸시하려는 리포지토리 선택 후 오른쪽 상단에 푸시 명령 보기(View push commands) 버튼을 클릭하면 푸시 명령어를 확인 할 수 있다. AWS 인증정보를 검색하여 도커 클라이언트를 인증한다. 아래 파라미터는 환경 변수로 지정하거나 직접 입력한다. ${AWS_REGION} : 사용 리전 $ACCOUNT_ID : IAM 계정 ID(숫자 12자리) aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com 도커 이미지 빌드 (AWS 워크샵 샘플 이미지 이용) cd ~/environment/amazon-eks-flask docker build -t demo-flask-backend . 이미지 빌드 완료 후 docker tag 태그 지정 docker tag demo-flask-backend:latest $ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/demo-flask-backend:latest 이미지를 리포지토리에 푸시 docker push $ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/demo-flask-backend:latest ","date":"2022-05-07","objectID":"/archives/devops/aws/aws-4-ecr/:1:2","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/archives/devops/aws/aws-4-ecr/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"푸시 된 리포지토리 확인 Amazon ECR \u003e 해당 리포지토리 클릭 하면 빌드된 이미지를 확인 할 수 있다. ","date":"2022-05-07","objectID":"/archives/devops/aws/aws-4-ecr/:1:3","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/archives/devops/aws/aws-4-ecr/"},{"categories":["docker/kubernetes"],"content":"Kubernetes 서비스 어카운트 인증정보 설정 kubectl 명령어를 사용해 크버네티스 클러스터를 제어할 때는 kubeconfig라고 하는 특수한 설정파일을 통해 인증을 진행한다. kubeconfig 파일에는 기본적으로 클러스터 관리자 권한을 가지는 인증서 정보가 저장되며 아무런 제한 없이 쿠버네티스를 사용할 수 있다. ","date":"2022-05-07","objectID":"/archives/docker-kubernetes/kubectl-change-context/:1:0","tags":["kubernetes","kubectl"],"title":"Kubernetes context 관리","uri":"/archives/docker-kubernetes/kubectl-change-context/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. ☁️ AWS Workshop 링크 : https://catalog.us-east-1.prod.workshops.aws/workshops/9c0aa9ab-90a9-44a6-abe1-8dff360ae428/ko-KR/ Amazon EKS 클러스터는 다양한 방식으로 배포할 수 있다. AWS 콘솔 창으로 배포 AWS CloudFormation 혹은 AWS CDK 와 같은 IaC(Infrastructure as Code) 도구를 사용해 배포 EKS의 공식 CLI인 eksctl 로 배포 Terraform, Pulumi, Rancher 등으로 배포 ","date":"2022-05-06","objectID":"/archives/devops/aws/aws-3-eks-cluster/:0:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/archives/devops/aws/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"eksctl로 Cluster 생성하기 아무 옵션없이 eksctl create cluster 실행하면 default parameter로 클러스터가 배포된다. 그러나 yaml 파일로 작성한 구성 파일을 작성하여 배포하면 구성파일에 명시한 오브젝트들의 바라는 상태(desired state)를 쉽게 파악하고 관리할 수 있는 이점이 있다. ","date":"2022-05-06","objectID":"/archives/devops/aws/aws-3-eks-cluster/:1:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/archives/devops/aws/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"1. Cluster 구성파일 작성 ~/environment/eks-demo-cluster.yaml apiVersion: eksctl.io/v1alpha5 kind: ClusterConfig metadata: name: eks-demo # 생성할 EKS 클러스터명 region: ap-northeast-2 # 클러스터를 생성할 리전 version: \"1.21\" vpc: cidr: \"192.168.0.0/16\" # 클러스터에서 사용할 VPC의 CIDR managedNodeGroups: - name: node-group # 클러스터의 노드 그룹명 instanceType: m5.large # 클러스터 워커 노드의 인스턴스 타입 desiredCapacity: 3 # 클러스터 워커 노드의 갯수 volumeSize: 10 # 클러스터 워커 노드의 EBS 용량 (단위: GiB) iam: withAddonPolicies: imageBuilder: true # Amazon ECR에 대한 권한 추가 # albIngress: true # albIngress에 대한 권한 추가 cloudWatch: true # cloudWatch에 대한 권한 추가 autoScaler: true # auto scaling에 대한 권한 추가 cloudWatch: clusterLogging: enableTypes: [\"*\"] ","date":"2022-05-06","objectID":"/archives/devops/aws/aws-3-eks-cluster/:1:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/archives/devops/aws/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"2. 명령어를 통해 클러스터를 배포한다. eksctl 클러스터 생성 관리 설정 참고 eksctl create cluster -f eks-demo-cluster.yaml 클러스터가 완전히 배포되는데까지는 약 15~20분이 소요된다. AWS CloudFormation 콘솔창에서도 진행사항을 파악할 수 있다. 생성한 클러스터 정보 확인 $ AWS_PROFILE=riley-admin eksctl get clusters 2022-05-07 22:52:40 [ℹ] eksctl version 0.95.0 2022-05-07 22:52:40 [ℹ] using region ap-northeast-2 NAME REGION EKSCTL CREATED eks-demo ap-northeast-2 True ","date":"2022-05-06","objectID":"/archives/devops/aws/aws-3-eks-cluster/:1:2","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/archives/devops/aws/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"3. kubectl 인증 정보 설정 컨텍스트 리스트 출력하기 $ kubectl config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE * eks-demo-cluster eks-demo.ap-northeast-2.eksctl.io Administrator@eks-demo.ap-northeast-2.eksctl.io kubectl 인증정보 alias 지정 $ kubectx eks-demo-cluster=Administrator@eks-demo.ap-northeast-2.eksctl.io Context \"Administrator@eks-demo.ap-northeast-2.eksctl.io\" renamed to \"eks-demo-cluster\". 컨텍스트 스위칭 # switch context kubectl config use-context eks-demo-cluster # kubectx로 switch context kubectx eks-demo-cluster 배포된 노드 확인 $ kubectx eks-demo-cluster Switched to context \"eks-demo-cluster\". $ kubectl get nodes NAME STATUS ROLES AGE VERSION ip-192-168-22-34.ap-northeast-2.compute.internal Ready \u003cnone\u003e 29m v1.21.5-eks-9017834 ip-192-168-58-247.ap-northeast-2.compute.internal Ready \u003cnone\u003e 29m v1.21.5-eks-9017834 ip-192-168-81-71.ap-northeast-2.compute.internal Ready \u003cnone\u003e 29m v1.21.5-eks-9017834 ","date":"2022-05-06","objectID":"/archives/devops/aws/aws-3-eks-cluster/:1:3","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/archives/devops/aws/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. ☁️ AWS Workshop 링크 : https://catalog.us-east-1.prod.workshops.aws/workshops/9c0aa9ab-90a9-44a6-abe1-8dff360ae428/ko-KR/ ☁️ 워크샵에는 Cloud9을 구축했지만 나는 따로 구축하지는 않았다… ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:0:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS CLI ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:1:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS CLI 설치하기 (Mac OS) AWS Command Line Interface는 command-line shell 명령어를 사용하여 AWS 서비스의 EC2, VPC 등과 같은 AWS의 리소스를 프로비저닝 할 수 있다. Mac OS는 pkg 파일을 다운로드 하여 설치한다. Mac OS : https://awscli.amazonaws.com/AWSCLIV2.pkg 다른 OS에서 AWS CLI 설치하기 $ aws --version aws-cli/2.6.1 Python/3.9.11 Darwin/21.4.0 exe/x86_64 prompt/o ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:1:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Credential Configure AWS CLI에서 자주 사용되는 구성 설정과 자격 증명을 저장할 수 있다. aws configure 명령어를 통해 자주 사용하는 자격증명 정보를 저장 할 수 있다. 자세한 설명은 여기를 참고한다. aws configure --profile 명령어를 통해 여러 AWS 계정에 접근하도록 관리할 수 있다. –profile 옵션에 계정 이름을 할당한다. aws configure --profile riley-admin 19:05:42 › aws configure AWS Access Key ID [None]: ****************SUIB # IAM 계정 Access Key ID 입력 AWS Secret Access Key [None]: ****************1eOn # IAM 계정 Secret Access Key 입력 Default region name [None]: ap-northeast-2 # 리전 입력 Default output format [None]: json # json 인증 설정 확인하기 인증설정은 cat ~/.aws/config, cat ~/.aws/credentials에 나누어 저장된다. cat ~/.aws/config [profile riley-admin] region = ap-northeast-2 output = json 23:36:50 › cat ~/.aws/credentials [riley-admin] aws_access_key_id = ~~~~~~ aws_secret_access_key = ~~~~~ 테스트 # ec2 인스턴스 조회 aws ec2 describe-instances --profile riley-admin aws sts get-caller-identity # default aws sts get-caller-identity --profile riley-admin ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:1:2","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"kubectl 설치 ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:2:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"kubectl 설치하기 kubectl은 쿠버네티스 클러스터에 명령을 내리는 CLI이다. 쿠버네티스는 오브젝트 생성, 수정, 삭제와 관련한 동작을 수행하기 위해 쿠버네티스 API를 사용한다. 이때 kubectl CLI을 사용하여 해당 명령어가 쿠버네티스 API를 호출하여 관련 동작을 수행한다. Installing kubectl에 접속하여 배포할 Amazon EKS 버전과 상응하는 kubectl를 설치한다. # To install kubectl on macOS $ curl -o kubectl https://s3.us-west-2.amazonaws.com/amazon-eks/1.22.6/2022-03-09/bin/darwin/amd64/kubectl $ chmod +x ./kubectl $ mkdir -p $HOME/bin \u0026\u0026 cp ./kubectl $HOME/bin/kubectl \u0026\u0026 export PATH=$HOME/bin:$PATH kubectl 설치 후 버전 명령어를 통해 잘 설치되었는지 확인한다. $ kubectl version --short --client Client Version: v1.21.2-13+d2965f0db10712 ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:2:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"Kubectl 인증 정보 설정 Kubernetes context 관리 ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:2:2","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"eksctl 설치하기 ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:3:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"eksctl 설치하기 eksctl이란 EKS 클러스터를 쉽게 생성 및 관리하는 CLI 툴 이다. 아래 링크를 통해 해당 OS에 최신 eksctl 바이너리를 직접 다운로드 하거나 해당 명령어를 통해 다운로드 한다. https://github.com/weaveworks/eksctl/releases # To install eksctl on macOS (intel) $ curl --silent --location \"https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz\" | tar xz -C ~/tmp $ sudo mv -v ~/tmp/eksctl /usr/local/bin $ eksctl version ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:3:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"EKS IAM 계정 연결 …(정리중) ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-2-cli/:4:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/archives/devops/aws/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 실습 내용입니다. ☁️ AWS Workshop 링크 : https://catalog.us-east-1.prod.workshops.aws/workshops/9c0aa9ab-90a9-44a6-abe1-8dff360ae428/ko-KR/ ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-eks-cloud9/:0:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/archives/devops/aws/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Cloud9 AWS Cloud9 은 브라우저만으로 코드를 작성, 실행 및 디버깅할 수 있는 IDE(통합개발환경)이다. 코드 편집기, 디버거 및 터미널 기능을 포함하고 있고 프로그래밍 언어를 위한 필수 도구가 사전에 패키징 되어 제공된다. ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-eks-cloud9/:1:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/archives/devops/aws/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Cloud9 시작하기 ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-eks-cloud9/:2:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/archives/devops/aws/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Cloud9 IDE 구성 AWS Cloud9 콘솔 접속 후 Create environment 버튼 클릭 IDE의 Environment 이름 및 설명을 작성한다. 인스턴스 타입을 t3.medium으로, 플랫폼의 경우 Amazon Linux 2 (recommended) 설정 Next Step을 클릭하여 지정한 속성 확인 후 Create environment 클릭하여 environment 생성한다. 생성 완료 ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-eks-cloud9/:2:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/archives/devops/aws/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"IAM Role 생성 IAM Role은 특정 권한을 가진 IAM 자격 증명이다. 서비스에 IAM Role을 부여할 경우 서비스가 사용자를 대신하여 수임받은 역할을 수행할 수 있다. 아래는 Administrator access 정책을 가진 IAM Role을 생성하고 AWS Cloud9에 연결한다. IAM 대시보드로 접속 후 액세스 관리 \u003e 역할 \u003e 역할 만들기 를 클릭한다. 역할 이름(Role name)에는 eksworkspace-admin 입력 후 권한에는 AdministratorAccess 관리형 정책을 추가하고 역할 생성 버튼을 클릭한다. 실제 환경에서는 AdministratorAccess 정책보다는 환경을 구동할 최소 권한만 부여하는 것이 좋다. ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-eks-cloud9/:3:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/archives/devops/aws/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"IDE(AWS Cloud9 인스턴스)에 IAM Role 부여 EC2 대시보드로 접속한다. 앞에서 생성한 Cloud9 EC2 인스턴스를 선택한다. 작업 \u003e 인스턴스 설정 \u003e IAM 역할 연결/바꾸기를 클릭하여 EC2 콘솔에서 AWS Cloud9 인스턴스에 위에서 생성한 IAM Role을 부여한다. IAM Role에서 eksworkspace-admin 선택 후 저장 ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-eks-cloud9/:3:1","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/archives/devops/aws/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"Cloud9 IDE에서 IAM 설정 업데이트 AWS Cloud9은 IAM Credentials를 동적으로 관리한다. 생성한 credentials는 EKS IAM authentication과 호환되지 않기에 이를 비활성화하고 IAM Role을 붙인다. (🤔 머선말인지 잘 모르겠지만…) ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-eks-cloud9/:3:2","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/archives/devops/aws/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. ☁️ AWS Workshop 링크 : https://catalog.us-east-1.prod.workshops.aws/workshops/9c0aa9ab-90a9-44a6-abe1-8dff360ae428/ko-KR/ ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-1-eks-iam/:0:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 1. IAM 계정 생성","uri":"/archives/devops/aws/aws-1-eks-iam/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"IAM 계정 생성 AWS 계정의 루트사용자로 로그인한다. IAM 대시보드에서 액세스 관리 \u003e 사용자 \u003e 사용자 추가를 선택한다. 사용자 이름을 입력 후 Access type에서 암호-AWS 관리 콘솔 액세스 선택 사용자 지정 비밀번호로 비밀번호 생성한다. 기존 정책 직접 연결(Attach existing policies directly) 선택 후 부여하려는 정책을 선택하여 다음:태그(Next:Tags) 버튼을 클릭. 태그 추가(선택 사항) 단계 후 최종 생성 정보를 확인하고 사용자 만들기(Create User) 클릭하여 생성한다. 사용자가 추가되면 로그인 URL이 생성된다! https://\u003cyour_aws_account_id\u003e.signin.aws.amazon.com/console 루트 사용자에서 로그아웃 후, IAM 계정 URL로 접속하여 로그인 한다. ","date":"2022-05-05","objectID":"/archives/devops/aws/aws-1-eks-iam/:1:0","tags":["aws","eks","kubernetes","ecs","ecr"],"title":"[AWS EKS] 1. IAM 계정 생성","uri":"/archives/devops/aws/aws-1-eks-iam/"},{"categories":["tucker-go"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 정리하였습니다. ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:0:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"1. 인터페이스 정의 ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:1:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"인터페이스 선언 인터페이스 선언은 type을 쓴 뒤 인터페이스 명을 쓰고 interface 키워드를 쓴다. 그런 뒤 {} 블록 안에 인터페이스에 포함된 메서드 집합을 써준다. type DuckInterface interface { Fly() Walk(distance int) int } 유의사항 메서드는 반드시 메서드명이 있어야한다. 매개변수와 반환이 다르더라도 이름이 같은 메서드는 있을 수 없다. 인터페이스에서는 메서드 구현을 포함하지 않는다. 인터페이스 선언 예제 package main import \"fmt\" type Stringer interface { String() string } type Student struct { Name string Age int } func (s Student) String() string { return fmt.Sprintf(\"안녕! 나는 %d살 %s라고 해.\", s.Age, s.Name) } func main() { student := Student{\"쳘수\", 5} var stringer Stringer stringer = student fmt.Printf(\"%s\\n\", stringer.String()) } ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:1:1","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"2. 인터페이스를 사용하는 이유 인터페이스는 객체 지향 프로그래밍에서 아주 중요한 역할을 한다. 인터페이스를 이용하면 구체화된 객체가 아닌 인터페이스만 가지고 메서드를 호출할 수 있기 때문에 큰 코드 수정 없이 필요에 따라 구체화 된 객체로 바꿔 사용할 수 있다. ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:2:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"추상화 계층 추상화(abstraction) : 내부 동작을 감춰서 서비스를 제공하는 쪽과 사용하는 쪽 모두에게 자유를 주는 방식. 인터페이스는 추상화를 제공하는 추상화 계층(abstraction layer) 이다. 인터페이스를 사용하여 서로 결합하고 의존성을 줄이는 것을 디커플링(decoupling) 이라고 한다. 구체화된 타입으로 상호작용하는게 아니라 추상화된 관계로 상호작용함으로써 결합도를 낮추고 의존관계를 줄이므로써 이후 유지 보수를 용이하 하고 유연성을 확보할 수 있다. ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:2:1","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"3. 덕 타이핑 Go 언어에서는 어떤 타입이 인터페이스를 포함하고 있는지 여부를 결정할 때 덕 타이핑(duck typing) 방식을 사용한다. 덕 타이핑 방식은 타입 선언 시 인터페이스 구현 여부를 명시적으로 나타낼 필요 없이 인터페이스에 정의한 메서드 포함 여부로만 결정하는 방식이다. Stringer 인터페이스를 정의 type Stringer interface { String() string } Stringer 인터페이스 포함 여부를 명시적으로 나타내지 않아도 String() 메서드를 포함하는 것 만으로 Stringer 인터페이스를 사용할 수 있다. type Student struct { ... } func (s *Student) String() string { ... } 만약 Go 언어가 덕 타이핑을 지원하지 않았더라면, implements 와 같은 키워드를 써서 명시적으로 Stringer 구현 여부를 표시해야 했을 것이다. type Student struct implements Stringer { ... } ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:3:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"덕 타이핑의 장점 서비스 사용자 중심의 코딩을 할 수 있다. 덕 타이핑은 인터페이스 구현 여부를 타입 선언에서 하는게 아니라 사용될 때 해당 타입이 인터페이스에 정의된 메서드를 포함했는지 여부로 결정한다. 따라서 서비스 제공자가 인터페이스를 정의 할 필요 없이 구체화된 객체만 제공하고 서비스 이용자가 필요에 따라 그때그때 인터페이스를 정의해서 사용할 수 있다. ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:3:1","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"4. 인터페이스 기능 더 알기 포함된 인터페이스 빈 인터페이스 인터페이스 기본값 ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:4:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"인터페이스를 포함하는 인터페이스 구조체에서 다른 구조체를 포함된 필드로 가질 수 있듯이 인터페이스도 다른 인터페이스를 포함할 수 있다. 이를 포함된 인터페이스라고 부른다. // 1) Read()와 Close() 메서드를 포함한 Reader 인터페이스 type Reader interface { Read() (n int, err error) Close() error } // 2) Write() 메서드와 Close() 메서드를 포함한 Writer 인터페이스 type Writer interface { Write() (n int, err error) Close() error } // 3) Reader, Writer 인터페이스의 메서드 집합을 모두 포함한 ReadWriter 인터페이스 type ReadWriter interface { Reader // Reader의 메서드 집합을 포함 Writer // Writer의 메서드 집합을 포함 } ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:4:1","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"빈 인터페이스 interface{}는 메서드를 가지고 있지 않은 빈 인터페이이다. 가지고 있어야 할 메서드가 하나도 없기 때문에 모든 타입이 빈 인터페이스로 쓰일 수 있다. 빈 인터페이스는 어떤 값이든 받을 수 있는 함수, 메서드, 변수값을 만들 때 사용한다. package main import \"fmt\" func PrintVal(v interface{}) { switch t := v.(type) { case int: fmt.Printf(\"v is int %d\\n\", int(t)) case float64: fmt.Printf(\"v is float64 %f\\n\", t) case string: fmt.Printf(\"v is string %s\\n\", string(t)) default: fmt.Printf(\"Not supported Type : %T: %v\", t, t) } } type Student struct { Age int } func main() { PrintVal(10) PrintVal(3.14) PrintVal(\"Hello\") PrintVal(Student{15}) } ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:4:2","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":"인터페이스 기본값 nil 인터페이스 변수의 기본값은 nil이다. package main type Attacker interface { Attack() } func main() { var att Attacker att.Attack() // Error! att의 초기값이 없기 때문에 기본값인 nil } invalid memory address로 비정상적인 메모리 주소에 접근해서 프로그램 실행중에 런타임 에러가(runtime error) 발생한다. ","date":"2022-04-27","objectID":"/archives/tucker-go/chapter19-interface/:4:3","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 19. Go 인터페이스","uri":"/archives/tucker-go/chapter19-interface/"},{"categories":["tucker-go"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 정리하였습니다. 슬라이스는 Go에서 제공하는 동적 배열 타입이다. 동적 배열은 실행 도중 배열의 사이즈가 계속 바뀔 수 있다. 정적, 동적 상수와 변수의 차이를 생각하면 간단하다. 정적(static) : compile time, build time 시 값이 결정된다. 실행 도중에 절대 바뀔 수 없다. 동적(dynamic) : Runtime. 프로그램 실행 도중에 계속 값이 바뀔 수 있다. 다른언어에서 slice와 비슷한 개념 (동일하지는 않다.) C++ : Vector\u003cint\u003e Java : ArrayList Python : slice Javascript : 기본적으로 동적 배열 ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:0:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"1. 슬라이스 배열과 비슷하지만 []에 배열의 개수를 적지 않고 선언한다. ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:1:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"1.1 슬라이스 선언 var slice []int { } 를 이용해 초기화하기 var slice1 = []int{1, 2, 3} // 대괄호 안에 길이를 넣지 않는 것을 주의 var slice2 = []int{1, 5:2, 10:3} // [1 0 0 0 0 2 0 0 0 0 3] var array = [...]int{1, 2, 3} // 배열 선언 var slice = []int{1, 2, 3} // 슬라이스 선언 make()를 이용한 초기화 내장함수인 make()를 사용하여 초기화 할 수 있다. var slice = make([]int, 3) // 3개의 길이를 갖는 int 슬라이스 // 결과 [0 0 0] ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:1:1","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"1.2 슬라이스 요소 접근 슬라이스 요소에 접근하는 방법은 배열과 동일하다. 대괄호 사이에 인덱스를 써서 요소에 접근한다. var slice = make([]int, 3) slice[1] = 5 ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:1:2","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"1.3 슬라이스 순회 방법 var slice = []int{1, 2, 3} // for loop for i := 0; i \u003c len(slice); i++ {} // for range for i, v := range slice {} ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:1:3","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"1.4 슬라이스 요소 추가 - append() append()는 첫 번째 인수로 들어온 슬라이스에 요소가 추가된 새로운 슬라이스를 반환한다. var slice = []int{1, 2, 3} slice := append(slice, 4) 하나 이상 값도 추가가 가능하다. slice = append(slice, 3, 4, 5, 6, 7) ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:1:4","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"2. 슬라이스의 동작 원리 슬라이스는 내장 타입으로 내부 구현이 감추어져있지만 reflect 패키지의 SliceHeader 구조체를 사용해 내부 구현을 볼 수 있다. type SliceHeader struct { Data uintptr // 실제 배열을 가리키는 포인터 Len int // 요소 개수 Cap int // 실제 배열의 길이0 } [그림] SliceHeader 구조체 ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:2:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"2.1 Make() 함수를 사용해서 선언 make() 함수로 슬라이스를 생성할 때 인수값에 따라 배열길이와 배열의 최대 크기를 지정할 수 있다. var slice = make([]int 3) // len:3, cap:3 (요소개수 3, 최대길이 3) var slice2 = make([]int, 3, 5) // len:3, cap:5 (요소개수 3, 최대길이 5) ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:2:1","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"2.2 슬라이스와 배열의 동작 차이 SliceHeader 구조체에서 Data는 실제 배열을 참조하고 있다. 그렇기 때문에 배열과 동작에서 차이가 있으며 사용법이 비슷하다고 해서 똑같이 사용했을 경우 예기치 못한 버그를 만날 수 있다. package main import \"fmt\" func changeArray(arr [5]int) { arr[2] = 200 // 서로 다른 메모리 공간 } func changeSlice(slice []int) { slice[2] = 200 } func main() { arr := [5]int{1, 2, 3, 4, 5} slice := []int{1, 2, 3, 4, 5} changeArray(arr) changeSlice(slice) fmt.Println(\"배열 : \", arr) fmt.Println(\"슬라이스 : \", slice) } 결과 배열 : [1 2 3 4 5] 슬라이스 : [1 2 200 4 5] ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:2:2","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"2.3 동작 차이의 원인 Go 언어에서 대입연산은 값을 복사하는 것이다. 포인터는 포인터의 값이 메모리값 주소가 복사, 구조체는 구조체의 모든 필드 값이 복사된다. 함수의 매개변수는 값 복사가 발생한다. changeArray(arr [5]int) 함수의 매개변수 arr은 배열이므로 int 5개짜리 배열의 값이 복사되어 main() 함수의 arr와는 별개의 인스턴스가 된다. (총 8byte * 5= 40 byte) changeSlice(slice []int) 함수의 매개변수 slice []int는 실제 배열을 가리키는 포인터, len, cap 세 개의 필드로 구성된 구조체이다. 구조체의 값이 그대로 복사되므로 실제 배열을 가리키는 포인터의 메모리 주소도 함께 복사되어 사용된다. (8byte * 3 = 24 byte) ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:2:3","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"2.4 append()를 사용할 때 발생할 수 있는 예기치 못한 문제 - 1 빈 공간이 충분할 때 append() 함수가 호출되면 먼저 슬라이스에 값을 추가할 수 있는 빈공간이 있는지 확인한다. 남은공간은 실제 배열 길이 cap에서 슬라이스 요소개수 len을 뺀 값을 의미한다. 남은공간 = cap - len package main import \"fmt\" func main() { slice1 := make([]int, 3, 5) // 1) slice2 := append(slice1, 4, 5) // 2) fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) slice1[1] = 100 // 3) fmt.Println(\"After change second element\") fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) slice1 = append(slice1, 500) // 4) fmt.Println(\"After change second element\") fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) } 결과 slice1 : [0 0 0] 3 5 slice2 : [0 0 0 4 5] 5 5 After change second element slice1 : [0 100 0] 3 5 slice2 : [0 100 0 4 5] 5 5 After change second element slice1 : [0 100 0 500] 4 5 slice2 : [0 100 0 500 5] 5 5 1) 요소개수 3, 최대길이 5의 슬라이스 구조체가 생성된다. 이때 남은 길이는 5-3 = 2개이다. 2) append() 함수가 호출되면 slice1의 배열에 빈공간이 있는지 확인한다. 두 개의 빈공간이 있으므로 4, 5를 추가할 수 있다. append()는 빈 공간에 값을 추가하고 요소 값이 2개 증가 된 슬라이스 구조체 (slice2)를 반환한다. 같은 구조체 값이 복사되었으므로 slice1과 slice2가 참조하는 배열의 주소값은 같다. 3) 같은 배열 주소를 참조하므로 변경된 값이 동일하게 적용되었다. 4) append() 함수를 통해 slice1에 빈공간이 있는지 확인하고 slice1[len] 자리에 500을 쓰고 len 값을 1 증가 시킨다. ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:2:4","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"2.5 append()를 사용할 때 발생할 수 있는 예기치 못한 문제 - 2 빈 공간이 충분하지 않을 때 append() 함수 실행시 빈 공간이 충분하지 않으면 더 큰 새 배열을 생성 한다. (일반적으로 두배 크기로 마련한다.) 그 다음 기존의 배열의 모든 요소를 새로운 배열에 복사한다. cap은 새로운 배열의 길, len은 기존 길이에 추구한 요소 개수만큼 더한 값이 된다. 포인터는 새로 생성한 배열을 가리키는 슬라이스 구조를 갖는다. package main import \"fmt\" func main() { slice1 := []int{1, 2, 3} // 1) slice2 := append(slice1, 4, 5) // 2) fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) slice1[1] = 100 // 3) fmt.Println(\"After change second element\") fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) slice1 = append(slice1, 500) // 4) fmt.Println(\"After change second element\") fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) } 결과 slice1 : [1 2 3] 3 3 slice2 : [1 2 3 4 5] 5 6 After change second element slice1 : [1 100 3] 3 3 slice2 : [1 2 3 4 5] 5 6 After change second element slice1 : [1 100 3 500] 4 6 slice2 : [1 2 3 4 5] 5 6 1) 1,2,3 len:3 cap:3인 슬라이스가 생성 2) append() 함수가 호출 되었을 때 4,5를 추가할 빈공간이 없으므로 새료운 배열을 생성하고 4,5를 추가 후 len:5, cap:6을 갖는 새로운 슬라이스를 반환한다. 3), 4) slice2의 경우 capacity가 늘어난 새로운 배열을 참조하므로 slice1만 변경된다. 정리 append()는 슬라이스가 가리키고 있는 배열의 capacity가 충분하면 값을 추가하고 그 배열을 참조값을 갖는 슬라이스 구조체를 리턴한다. capacity가 충분하지 않으면 더 큰 배열을 생성하고 생성된 새로운 배열을 참조하는 슬라이스 구조체를 리턴한다. ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:2:5","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"3. 슬라이싱 slicing 슬라이싱은 배열의 일부를 집어내는 기능이다. 슬라이싱하면 그 결과로 배열 일부를 가리키는 슬라이스를 반환한다. 새로운 배열이 만들어지는게 아니라 배열의 일부를 포인터로 가리키는 슬라이스를 반환하게 된다. array[startIndex:endIndex] ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:3:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"3.1 슬라이싱으로 배열 일부를 가르키는 슬라이스 만들기 package main import \"fmt\" func main() { arr := [5]int{1, 2, 3, 4, 5} slice := arr[1:2] // 1) fmt.Println(\"array : \", arr) fmt.Println(\"slice : \", slice, len(slice), cap(slice)) arr[1] = 100 // 2) fmt.Println(\"After change second element\") fmt.Println(\"array : \", arr) fmt.Println(\"slice : \", slice, len(slice), cap(slice)) slice = append(slice, 500) // 3) fmt.Println(\"After append 500\") fmt.Println(\"array : \", arr) fmt.Println(\"slice : \", slice, len(slice), cap(slice)) } 결과 array : [1 2 3 4 5] slice : [2] 1 4 After change second element array : [1 100 3 4 5] slice : [100] 1 4 After append 500 array : [1 100 500 4 5] slice : [100 500] 2 4 1) array 배열의 시작 인덱스 1 끝 인덱스 이전 인덱스 범위의만 집어낸다. (len:1, capacity:4) 2) slice가 array의 두번째 값을 가리키기 때문에 array의 값이 바뀌면 slice값도 바뀐다. 3) slice의 capacity가 4이므로 새로운 배열을 만들지 않고 array의 인덱스 2의 값을 변경하게 된다. ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:3:1","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"3.2 슬라이스를 슬라이싱 하기 슬라이싱 기능은 배열 뿐만 아니라 슬라이스 일부를 집어낼 때도 사용할 수 있다. func main() { arr := [100]int{1: 1, 2: 2, 99: 100} slice1 := arr[1:10] slice2 := slice1[2:99] fmt.Println(slice1) fmt.Println(slice2) } 결과 [1 2 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 100] 처음부터 슬라이싱 slice1 := []int{1, 2, 3, 4, 5} slice2 := slice[0:3] // 생략 가능 slice2 := slice[:3] 끝까지 슬라이싱 slice1 := []int{1, 2, 3, 4, 5} slice2 := slice1[2:len(slice1)] // [3, 4, 5] // 생략 가능 slice2 := slice1[2:] // [3, 4, 5] 전체 슬라이싱 array := [5]int{1, 2, 3, 4, 5} slice := array[:] 인덱스 3개로 슬라이싱하여 cap 크기를 조절 인덱스를 2개만 사용할 경우 cap은 배열의 전체 길이 - 시작인덱스를 뺀 값이 된다. 인덱스 3개를 사용하면 cap 값을 조절할 수 있다. slice[시작인덱스 : 끝인덱스 : 최대인덱스] slice1 := []int{1, 2, 3, 4, 5} slice2 := slice1[1:3:4] ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:3:2","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"4. 유용한 슬라이싱 기능 활용 ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:4:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"4.1 슬라이스 복제 슬라이스를 그대로 복사해서 새로운 슬라이스를 만들면 두 슬라이스가 서로 영향을 주지 않는다. 슬라이스를 복제하는 방법은 여러가지 이며 성능상 차이는 없기 때문에 편한 방법을 이용한다. 반복문을 이용한 값 복제 func main() { slice1 := []int{1, 2, 3, 4, 5} slice2 := make([]int, len(slice1)) for i, v := range slice1 { slice2[i] = v } slice2[1] = 100 fmt.Println(\"slice1 : \", slice1) fmt.Println(\"slice2 : \", slice2) } append() 함수를 이용한 값 복제 slice1 := []int{1, 2, 3, 4, 5} slice2 := make([]int{}, slice1...) copy() 함수를 이용한 값 복제 slice1 := []int{1, 2, 3, 4, 5} slice2 := make([]int, len(slice1)) copy(slice1, slice2) ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:4:1","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"4.2 요소 삭제하기 슬라이스 중간의 요소를 삭제하는 방법이다. 중간에 위치한 삭제 요소 이후의 값을 앞당겨서 삭제된 요소를 채운다. 마지막 값을 지워준다. package main import \"fmt\" func main() { slice1 := []int{1, 2, 3, 4, 5, 6} idx := 2 for i := idx + 1; i \u003c len(slice1); i++ { slice1[i-1] = slice1[i] } slice1 = slice1[:len(slice1)-1] fmt.Println(slice1) } append() 함수 이용 처음 요소 부터 삭제할 요소의 이전 요소 슬라이스와 삭제할 요소 이후 부터 끝까지 슬라이싱 된 슬라이스를 append()한다. slice1 = append(slice1[:idx], slice1[idx+1:]...) ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:4:2","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"4.3 요소 추가 슬라이스 중간에 요소를 추가한다. package main import \"fmt\" func main() { slice := []int{1, 2, 3, 4, 5, 6} idx := 2 slice = append(slice, 0) // 1. 맨 뒤에 요소 추가 // 2. 맨 뒤의 인덱스부터 삽입하려는 위치까지 한 칸씩 뒤로 밀어준다. for i := len(slice) - 2; i \u003e= idx; i-- { slice[i+1] = slice[i] } // 3. 값 변경 slice[idx] = 100 fmt.Println(slice) } 슬라이스 맨 뒤에 요소를 추가한다. 맨 뒤값부터 삽입하려는 위치까지 한 칸씩 뒤로 밀어준다. 삽입하는 위치의 값을 바꿔준다. append() 함수로 코드 개선 slice = append(slice[:idx], append([]int{100}, slice[idx:]...)...) 불필요한 메모리 사용이 없도록 코드 개선 위에서 append() 구문으로 생성한 [100, 3, 4, 5, 6] 슬라이스는 임시 버퍼 슬라이스 이다. 연산을 위해 임시로 생성되었으며 나중에 사라지기는 하나 불필요한 메모리 자원이 사용되었다. slice = append(slice, 0) // 1. 맨 뒤에 요소 추가 copy(slice[idx+1:], slice[idx:]) // 2. 하나씩 뒤로 복사 ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:4:3","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"5 슬라이스 정렬 ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:5:0","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"5.1 int 슬라이스 정렬 sort 패키지의 Ints() 함수를 이용하여 정렬 package main import ( \"fmt\" \"sort\" ) func main() { slice := []int{5, 2, 6, 3, 1, 4} // 1. 정렬되지 않은 슬라이스 sort.Ints(slice) // 2. 정렬 fmt.Println(slice) } ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:5:1","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["tucker-go"],"content":"5.2 구조체 슬라이스 정렬 Sort() 함수를 이용하기 위해서는 Len(), Less(), Swap() 메서드를 구현해야 한다. 이를 이용하면 우리가 정의한 구조체도 정렬을 할 수 있다. https://pkg.go.dev/sort#Sort package main import ( \"fmt\" \"sort\" ) type Student struct { Name string Age int } type Students []Student // 1) // 2) func (s Students) Len() int { return len(s) } func (s Students) Less(i, j int) bool { return s[i].Age \u003c s[j].Age } func (s Students) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func main() { s := []Student{ {\"화랑\", 31}, {\"백두산\", 52}, {\"류\", 42}, {\"켄\", 38}, {\"송하나\", 18}, } sort.Sort(Students(s)) // 3) fmt.Println(s) } 결과 [{송하나 18} {화랑 31} {켄 38} {류 42} {백두산 52}] 1) []Student 별칭 타입 Students 생성 2) Len(), Less(), Swap() 메서드 구현하여 sort.Interface를 사용할 수 있게 해준다. 3) []Student를 Students 타입으로 변환한 뒤 sort.Sort() 함수를 호출 Students는 이미 sort.Interface 메서드를 포함하고 있기 때문에 sort.Sort() 인수로 사용할 수 있다. ","date":"2022-04-26","objectID":"/archives/tucker-go/chapter18-slice/:5:2","tags":["go","golang"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/archives/tucker-go/chapter18-slice/"},{"categories":["docker/kubernetes"],"content":" 시작하세요! 도커/쿠버네티스 책 정리 🐳🐳🐳 ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:0:0","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"1 도커 이미지와 컨테이너 도커 엔진에서 사용하는 기본단위는 이미지와 컨테이너이다. ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:1:0","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"1.1 도커 이미지 이미지는 컨테이너를 생성할 때 필요한 요소이다. 가상 머신을 생성할 때 사용하는 iso 파일과 비슷한 개념이다. 여러 개의 계층으로 된 바이너리 파일로 존재, 컨테이너를 생성하고 실행할 때 읽기 전용으로 사용된다. 도커 이미지의 구성 도커 이미지 이름은 저장소 이름/이미지 이름:[태그] 형태로 구성 된다. 저장소 (Repository) : 이미지가 저장된 장소. 저장소 이름이 명시되지 않은 이미지는 도커에서 기본적으로 제공하는 이미지 저장소인 도커 허브의 공식 이미지. 이미지 이름 : 이미지가 어떤 역할을 하는지 나타냄. 이미지 이름을 생략할 수 없으며 반드시 설정 태그 : 이미지의 버전 관리, 혹은 리비전 Revision 관리에 사용. 태그를 생략하면 이미지의 latest 로 인식 ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:1:1","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"1.2 도커 컨테이너 이미지로 컨테이너를 생성하면 해당 이미지 목적에 맞는 파일이 들어 있는 격리된 시스템 및 자원 네트워크를 사용할 수 있는 독립된 공간이 생성 된다. 컨테이너 이미지를 읽기 전용으로 사용하되 이미지에서 변경된 사항만 저장하므로 원래 이미지는 영향을 받지 않는다. 생성된 각 컨테이너는 각기 독립된 파일시스템을 제공 받으며 호스트와 분리돼 있으므로 특정 컨테이너에서 어떤 어플리케이션을 삭제해도 다른 컨테이너와 호스트에는 영향을 주지 않는다. ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:1:2","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"2. 도커 컨테이너 다루기 ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:2:0","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"2.1 컨테이너 생성 도커는 다양한 기능이 빠르게 업데이트되고 새로운 버전이 배포되므로 설치된 도커 엔진을 먼저 확인해야 한다. sudo docker -v Docker version 19.03.12, build 48a66213fe 컨테이너 생성 후 접속 sudo docker run -i -t ubuntu:14.04 docker run : 컨테이너를 생성하고 실행하는 역할 -i -t : -i 옵션으로 컨테이너와 상호 interactive 입출력을, -t 옵션으로 tty 를 활성화해서 bash 쉘을 사용하도록 컨테이너를 설정. ubuntu:14.04 이미지가 엔진에 존재하지 않는 경우 도커 중앙 이미지 저장소인 도커 허브에서 자동으로 이미지를 내려 받음 위의 명령어로 실행할 경우 컨테이너 생성과 동시에 도커 환경 내부로 접속된다. 호스트 도커 환경으로 복귀하려면, exit를 입력한다. 이 방법은 컨테이너 내부에서 빠져나오면서 동시에 컨테이너를 정지한다. Ctrl + P, Q 입력한다. 단순히 컨테이너의 쉘에서만 빠져나온다. create 명령 sudo docker create -i -t --name mycentos centos:7 # docker 컨테이너 실행하기 sudo docker start mycentos # docker 컨테이너 내부로 들어가기 sudo docker attach mycentos run 명령어와 create 명령어의 차이점 run 명령어 : pull, create, start 명령어를 일괄적으로 실행한 attach가 가능한 컨테이너라면 컨테이너 내부로 들어간다. create 명령어 : pull 한 뒤 컨테이너만 생성할 start, attach를 실행하지 않는다. 보통은 run 명령어를 더 많이 사용한다. 도커 이미지 내려받기 sudo docker pull centos:7 도커 엔진에 존재하는 이미지 조회 sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 18.04 2eb2d388e1a2 10 days ago 64.2MB wordpress latest 04b52c96c4b6 11 days ago 543MB mysql 5.7 8679ced16d20 11 days ago 448MB mysql 8 e3fcc9e1cc04 11 days ago 544MB ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:2:1","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"2.2 컨테이너 목록 확인 생성한 컨테이너 목록 확인 # 정지되지 않은 컨테이너만 출력 sudo docker ps # 정지된 컨테이너를 포함한 모든 컨테이너 출력 sudo docker ps -a CONTAINER ID : 컨테이너에게 할당되는 고유한 ID. 위 결과에서는 ID의 일부분 밖에 확인할 수 없지만 컨테이너를 확인하기 위해 docker inspect 명령어를 사용하면 전체 ID를 확인할 수 있다. IMAGE : 컨테이너를 생성할 때 사용된 이미지 이름. COMMAND : 커맨드는 컨테이너가 시작될 때 실행 명령어. 커맨드는 대부분의 이미지에 미리 내장되어 있기 때문에 별도로 설정할 필요가 없다. CREATE : 컨테이너가 생성되고 난 뒤 흐른 시간을 나타냄 STATUS : 컨테이너의 상태를 나타낸다. Exited... 는 정지된 상태 나타내며 Up ... seconds 는 실행중인 상태를 나타낸다. PORTS : 컨테이너가 개방한 포트와 호스트에 연결한 포트를 나열. NAMES : 컨테이너의 고유 이름. docker rename 명령어를 통해 컨테이너 이름을 변경할 수도 있다. # 컨테이너 이름 변경 docker rename angry_morse my_container ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:2:2","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"2.3 컨테이너 삭제 docker rm 명령어를 통해 컨테이너를 삭제할 수 있다. 한 번 삭제한 컨테이너는 복구할 수 없으므로 신중을 기해야 한다. 도커 컨테이너 삭제 실행 중인 컨테이너는 삭제할 수 없다. 실행 중인 컨테이너를 종료하거나 강제삭제 옵션을 추가해야한다. # 실행 중인 컨테이너 종료 후 삭제 docker stop mycentos docker rm mycentos # 강제 옵션을 통한 삭제 docker rm -f mycentos 모든 도커 컨테이너 삭제 - prune prune 명령어를 사용하면 모든 컨테이너를 한번에 삭제할 수 있다. riley@DESKTOP-XXXXX:~$ docker container prune WARNING! This will remove all stopped containers. Are you sure you want to continue? [y/N] y Total reclaimed space: 0B ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:2:3","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"2.4 컨테이너를 외부에 노출 컨테이너는 가상 머신과 마찬가지로 가상 IP 주소를 할당 받는다. 기본적으로는 172.17.0.x의 IP를 순차적으로 받게 된다. (나는 WSL2 우분투 사용중이라 네트워크 정보가 조금 다른것 같다.) ifconfig 명령어를 통해 도커의 NAT IP를 할당받은 eht0 인터페이스와 로컬 lo 인터페이스를 확인 할 수 있다. 외부에 컨테이너의 애플리케이션을 노출하기 위해서는 eth0의 IP와 포트를 호스트의 IP와 포트에 바인딩 해야 한다. # ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.21.154.31 netmask 255.255.240.0 broadcast 172.21.159.255 inet6 fe80::215:5dff:fe81:5ff2 prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:15:5d:81:5f:f2 txqueuelen 1000 (Ethernet) RX packets 5941 bytes 1924948 (1.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 146 bytes 10909 (10.9 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 도커 컨테이너로 아파치 웹서비스 띄우기 docker run -i -t --name mywebserver -p 80:80 ubuntu:18.04 root@b6e1a96299bb:/# apt-get update root@b6e1a96299bb:/# apt-get install apache2 -y root@b6e1a96299bb:/# service apache2 start 아파치 웹 서버는 172 대역을 가진 컨테이너의 NAT IP와 80번 포트로 서비스하므로 여기에 접근하려면 172.x.x.x:80 의 주소로 접근해야 한다. 도커의 포트 포워딩 옵션인 -p 옵션을 통해 호스트와 컨테이너를 연결했으므로 호스트 ip를 통해 172.x.x.x:80에 접근할 수 있다. ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:2:4","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"2.5 컨테이너 어플리케이션 구축 보통은 여러 에이전트나 데이터베이스 등을 연결하여 하나의 서비스로 동작시킨다. 이런 서비스를 컨테이너화(Containerize)할 때 여러개의 애플리케이션을 하나의 컨테이너에 설치할 수 있다. 컨테이너에 애플리케이션을 하나만 동작시키면 컨테이너 간 독립성을 보장함을 동시에 애플리케이션의 버전 관리, 소스코드 모듈화 등이 더 쉬워진다. 도커에서는 한 컨테이너에 하나의 프로세스만 실행하도록 권장한다. MySql 이미지로 데이터베이스 컨테이너 생성 docker run -d \\ --name wordpressdb \\ -e MYSQL_ROOT_PASSWORD=password \\ -e MYSQL_DATABASE=wordpress \\ mysql:5.7 워드프레스 이미지로 워드프레스 웹 서비스 컨테이너 생성 docker run -d \\ -e WORDPRESS_DB_PASSWORD=password \\ --name wordpress \\ --link wordpressdb:mysql \\ -p 80 \\ wordpress -d : Detached 모드로 컨테이너를 실행한다. Detached 모드는 백그라운드에서 동작하는 애플리케이션으로써 실행하도록 설정. 컨테이너 내부에서 프로그램이 foreground로 실행된다. -e : 컨테이너 내부의 환경변수 설정 docker exec -i -t wordpressdb /bin/bash root@d777facb7e1f:/# echo ${MYSQL_ROOT_PASSWORD} password exec : 명령어를 사용하면 컨테이너 내부에서 명령어를 실행한 뒤 그 결과값을 반환 받을 수 있다. -i, -t 옵션을 추가해 /bin/bash로 상호 입출력이 가능한 형태로 exec를 사용할 수 있다. --link : deprecated 된 옵션이며 도커 브리지(bridge) 네트워크를 사용하면 link와 동일한 기능을 손쉽게 사용할 수 있다. docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0ba1266d50e0 wordpress \"docker-entrypoint.s…\" 3 seconds ago Up 2 seconds 0.0.0.0:57594-\u003e80/tcp wordpress 7a8d5ded323e mysql:5.7 \"docker-entrypoint.s…\" 29 seconds ago Up 27 seconds 3306/tcp, 33060/tcp wordpressdb # wordpress가 사용중인 포트 확인하기 $ docker port wordpress 80/tcp -\u003e 0.0.0.0:57594 포트 54746과 호스트의 80 포트와 매핑되었다. ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:2:5","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["docker/kubernetes"],"content":"2.6 도커 볼륨 도커 이미지로 컨테이너를 생성하면 이미지는 읽기 전용이 되고 컨테이너의 변경 사항만 별도 저장하여 컨테이너의 정보를 보존한다. 이미 생성된 이미지는 어떠한 경우로도 변경되지 않으며, 컨테이너 계층에 원래 이미지에서 변경된 파일시스템 등을 저장한다. 생성된 mysql 이미지에는 mysql을 실행하는 데 필요한 애플리케이션 파일이, 컨테이너 계층에는 워드프레스에서 쓴 로그인 정보나 게시글 등과 같은 데이터베이스를 운용하면서 쌓인 데이터가 저장된다. [그림] 이미지와 컨테이너의 구조 위의 mysql 컨테이너를 삭제하면 컨테이너 계층에 저장되어 있던 데이터베이스의 정보도 모두 사라진다. 도커는 컨테이너의 생성과 삭제가 매우 쉬으므로 데이터를 영속적(Persistent)로 활용할 수 있는 방법은 아래와 같다. 볼륨 생성 방법 호스트 볼륨 공유 볼륨 컨테이너 활용 도커가 관리하는 볼륨 이용 2.6.1 호스트 볼륨 공유 -v 옵션을 통해 ~/wordpress_db:/var/lib/mysql로 설정하여 [호스트 공유 디렉터리]:[컨테이너 공유 디렉터리] 형태로 디렉토리를 공유한다. ~/wordpress_db 에 mysql 구동에 필요한 파일이 공유된 것을 확인 할 수 있다. 컨테이너의 /var/lib/mysql 디렉터리는 호스트의 ~/wordpress_db 디렉터리와 동기화되는 것이 아니라 완전히 같은 디렉터리이다. docker run -d \\ --name wordpressdb_hostvolume \\ -e MYSQL_ROOT_PASSWORD=password \\ -e MYSQL_DATABASE=wordpress \\ -v ~/wordpress_db:/var/lib/mysql mysql:5.7 docker run -d \\ -e WORDPRESS_DB_PASSWORD=password \\ --name wordpress_hostvolume \\ --link wordpressdb_hostvolume:mysql \\ -p 80 wordpress 컨테이너를 삭제해도 호스트 공유 디렉터리(~/wordpress_db)에는 mysql 컨테이너가 사용한 데이터가 그대로 남아 있다. # stop containers docker stop wordpress_hostvolume wordpressdb_hostvolume # remove containers docker rm wordpress_hostvolume wordpressdb_hostvolume 💡 이미지에 이미 존재하던 디렉터리에 호스트의 볼륨을 공유하면 컨테이너 디렉터리가 덮어씌워진다. 2.6.2 볼륨 컨테이너 -v 옵션으로 볼륨을 사용하는 컨테이너를 다른 컨테이너와 공유하는 방법이 있다. 컨테이너를 생성할 때 –volumes-from 옵션을 설정하면 -v 또는 --volume 옵션을 적용한 컨테이너의 볼륨 디렉터리를 공유할 수 있다. 호스트에서 볼륨만 공유하고 별도의 역할을 담당하지 않는 볼륨 컨테이너로 활용하는 것이 가능하다. 2.6.3 도커가 관리하는 볼륨이용 docker volume 명령어를 사용하여 도커 자체에서 제공하는 볼륨 기능을 활용할 수도 있다. docker volume create --name myvolume 호스트와 볼륨을 공유할 때는 다음과 같은 형식으로 입력한다. [볼륨이름]:[컨테이너의 공유 디렉터리] docker run -i -t --name myvolume_1 \\ -v myvolume:/root/ \\ ubuntu:18.04 docker inspect 명령어를 이용하면 볼륨이 실제 어디에 저장되는지 알 수 있다. docker inspect --type volume myvolume ","date":"2022-04-20","objectID":"/archives/docker-kubernetes/chapter2-1-docker-engine/:2:6","tags":["docker"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/archives/docker-kubernetes/chapter2-1-docker-engine/"},{"categories":["javascript"],"content":"개요 Go의 라이브러리에서 사용하는 SHA3-512 해시값과 자바스립트에서 사용하는 CryptoJS의 SHA3-512 해시값이 다른 문제가 발생 테스트 대상 모듈 hash.js js-sha3 CrytoJS 테스트 방법 Go의 테스트 코드 작성 후 Go에서 생성한 해시값과 Javascript에서 위의 라이브러리로 생성했을 때 해시값이 같은지 비교한다. 테스트 결과 hash.js : SHA3-512 관련 함수가 없는 것 같았다. js-sha3 : 성공 CrytoJS : 실패 CrytoJS 의 경우 Go에서 사용하는 SHA3-512와 차이가 있는 것 같다. [cryptojs_document(https://cryptojs.gitbook.io/docs/)에 참고 사항이 있었다. NOTE: I made a mistake when I named this implementation SHA-3. It should be named Keccak[c=2d]. Each of the SHA-3 functions is based on an instance of the Keccak algorithm, which NIST selected as the winner of the SHA-3 competition, but those SHA-3 functions won’t produce hashes identical to Keccak. Go 테스트 코드 func TestSha3(t *testing.T) { addr, _ := utils.FromHex(\"079164CF59F8B91DA6EC0767CB78075D73E93994\") tx, _ := utils.FromHex(\"D08BC04E9EDACA0D964BF7404CD1E9C4939C1F099F26177B9B8597BC521BC5CE\") shashum1 := sha3.New512() shashum1.Write(addr) println(\"[addr to sha3-512] \", utils.ToHex(shashum1.Sum(nil), false)) shashum2 := sha3.New512() shashum2.Write(tx) println(\"[txHash to sha3-512] \", utils.ToHex(shashum2.Sum(nil), false)) hasher512 := sha3.New512() hasher512.Write(addr) hasher512.Write(tx) sha512 := hasher512.Sum(nil) hasher160 := ripemd160.New() _, _ = hasher160.Write(sha512) println(\"[data-account] \", utils.ToHex(hasher160.Sum(nil), false)) } javascript test(\"Test sha3-512\", () =\u003e { const u8Addr = Hex.toU8Array('079164CF59F8B91DA6EC0767CB78075D73E93994'); const expected_sha3_512 = 'A6CEF82C523F10ABE2684E19FD1AB35580E8B2DCE4926280B6CEC829D2A1A734F46A642BAA5C62369F185577D23A8428D50C201842B62663DCEB1EF2CD911853'; // js-sha3 (pass) const shasum = sha3_512.create() shasum.update(u8Addr) shasum.hex() expect(shasum.toString().toUpperCase()).toEqual(expected_sha3_512) // hashjs (fail) const shasum2 = hashjs.sha512().update(u8Addr).digest('hex') console.log(shasum2.toUpperCase()) expect(shasum2.toUpperCase()).toEqual(expected_sha3_512) // CRYPTOJS (fail) const shasum3 = CryptoJS.SHA3.create(u8Addr, {outputLength: 512}); expect(shasum3.toUpperCase()).toEqual(expected_sha3_512) }); 결론 및 답변 내용 SHA-3은 SHA-1과 SHA-2를 대체하기 위해 미국 국립표준기술연구소(NIST)가 공개적인 방식을 통해 선정한 암호화 해시 함수이다. 최종 적으로 Keccak이 SHA-3의 해시 알고리즘으로 선정되었고 그 이후 NIST에서 변경된 암호화 해시 함수 표준을 발표했다. 결과적으로 처음 선정되었던 Keccak 방식과 현재 공식적인 SHA3 방식이 일부 달라지게 되었다. CryptoJS 에서 구현한 SHA3은 공식적인 SHA3이 아니라 이전 SHA3(Keccak)으로 보임. js-sha3 라이브러리가 추가됨에 따라 최적화가 필요하므로 hash-wasm 라이브러리를 추천해주심. ","date":"2022-04-17","objectID":"/archives/javascript/hash3/:1:0","tags":["javascript","sha3","keccak"],"title":"SHA3 라이브러리 조사","uri":"/archives/javascript/hash3/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인과 보안 및 개인정보 ","date":"2022-03-26","objectID":"/archives/til/20220326/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 블록체인과 보안 ","date":"2022-03-26","objectID":"/archives/til/20220326/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"해커 해커의 주된 목표 가치있는 정보 탈취로 경제적 이익 추구 -\u003e 정보 자체에 대한 약탈 서비스 중단(Denial of Service)을 통한 시스템의 교란 해커의 공격을 막으려면? 정보 자체가 노출되는 것을 보호 서비스가 중단되지 않도록 보호 블록체인은 해커의 공격에 대해 안전할까? 블록체인은 모든 데이터를 브로드캐스팅을 통해 다른 노드와 공유 정보의 탈취 자체가 필요없을 정도로 정보가 노출됨. 정보 탈취로부터의 안정성은 가지고 있지 못함 암호화 자체가 안전을 보장하지 않음 암호화를 위한 기술적인 문제도 뒤따름 ","date":"2022-03-26","objectID":"/archives/til/20220326/:1:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 보안 서비스 중단 공격이나 기록을 변경시키려는 시도로부터는 현존하는 가장 안전한 시스템 공격이나 기록 변경을 위해서는 모든 노드를 공격해야 함. ","date":"2022-03-26","objectID":"/archives/til/20220326/:1:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"현업에서의 블록체인 사용 정보의 탈취로부터의 안전성에 대한 고려는 접어두어야 함 블록체인 사용 고려 가능한 시스템 중단되는 안 되는 서비스 기록이 변경되면 안 되는 시스템 ","date":"2022-03-26","objectID":"/archives/til/20220326/:1:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 블록체인과 개인정보 ","date":"2022-03-26","objectID":"/archives/til/20220326/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"정보 데이터를 가공하여 누군가에게 가치 있는 무엇을 제공해 줄 수 있는 경우. ","date":"2022-03-26","objectID":"/archives/til/20220326/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"개인 정보 가공 된 정보 중 누구에게 해당하는 것인지 특정할 수 있는 경우 질병정보 -\u003e 누구에 대한 정보인지 알 수없는 경우 -\u003e 정보 질병정보 -\u003e 누구에 대한 정보인지 알 수 있는 경우 -\u003e 개인정보 두 가지 정보가 결합되어 어떤 사람을 특정할 수 있는 정보를 발생하기도 함 정보 중에 누구 것인지를 특정할 수 있는 경우 ","date":"2022-03-26","objectID":"/archives/til/20220326/:2:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 두 가지 정보가 결합되어 어떤 사람을 특정할 수 있는 정보를 발생하기도 함 비트코인 블록체인에 들어 있는 데이터는 암호화되지 않은 채 모든 노드에 공개 ","date":"2022-03-26","objectID":"/archives/til/20220326/:2:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 데이터의 암호화 암호화 자체도 안전하지 않음 해킹을 통해서 언제든지 풀릴 수 있음 암호화의 여부와 상관없이 접근을 통제하는 것이 가장 중요 데이터 암호화의 이치 암호화된 비밀번호 데이터를 온라인에 공개할 수 없는 것과 같은 이치 암호화를 통한 브로드캐스팅은 안전하게 보호할 수 없음 -\u003e X 모든 데이터는 접근을 통제해야만 안전하게 보호가 가능함 블록체인은 암호화의 여부에 상관없이 정보가 보호되지 않음. 비트코인 블록체인 익명성 보장 정보가 존재 -\u003e 모든 사람에게 공개 -\u003e 이 정보가 누구의 것인지는 특정할 수 없다 = 개인정가 없다 정보는 노출되지만 개인정보는 노출되지 않음. 비트코인 블록체인에서 공개된 정보 발송인의 비트코인 주소 수취인의 비트코인 주소 비트코인의 수량 ","date":"2022-03-26","objectID":"/archives/til/20220326/:2:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인과 이더리움 비트코인 정적인 내용만 기록 적힐 내용이 미리 정해져 있음 사용자가 내용을 바꿀 수 없음 용도를 바꾸려면 프로그램을 완전히 수정해야 함 개인정보가 누출될 일이 없음 익명으로 처리됨 구조적으로 개인정보가 막혀 있음 이더리움 동적인 프로그램까지 기록 스마트 컨트랙트를 만드는 사람이 내용을 임의로 정할 수 있음. 스마트 컨트랙트를 통해서 임의로 데이터를 쓸 수 있음 스마트 컨트랙트를 이용해 개인정보를 저장했다면 개인정보의 누출이 일어 날 수 있음 개인정보의 누출이 언제든지 발생 ","date":"2022-03-26","objectID":"/archives/til/20220326/:2:5","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인의 순기능과 역기능 순기능 : 검열을 피해 자신의 의견을 퍼블릭이 파악할 수 있는 공간에 게재했다. 역기능 : 사실확인이 안 된 상태에서 영원히 기록되게 된다. 비트코인은 진실만을 기록한다? -\u003e 비트코인은 단순한 기록장치 블록체인에 대한 진실 정적인 기록을 위한 검열을 통과했기 때문에 코인에서 진실을 쓰지 않는 방법이 존재하지 않음 검증 절차 없이 누구든 원하는 내용을 쓸 수 있음 정보 -\u003e (스마트 컨트랙트) -\u003e 이더리움 무엇이든 기록할 수 있지만 쉽게 바꿀 수 없음 비트코인과 스마트컨트랙트 비트코인 : 모든 거래내역을 모든 노드가 참여하여 검증하므로 진실만을 기록하도록 노력함 스마트 컨트랙트 원하는 사람이 자신이 원하는 내용을 쓸 수 있도록 하는 것 비트코인처럼 정적인 기록만 작성할 경우 개인정보보 보호 가능 -\u003e 규칙검증 가능 -\u003e 통제 스마트 컨트랙트 경우 어떤 기록이든 작성 가능하므로 개인정보 보호가 불가능 스마트 컨트랙트를 이용하면 개인정보는 언제든지 누출 될 가능성이 있음 ","date":"2022-03-26","objectID":"/archives/til/20220326/:2:6","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 중개소와 블록체인 ","date":"2022-03-26","objectID":"/archives/til/20220326/:3:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"암호화폐 중개소와 블록체인의 관계 블록체인의 안전성과 암호화폐 중개소의 안전성을 관련이 없음 해킹과 블록체인의 안전성은 블록체인과 비트코인 시스템에 국한된 내용임 지갑 소프트웨어 -\u003e 블록체인을 사용하기 위한 인터페이스 지갑을 통해 늘 블록체인과 통신을 하고 있음 지갑을 개발하는 사람마다 안전성이 다르게 만들 수 있음 우회적으로 블록체인을 접근하는 환경 죽애소는 블록체인 자체와 관련이 없음 ![[Pasted image 20220326164000.png]] ","date":"2022-03-26","objectID":"/archives/til/20220326/:3:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인 중개소 중앙화 시스템으로 되어 있음 중개소의 안정성은 그 중개소 자체가 가진 안정성과 같음 암호화폐 중개소는 블록체인의 외부 요소로 블록체인 기술과는 상관이 없음 최근 발생한 암호화폐 해킹 사건은 중개소를 해킹하여 많은 자원을 획득하려는 시도 암호화폐 중개소는 거래 내용을 시뮬레이션만 하고 있음 것 언제든지 해킹 위험에 노출 암호화폐 중개소의 안전성에 전적으로 의지 ","date":"2022-03-26","objectID":"/archives/til/20220326/:3:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인과 보안 블록체인에 담긴 데이터 자체는 모든 노드에 노출되므로 안전하지 않음 블록체인은 서비스 중단(Dos) 공격으로부터 안전함 ","date":"2022-03-26","objectID":"/archives/til/20220326/:4:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인과 개인정보 블록체인에는 정보는 담겨 있지만, 익명성을 기반으로 하고 있기 때문에 누구의 정보인지 특정할 수 없으므로 개인정보 문제는 발생하지 않음 법 조항의 강화에 따른 적극적인 대응 필요 ","date":"2022-03-26","objectID":"/archives/til/20220326/:5:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"중개소와 블록체인 중개소는 블록체인 기술과 무관하며, 단순히 이를 이용하는 외부 소프트웨어에 불과 다양한 해킹의 위협으로부터 노출되어 있음 이더리움 vs 비트코인 ","date":"2022-03-26","objectID":"/archives/til/20220326/:6:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 비트코인 블록체인의 문제점 ","date":"2022-03-26","objectID":"/archives/til/20220326/:7:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인 블록체인의 문제점(=개선점) 이더리움이 등장하면서 나타난 비트코인에서 개선할 점 1. 용도가 제한적임 비트코인을 주고 받는 정적인 기록만 함. 새로운 것을 기록하기 위해서는 프로그램 모두가 수정되어야 함 비트코인을 주고 받는 제한적인 용도로만 사용 가능 2. 상태가 기록되어 있지 않음 비트코인의 상태 주소별 잔액 입출금 히스토리 비트코인의 특정 상태는 어떤 한 블록에 있지 않으므로 하나의 블록만으로는 상태를 알 수 없음 3. 비트코인이 사용하고 있는 해시 퍼즐 방식은 계산만 빨리하면 풀 수 있음 해시파워가 일부 세력에 의해 독점 될 위험이 큼 51% Attack -\u003e 일부 세력의 해시파워 독점 -\u003e 블록의 생산을 독점하는 결과가 나타남 빠른 계산만 하면 되므로 전용기계로 만들기에 좋은 방식으로 되어 있음 ","date":"2022-03-26","objectID":"/archives/til/20220326/:7:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움이 비트코인 문제를 개선한 방법 이더리움은 비트코인의 세가지 문제를 가장 큰 문제점이라 판단하고 개선하기 위해 노력함 1.용도가 제한적임 스마트 컨트랙트를 이용하여 극복 프로그램을 이용하여 각각의 용도가 바뀜 호출시마다 메세지를 통해 서로 다른 매개변수를 부여할 수 있음 각각 동작을 달리 할 수 있음 2. 상태가 기록되어 있지 않음 계정벌 상태 관리를 통하여 극복 비트코인 : 주고받은 모든 기록내용이 주소를 통해 기록. 모든 블록에 흩어져 있음 이더리움은 계정별 관리 진행 -\u003e 각각의 블록에서 각각의 계정으로 이어가는 다리 역할 어떤 계정이던 특정 블록에서 바로 액세스 가능 3. 비트코인이 사용하고 있는 해시 퍼즐 방식은 계산만 빨리하면 풀 수 있음 메모리-하드 해시를 통하여 극복 ","date":"2022-03-26","objectID":"/archives/til/20220326/:7:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 이더리움 블록체인의 특징 ","date":"2022-03-26","objectID":"/archives/til/20220326/:8:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움 블록체인 스마트 계약 1990년대 닉 사보(Nick Sazbo)에 의해 제안 제3자의 개입없이 법률적 계약사항이 집행되는 디지털 환경 이더리움에서의 스마트 컨트랙트 이용 컴퓨터 프로그램 -\u003e 프로그램 실행 -\u003e 데이터 생성 -\u003e 데이터 이용 프로그램을 통해 원하는 내용을 블록에 저장 및 호출할 수 있는 환경 제공 솔리디티 언어를 이용하여 프로그래밍화 이더리움의 발전 계정단위의 관리를 위한 계정 정의 EOA(Externally Owned Account) 비트코인 주소와 비슷 정적인 내용 기록이 기본 목표 개인키로 통제할 수 있음 이더리움 간 전송 가능 계약 계정 스마트 컨트랙트 저장 전송 내용과 특정 스마트 컨트랙트 저장 코드에 의해 통제 계정 단위 관리를 위한 계정정의 ![[Pasted image 20220326171431.png]] 계약 계정 내의 실행코드가 실행되면 그 결과가 저장되게 됨 이더리움의 블록 현재 계정 상태가 저장된 별도의 공간이 있음 이더리움 주소 A를 여러번 사용 -\u003e 글로벌한 결과를 한 곳에서 저장 계약 계정 속에 프로그램을 저장할 수 있는 방식 -\u003e 스마트 컨트랙트 계약 계정 언제든지 코드에 의해 통제 실행된 코드는 또 다른 계약 계정 호출 가능 최초의 계약 계정은 반드시 EOA를 통해 호출 ","date":"2022-03-26","objectID":"/archives/til/20220326/:8:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인 해시함수의 단점 전용기계화가 쉬엄 특정 세력이 해시파워를 장악하는 것이 쉬움 해시 함수의 독점화를 통해 51% 공격이 용이 ","date":"2022-03-26","objectID":"/archives/til/20220326/:8:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움의 해시퍼즐 방식 ![[Pasted image 20220326171810.png]] SHA256 -\u003e SHA3 변경 메모리 문제 해결의 열쇠 이더리움 해시 함수 메모리 상자가 있음 하나의 해시 함수 계산 시 64회 메모리 액세스 필요 Nonce 1씩 증가시키는 것을 물론 64개의 숫자를 읽어와서 계산 이더리움 해시 퍼즐 방식의 문제점 계산 속도 저하 해시 퍼즐에 가장 큰 시간이 소요되는 것은 -\u003e 64회 메모리 액세스 64회의 메모리 액세스를 해야하므로 의도적으로 속도를 늦춘 셈 ASIC의 사용 속도를 따라 잡을 수 있는 메모리가 않음 -\u003e ASIC으로 만드는 것이 용이 하지 않음 가격대 효용비용이 떨어 질 수 있음 비트코인에 비해 효율적이지 않음 특정 세력의 해시 함수 독점을 방지 할 수 있음 메모리-하드 방식 사용 속도가 느린 메모리 시스템의 활용을 통해 전용기계화 하여 해시 함수를 독점하려는 시도를 막는 방식 비트코인 블록체인 이후 대부분 메모리-하드 방식 이용 해시 함수의 전용화 및 특정 세력의 독점화 방지 비트코인에 비해 더 나은 성능으로 발전 중 ","date":"2022-03-26","objectID":"/archives/til/20220326/:8:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"그 밖의 개선 통합 개발 프로그램 (IDE)의 제공 IDE 툴을 사용해 스마트 컨트랙트 생성 가능 스스로 작동, 집행되는 스마트 계약의 시발점 토큰 개념 도입 토큰 개념의 도입 전 독자적인 네트워크 구성 -\u003e 구축된 네트워크에서 암호 화폐 발행 토큰 개념의 도입 후 스마트 컨트랙트 이용 -\u003e 개념만으로 전송 및 판매 가능 누구나 손쉽게 토큰 발생 가능 ","date":"2022-03-26","objectID":"/archives/til/20220326/:8:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"개선되지 못한 부분 범용적인 부분 이외에 안전성, 지속성, 탈중앙화 비트코인 블록체인에 비해 개선된 점이 많지 않음 ","date":"2022-03-26","objectID":"/archives/til/20220326/:8:5","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움의 스마트 계약 스마트 계약의 환경 더 개선한것으로 볼 수 있음 비트코인이 가지고 있던 문제점을 개선 ","date":"2022-03-26","objectID":"/archives/til/20220326/:8:6","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"토큰의 개념을 보는 시각 암호화폐 -\u003e 인센티브 공학의 일부 채굴하는 사람의 대가를 위해 도입 다른 인센티브 방식이 있을 수 있음 토큰의 기능 일정 디지털 화폐를 서로 주고받는 기능 이더리움에서는 스마트 컨트랙트를 위해서 주고 받을 수 있음 현재 15만개 중 1,000 여개가 실제로 거래 토큰의 이면 거래되고 있는 대부분의 토큰이 중개소에 의해 만들어지고 있음 스마트 컨트랙트가 토큰을 이용하는 사람들에 의해 남용될 가능성 발생 최근 생성되는 대부분의 스마트 컨트랙트가 토큰에 연루 이더리움이 꿈꾸는 세상 누구나 탈 중앙화 프로그램을 제공할 수 있도록 하겠다 안정성, 지속성에 대한 검증 필요 Dapp의 한계 중요한 정보를 저장할 수 없음 -\u003e 사용제한에 대한 문제가 발생 비효율적인 시스템 -\u003e 효율을 포기하고 값 저장 저장된 것에 대한 변화를 최소화 좀 더 나은 시스템 구현에 대한 숙제가 남아 있음 ","date":"2022-03-26","objectID":"/archives/til/20220326/:8:7","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"스마트 컨트랙트의 역할 원하는 데이터를 기록하고 블록체인이 범용성을 가지도록 함. ","date":"2022-03-26","objectID":"/archives/til/20220326/:8:8","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 이더리움과 비트코인 비교 ","date":"2022-03-26","objectID":"/archives/til/20220326/:9:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인과 이더리움 ![[Pasted image 20220326173306.png]] ","date":"2022-03-26","objectID":"/archives/til/20220326/:9:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움 비트코인의 비효율적인 부분 개선 해시파원의 편중 견제 스마트 컨트랙트 구현 누구나 쉽게 프로그램 할 수 있도록 함 ","date":"2022-03-26","objectID":"/archives/til/20220326/:9:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"튜링 완전과 튜링 비완전 튜링 완전 - 컴퓨터의 동작을 모두 표현 할 수 있는 경우. 솔리디티 언 튜링 비완전 - 튜링 완전에 비해 표현이 제한적. 스크립트 언어 ","date":"2022-03-26","objectID":"/archives/til/20220326/:9:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인과 이더리움의 블록 형태 ![[Pasted image 20220326173556.png]] ","date":"2022-03-26","objectID":"/archives/til/20220326/:9:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인 블록체인의 문제점 비트코인에는 정적인 데이터만 기록되어 용도가 제한적임 해시 퍼즐의 경우 계산에만 국한되어 전용기계를 통해 일부 세력의 독점화가 용이 ","date":"2022-03-26","objectID":"/archives/til/20220326/:10:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움 블록체인의 특징 이더리움은 디지털 환경을 통해 제 3자 없이도 계약을 이행하려는 닉 사보의 ‘스마트 컨트랙트’ 개념을 구현하기 위해, 블록에 프로그램을 저장할 수 있는 기능을 적용 해시 퍼즐에 메모리-하드-개념을 도입하여 전용기계를 통한 일부 세력의 독점화를 견제 ","date":"2022-03-26","objectID":"/archives/til/20220326/:11:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움과 비트코인 비교 이더리움은 블록체인의 비효율적인 부분을 개선함 이더리움은 튜링-완전 언어를 도입해 스마트 컨트랙트를 구현 이더리움은 메모리-하드 해시 퍼즐을 통해 일부 세력 독점을 견제했음 이더리움은 계정 위주의 관리를 통해 현재 계정의 잔액 등 상태를 손쉽게 알 수 있게 했음 이더리움은 블록체인 본연의 기능 면에 있어서 큰 변혁이 아니라고 볼 수 있음 블록체인의 진정한 효용 ","date":"2022-03-26","objectID":"/archives/til/20220326/:12:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 블록체인의 진정한 효용 ","date":"2022-03-26","objectID":"/archives/til/20220326/:13:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인에 관한 오해 데이터 저장의 안전성 해킹 방지에 탁월 진실만을 기록 기록의 불변 중앙화 시스템보다 효율적 데이터 저장의 안정성 오해 바로잡기 블록체인에 데이터를 저장하면 안전하게 보호된다 (▲) 데이터 자체 비보호 블록체인 데이터는 브로드캐스팅을 통해 모든 노드에 공유 DoS 공격에 대해서는 상대적 안정성 보유 데이터는 보호되지 않으나, 서비스 중단 공격에는 상대적으로 안전하다. 해킹 방지에 탁월 오해 바로잡기 블록체인은 현존하는 시스템 중 해킹으로부터 가장 안전하다 (▲) 기록 변조 및 서비스 중단 시도에 대한 안정성 보유 참여한 모든 노드의 중복 검증 서비스 중단 및 기록 변조 시도에는 가장 안전하지만 데이터의 보호가 되지 않는 가장 취약한 시스템이다. 진실만을 기록에 대한 오해 바로잡기 블록체인은 항상 진실만을 기록한다. (X) 초창기 블록체인 정적인 기록, 비트코인 거래 내용 기록 -\u003e 검증가능 최소한 비트코인 블록체인에서는 진실만 기록 가능한 장치 마련 후기 블록체인 누구든 원하는 사실 기록 -\u003e 검증 불가 블록체인은 진실을 기록하는 것이 아니라, 기록이 변경되지 않도록 특정장치를 한 것이다. 기록의 불변 오해 바로잡기 한 번 기록되면 어떤 경우에도 변경되지 않는다.(X) 기록 및 변경이 어려울 뿐, 불가능한 것은 아니다. 퍼즐의 난이도 조절로 기록 변경을 어렵게 만들 수 있다. 중앙화 시스템보다 효율적 오해 바로잡기 블록체인은 중앙화 시스템보다 더 효율적이다 (X) 일의 반복을 통해 데이터의 투명성을 요구하는 기술 효율성 ↓, 투명성 ⬆️ 속도의 효율성 : 블록체인 \u003c 중앙화 시스템 블록체인은 중앙화 시스템에 비해 비효율적이다. ","date":"2022-03-26","objectID":"/archives/til/20220326/:13:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 플랫폼 블록체인의 효용을 위해 작업증명 방식의 막대한 에너지 사용에 대한 의구심 증폭 ","date":"2022-03-26","objectID":"/archives/til/20220326/:13:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인의 효용성 효용성을 희생하고 안전성을 누림 스스로 실행되는 스마트 계약 환경을 구축할 수 있는 플랫폼 진정한 효용성을 얻기 위해서는 블록체인의 안정성이 관건 ","date":"2022-03-26","objectID":"/archives/til/20220326/:13:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"현재 블록체인의 발전 방향 기존의 블록체인을 변형하려는 노력이 많이 나오고 있음 블록체인 = 리더선출 방식 비트코인 : 해시 퍼즐 방식을 통해 무작위성을 최대한 보장하며 리더 선출 현재 : 정해진 방식 혹은 일부 세력이 점유한 방식에 의해 리더 선출 블록체인의 무작위성을 잃어버리게 되는 결과를 가져올 수 있음 신뢰받는 제3가 필요 없는 거래, 안전성, 기록불변성, 확장성 등의 모든 조건을 만족하는 블록체인 개발은 여전히 미지수임 ","date":"2022-03-26","objectID":"/archives/til/20220326/:13:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인에 관한 연구의 미래 과연 탈중앙화된 세상을 소프트웨어로 구현할 수 있을까? 누군가 혁신적인 방식이 제안될 가능성이 있음 소프트웨어로 새로운 효용을 가질 수 있을까 ","date":"2022-03-26","objectID":"/archives/til/20220326/:13:5","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 프라이빗 블록체인과 컨소시엄 블록체인 프라이빗 블록체인과 컨소시엄 블록체인을 과연 블록체인이라고 할 수 있는가? ","date":"2022-03-26","objectID":"/archives/til/20220326/:14:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인과 이더리움 블록체인의 특징 기록과 검증을 위해 특정 서버를 의지하지 않음(확장성) 퍼블릭 블록체인 확장성 보유, 누구든 기록의 무결성 확인 가능 -\u003e 기록의 투명성 확보 프라이빗, 컨소시엄 블록체인 기록과 검증은 정해진 소수의 서버에 의해서 가능 프라이빗 블록체인의 경우 단 하나의 서버가 기록과 검증 실시 중앙화 시스템과 유사 분산 저장을 통해 차별화 프라이빗, 중앙화 시스템으로 분류할 수도 있다. 컨소시엄 블록체인 여러 개의 서버로 나눠 저장할 뿐 기록과 검증을 정의된 소수에 의존 사전에 정의된 컨소시엄에 합류해야 기록의 검증에 참여가능 몇 개의 동종업계가 기록 분산 저장 방식 채택 ","date":"2022-03-26","objectID":"/archives/til/20220326/:14:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"프라이빗, 컨소시엄 효용성 훼손 사항 1. 심각한 안정성의 저해 해커의 목표가 뚜렷함 해킹에 안전하다는 말이 성립되지 않음 서비스 중단 공격 및 기록 변경 공격으로부터 안전했던 속성을 잃음 2. 확장성 보유 불가 사전에 정한 노드만 기록과 검증에 참여가능 3. 기록의 불변성 저해 채굴과정이 없음 기록 변경에 대해 쉽게 감지하거나 엄청난 에너지가 드는 리소스가 필요 없음 해시 함수만 다시 계산하면 언제든지 기록 변경 가능 4. 탈중앙화, 제3자의 개입 없이 거래 불가능 노드 자체가 이미 신뢰받는 제 3자의 역할 여러 개의 서버에 의존하는 방식으로 변경된 것임 퍼블릭 블록체인과는 거리가 멀다. 다소의 안전성을 제외하고 블록체인이 가지고 있는 모든 속성을 잃음 분산저장 =? 블록체인 안전성 유지 투명성 유지 탈중앙화 -\u003e 프라이빗, 컨소시엄 블록체인 기능 수행 불가 ","date":"2022-03-26","objectID":"/archives/til/20220326/:14:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 도입 전 체크리스트 1. 왜 블록체인이 필요한가? 용도에 따른 블록체인의 종류는 중요하지 않음. 왜 블록체인 도입을 생각했을까? 기록의 불변성, 안정성을 고려하면 -\u003e 퍼블릭/프라이빗 답이아님 안전성 때문에 새로운 시스템을 도입해야할 필요가 있을까? 2. 어떤 형태의 블록체인을 도입할 것인가 3. 도입하는 블록체인이 문제점을 해결 할 수 있는가? 안전성 분산이 해답이 아님 -\u003e 분산이 해답이라면 현재의 은행 모두가 해킹으로부터 안전하지 않을까? ","date":"2022-03-26","objectID":"/archives/til/20220326/:14:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 도입 시 고려사항 블록체인은 안전성을 위해 효율을 포기한 시스템이다. 현재 시스템으로 원하는 목적을 달성할 수 없는가? 블록체인은 그 효능이 한정적이다. ","date":"2022-03-26","objectID":"/archives/til/20220326/:14:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"컨소시엄 블록체인의 등장 컨소시엄, 프라이빗으로 구현 가능 하이퍼레저 시스템은 분산 저장시스템으로 부르는 것이 합당. 분산 저장시스템은 효용성이 있을 수 있음 새로운 효용을 만들 수 없을 수 있음 하이퍼렛저를 왜 이용하는지에 대해 꼼꼼히 따져봐야 함 분산저장 시스템은 더 큰 효용성을 둘 수 있을 경우에만 사용하도록 함 ","date":"2022-03-26","objectID":"/archives/til/20220326/:14:5","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"지분 증명 작업증명을 대체할 수 있는 방식 작업증명 방식을 대선하여 더 나은 방식으로 호도되기도 함 지분증명과 작업증명은 다른 방식 다수결, 코인보유량에 따라 결정방식이 다름 지분증명을 사용하는 블록체인 시스템 블록체인 시스템으로 부르기에 미흡함 안전성이 담보되지 않았음 투명성 문제가 제기되고 있음 완전한 무작위성에 의한 투명성을 가진 블록체인과는 거리가 멀다. Delegated POS, PPOS 표방한 블록체인은 미리 몇 개의 노드가 검증에 참여 -\u003e 컨소시엄 블록체인과 거의 동일한 형태 ","date":"2022-03-26","objectID":"/archives/til/20220326/:14:6","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인의 진정한 효용 안전성, 기록 불변성, 신뢰받는 제 3자 필요없는 거래, 누구나 검증에 참여 가능하다는 특징이 있음 블록체인은 완성형으로 사용할 수 있는 기술이 아닌, 많은 실험을 통해 그 효용성을 검증해 나가야 하는 상태의 기술임 ","date":"2022-03-26","objectID":"/archives/til/20220326/:15:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"프라이빗 블록체인과 컨소시엄 블록체인 프라이빗 블록체인 : 기능의 입루를 변형한 블록체인, 특정 노드가 서버 역할 수행, 하나의 서버만 존재 컨소시엄 블록체인 : 다수의 노드가 서버 역할 수행 프라이빗 블록체인과 컨소시엄 블록체인의 경우 누구나 참여하는 확장성이 결여 과정 종합 ","date":"2022-03-26","objectID":"/archives/til/20220326/:16:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 블록체인과 일반적 중앙집중 시스템 ","date":"2022-03-26","objectID":"/archives/til/20220326/:17:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인과 중앙 서버 비트코인의 탄생 유래 : 암호화를 통해 프라이버시 보호를 극대화하고자 했던 -\u003e 사이퍼 펑크 탄생 : 절대 익명 거래, 비가역성 거래 비트코인의 기반, 탈중앙화 시스템 분산시스템 =\u003e 일의 배분을 통한 효율성 추구 탈중앙화 시스템 =\u003e 일의 반복을 통해 기록 불변성과 안전성을 추구 블록체인 사용시 효율성 증대 불가능 -\u003e 중앙화 시스템 보다 일 반복 분산시스템 목적 \u003c-\u003e 블록체인 목적 비트코인의 목적 누구도 접근 불가능한 절대 익명의 금융거래 환경 신뢰받는 제 3장벗이 작동하는 방식 연구 -\u003e 블록체인 인프라 제안 탈중앙화 시스템 일의 반복을 통해 안정성을 추가한 시스템 ","date":"2022-03-26","objectID":"/archives/til/20220326/:17:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 블록체인의 기본 원리 ","date":"2022-03-26","objectID":"/archives/til/20220326/:18:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인의 기본 원리 트랜잭션 처리 방식 블록체인 정보 -\u003e 브로드 캐스팅 -\u003e 전체 노드 공유 중요한 정보에 블록체인에 담으면 안됨 ![[Pasted image 20220326182718.png]] 비트코인의 소유권 통제 비대칭 암호화에 의해 철저히 통제 브로드캐스팅 통해 모든 공유 -\u003e 기록 사용은 해당 개인키 소유자만 가능 공개키와 개인키로 이루어진 암호화로 소유권 통제 기록 조작 불가 작성된 기록 조작 시 해시 함수에 의해 발각 개인정보 노출 X 블록체인은 익명성에 기반 ","date":"2022-03-26","objectID":"/archives/til/20220326/:18:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인을 이루기 위한 기반 기술 해시 함수 입력 길이와 상관없이 늘 일정한 길이의 출력을 내는 함수 입력의 사소한 변화에도 출력이 완전히 달라짐 출력으로 입력 예측 불가 비트코인에서 해시 함수는 원래 문서의 변경 여부 탐지에 사용 해시 함수의 블록 해시 숫자 생성 현재 해시값 + 이전 해시값 : 모두 연쇄 반응을 일으키도록 설계 현재 블록값의 값 변경시 그 이후 생성 블록 값은 연쇄적으로 변경 제네시스 블록 값 변경 이후 생성된 블록은 해시값 변경 해시퍼즐 작업증명이라는 방식을 비트코인 형식으루 구현 비트코인에서의 작업증명 -\u003e 해시퍼즐 엄청난 양의 계산을 해야만 해결 가능 하나의 해시 퍼즐 풀이에 걸리는 시간 -\u003e 최소 10분이상 오래된 기록일수록 불변성이 기하급수적으로 증가 비대칭 암호화 기법 대칭형 암호화 기법 비대칭형 암호화 기법 -\u003e 암호화, 복호화 할때 서로 다른 키 개인키, 공개키 두 개의 키가 쌍을 이룸 개인키 소유자만이 잠금 장치를 풀 수 있음 실수령자만이 비트코인 사용 가능 비트코인은 짝이 되는 상대키로만 잠금 장치를 풀 수 있는 방식 적용 블록 기록 과정 ![[Pasted image 20220326183504.png]] 리더 선출 비트코인 -\u003e 해시 퍼즐을 가장 먼저 해결한 사람 작업증명 방식 지분증명 방식 -\u003e 안전성 문제, 블록체인으로 보기 어려움 검증 절차 리더로 선출된 노드가 전권을 보유하고 기록 수행 신뢰할 수 없으므로 검증 절차가 필요함 검증은 시스템에 참여한 모든 노드가 수행 합의 모든 노드가 동의하면 새로운 블록 형성 정상적인 블록이 아니라고 판명되면 폐기 소프트웨어 버전에 따라 블록체인의 기본 원리와 블록체인의 진정한 효용 발생 -\u003e 하드포크, 소프트포크 ","date":"2022-03-26","objectID":"/archives/til/20220326/:18:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"각 블록은 하나의 새로운 세계 세계를 지배할 리더 선출, 선출된 리더는 전권 보유 55만 개의 비트코인은 55만 번에 걸쳐 새로운 리더 선출 선출된 리더는 중앙 서버의 역할 기록하는 사람이 단 한명이기 때문에 기록할 리더는 계속 변경 비트코인 : 10분마다 반복 이더리움 : 15초마다 반복 ","date":"2022-03-26","objectID":"/archives/til/20220326/:18:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 블록체인의 진정한 효용 ","date":"2022-03-26","objectID":"/archives/til/20220326/:19:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인의 진정한 효용 이해 현업에서 블록체인의 필요 여부 판단 블록체인에서 요구 실현 가능성 판단 ","date":"2022-03-26","objectID":"/archives/til/20220326/:19:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"현업에서 블록체인이 비효율적인 경우 안정성보다 효율성을 추구할 때 -\u003e 블록체인 적절하지 않음 리더 선출의 무작위성 보장, 제3자 없이 거래 가능하도록 구축 제3자가 필요하거나 되고 싶은 경우 ","date":"2022-03-26","objectID":"/archives/til/20220326/:19:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 도입 시 만족해야 하는 사항 안정성, 기록불변성, 신뢰받는 제3자가 필요 없는 거래, 누구나 검증에 참여 가능한 확장성 일부만 필요하거나 모두 필요 없다면 블록체인은 적절한 솔루션이 아님 일부만 맞고할 경우 처리 여부는 스스로 판단 ","date":"2022-03-26","objectID":"/archives/til/20220326/:19:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인이 이루려고 했던 세상 DAO(Decentralized Autonomous Organization) 탈중앙화 된 자유 조직 자율적으로 실현될 수 있는 환경 추구 블록체인이 자율적 환경을 실현해줄 것이라도 믿음 이를 통한 경제적 이득 -\u003e 불필요한 수수려 제거 닉 사보의 스마트 계약 그 누구의 간섭없이 스마트 컨트랙트에 의해서만 꾸려지는 생태계 이 상태를 꿈꾸는 사람들이 만든 용어 블록체인의 비각역성과 불변성 블록체인의 기록 -\u003e 바꾸는 것이 어렵게는 가능 -\u003e 작업증명 방식 현실 -\u003e 비각역적 불변성은 아직 미구현 채굴업자들의 담함 블록체인 기록 언제든 변경 가능 더 다오 사건 이더리움 진영 사이에 다툼 발생 채굴업자와 담합 -\u003e 지금의 이더리움 채굴업자와 반기 -\u003e 이더리움 클래시 중재가 필요 없는 거래 연구 가치 있음 중재가 필요 없다는 자체로 의미를 가지지 못함 세상에 중재가 있는 이유는 필요하기 때문 ","date":"2022-03-26","objectID":"/archives/til/20220326/:19:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"현업에 블록체인 도입 시 고려사항 블록체인으로 어떤 효용을 얻을 것인가 기존에 없던 효용 획득 -\u003e 고객은 어떤 시스템이든 만족 효용 미획득 -\u003e 고객 그 효용이 기존의 시스템으로는 불가능한가 어떠한 형태로 블록체인을 구현해야 하는가 ","date":"2022-03-26","objectID":"/archives/til/20220326/:19:5","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인을 위한 블록체인 프로젝트 -\u003e 존립가치 없음 ","date":"2022-03-26","objectID":"/archives/til/20220326/:19:6","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"효용을 위한 블록체인 프로젝트 -\u003e 앞으로 계속 연구해야 할 영역임 ","date":"2022-03-26","objectID":"/archives/til/20220326/:19:7","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인과 일반적 중앙집중 시스템 분산시스템 : 일의 분산을 통해 효율을 올리려는 시스템 블록체인 : 탈중앙화 시스템으로서 일의 반복을 통해 기록의 불변성과 안정성을 꾀하려는 기술 ","date":"2022-03-26","objectID":"/archives/til/20220326/:20:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인의 기본 원리 블록체인은 브로드캐스팅을 통해 모든 정보를 전체 노드에 공유 블록 단위로 리더를 선출, 기록을 맡긴 다음, 그 기록이 정확한지 모든 노드가 검증 ","date":"2022-03-26","objectID":"/archives/til/20220326/:21:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인의 진정한 효용 블록체인은 효용성을 버리고 기록의 불변성과 안정성을 꾀함과 동시에, 신뢰받는 제 3자 없이도 거래가 가능한 P2P 시스템을 구현하고자 하는 것임 따라서 블록체인을 고려할 때는 이러한 효용이 진정으로 필요한 것인지 면밀히 검토하에 체크리스트 검토후 진행 ","date":"2022-03-26","objectID":"/archives/til/20220326/:22:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220326","uri":"/archives/til/20220326/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 원리(7) - 채굴과 51% 공격 ","date":"2022-03-24","objectID":"/archives/til/20220324/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 채굴과 블록 생성 ","date":"2022-03-24","objectID":"/archives/til/20220324/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록을 만드는 것 = 채굴 보상금 획득 하는것이 금 획득하는 것과 비슷 채굴 단어의 유래 - Nick Szabo 금이 가치를 갖는 것은 채굴이 어렵기 때문 어떤 문제가 매우 어렵다면 -\u003e 문제의 정답 자체가 어떤 가치를 가지지 않을까? 블록 만듦 -\u003e 해시 퍼즐 풀이 : 어려운 문제이기 때문에 정답 자체가 가치 보유 금을 캐려면 -\u003e 금광에서 채굴 : 힘든 작업이기 때문에 금이 가치 보유 해시 퍼즐 풀이 -\u003e(비유) 금광에서 채굴 채굴 == 블록을 만들다. ","date":"2022-03-24","objectID":"/archives/til/20220324/:1:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록을 왜 만들었을까? 블럭을 생성해야 거래내역을 기록할 수 있다. 해시 퍼즐 및 연쇄 -\u003e 비가역성 보유 비가역성 거래내역을 기록하기 위해 ","date":"2022-03-24","objectID":"/archives/til/20220324/:1:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시퍼즐 무작위로 해시함수 계산, 특정 패턴이 나올 때까지 무한 반복 풀이에 많은 에너지 필요 보조금 삭감 -\u003e 시세 하락 -\u003e 채굴업자에게 영향 채굴 시 소모 에너지 \u003e 채굴 보상금 -\u003e 채굴이 완전히 멈추는 현상 발생 ","date":"2022-03-24","objectID":"/archives/til/20220324/:1:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"채굴업자가 더 이상 채굴하지 않을 경우 거래내역을 담을 수 없게 됨 -\u003e 더 이상 블록체인이 움직이지 않음 채굴의 목적 -\u003e 경제적 수익 채굴 비용 \u003e 채굴 수익 -\u003e 블록체인 거래가 불가능하게 됨 ","date":"2022-03-24","objectID":"/archives/til/20220324/:1:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"채굴이 갑자기 멈추지 않는 이유 이미 채굴한 양이 많기 때문 한계점이 이상을 지나면 멈추는 시점이 찾아옴 ","date":"2022-03-24","objectID":"/archives/til/20220324/:1:5","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"발행량 반감 -\u003e 시세 하락 -\u003e 블록체인 안정도와 직접 영향 ","date":"2022-03-24","objectID":"/archives/til/20220324/:1:6","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 51% 공격 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"51% 공격 누군가 엄청난 하드웨어를 소유했다면? 단 한명이 나머지 사람들의 하드웨어보다 더 많은 자원을 가지는 현상 자원 및 계산량이 많으므로 -\u003e 블록을 만들 가능성이 높아짐 블록을 만들 확률 51% 블록을 만들지 못할 확률 49% 특정한 노드가 높은 확률로 계속 블록을 만드는 현상 발생 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"51% 시스템에 미치는 영향 거래내역 기록 -\u003e 블록 생성자가 결정 높은 수수료 거래내역 먼저 처리 자기 임의대로 거래내역 작성 시스템 교란 목적으로 거래내역 미작성 -\u003e 시스템 마비 누군가가 소유하고 있는 계산력 -\u003e 해시파워 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시파워 해시 퍼즐을 풀 수 있는 능력 시스템 계산량 51% = 해시 파워 51% 독점 52%의 해시 파워로 다른 노드 보다 항상 더 높은 확률로 블록 생성 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록 생산권 독점 시 악의적 상황 거래내역 미작성 서비스 자체가 방해되어 블록체인 서비스 비활성화 자신이 원하는 거래내역만 기록 수수료 인상 트랜잭션 처리 선택은 블록 생산자에게 달림 특정 수수료 지급 전까지 트랜잭션 미처리 블록 생산자가 원하는 수수료를 지불할 수 밖에 없음 이중 사용 동일한 비트코인을 두 번 이상 사용하려는 시도 상충된 지급내역이 브로드캐스팅 되어 네트워크에 확산 독점권 소유자가 자신에게 되돌아오는 거래내역만 처리 이중사용 항상 성공 자기 자신이 블록을 결정 긴 블록 생성 후 기존 블록 퇴출 긴 블록체인 생성 후 기존 블록 퇴출 시스템 자체의 안전성을 저해 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"51% 공격 특정 노드가 해시 파워 독점, 시스템 전체를 교란시키는 공격 과반수 이상을 차지한 상징적 경우 의미 이클립스 공격, 이기적인 채굴자 공격 -\u003e 과반수 해시 파워 없이 시스템 교란 가능 25% 시스템 독점 시 시스템 교란 가능 입증 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:5","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"51% 공격, 실제로 일어날까? 상위 10개 채굴 업체가 보유 -\u003e 전체 해시 파워 55% 장악 언제든 51% 공격 가능 공격 확률은 낮다 -\u003e 경제적 이득이 적음 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:6","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"51% 공격자가 이득을 얻는 경우 디지털 서명, 비대칭 암호화 기법, 해시 함수 -\u003e 원천적으로 불가능 타인의 비트코인 약탈 불가능 이득을 얻는 유일한 방법은 이중사용 이중 사용 물건을 건내 준 사람이 무한정 기다리면 무조건 실패 타인이 비트코인이 아닌 자신의 비트코인 두 번 사용 타인의 비트코인 약탈 불가능 51% 공격을 감행해서 가치를 떨어뜨리는 것보다 가치를 유지하면서 더 많은 보상금을 획득하는 것이 나음 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:7","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"현재 블록체인 구조 정상적 블록 생성이 경제적으로 더 이득 51% 공격 발생 확률 높지 않음 랜덤화를 통해 투명성을 이끌었던 블록체인의 기본정신 훼손 상위 3개 업체가 과반 이상의 블록 생성 10% 업체가 전체 90% 블록 생산 99.9999% -\u003e의존 0.0001% 블록체인 존립에 심각한 위협 요소 단 10개의 노드가 채굴 중지 시 더 이상 거래 불가능 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:8","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인 블록체인 채굴자원의 독점 심화, 심각한 위협 ","date":"2022-03-24","objectID":"/archives/til/20220324/:2:9","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"채굴과 블록 생성 채굴은 블록 만들기의 다른 이름임 블록을 만든다는 의미는 거래내역을 보관한다는 의미임 ","date":"2022-03-24","objectID":"/archives/til/20220324/:3:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"51% 공격 51% 공격이란 특정 노드가 시스템 해시자원 51% 이상을 독점한 상황을 상징적으로 나타내는 말을 뜻함 시스템 자원을 51% 독점하게 되면 블록 생산권을 독점하게 되고, 이에 따라 다양한 형태로 시스템 공격이 가능함 51% 공격은 경제적 이득보다는 주로 시스템 교란에 의한 서비스 단절이 주된 위협임 중개인이 없는 거래 - 스마트 계약 개념 및 이더리움 구현 방식 ","date":"2022-03-24","objectID":"/archives/til/20220324/:4:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 중개인이 없는 거래 ","date":"2022-03-24","objectID":"/archives/til/20220324/:5:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"상거래에서의 제 3자 이용 은행이라는 제 3자를 두고 계좌이체하는 것 이때 은행은 중앙 서버역할 수행 및 수수료 획득 ","date":"2022-03-24","objectID":"/archives/til/20220324/:5:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"제 3자를 활용한 거래의 단점 임의 기록 수정 악의적 의도 기록 변경 불필요한 수수료 발생 ","date":"2022-03-24","objectID":"/archives/til/20220324/:5:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"중개인이 없는 거래가 가능하다면 불필요한 수수료 절감 ","date":"2022-03-24","objectID":"/archives/til/20220324/:5:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 거래 중앙 서버 없이도 안심하고 거래할 수 있는 환경 구축 해시파워를 제일 먼저 해결한 노드가 기록함 -\u003e 다만, 모든 참여자의 검증 중앙서버에 비해 높은 안정성 보유 별도 수수료 지급하지 않음 직거래 시스템 구축 가능 응용분야 : 중고 물품 거래, 중고차 거래 기대 : 수수료 절감 ","date":"2022-03-24","objectID":"/archives/til/20220324/:5:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"중개인이 없는 거래의 이면 항상 좋은 것일까? 비트코인을 사용하다가 비밀번호를 잊어버리면 ? 비트코인 키를 저장한 장치를 훼손하게 되면? 잘못된 주소로 비트코인을 전송하게 되면? ","date":"2022-03-24","objectID":"/archives/til/20220324/:5:5","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"금융거래 중개인 은행의 비밀번호를 잊어버리면? 은행 공인인증서를 훼손하게 되면다면? 은행에 중재 요청하여 해결 가능 ","date":"2022-03-24","objectID":"/archives/til/20220324/:5:6","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"중개인이 없는 거래 수수료가 절감 되는가? 채굴업자에게 지급하는 수수료가 더 적은지는 알 수 없음 ","date":"2022-03-24","objectID":"/archives/til/20220324/:5:7","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"절대 익명의 거래 많은 문제점 발생, 중재자 필요 중고차를 익명으로 거래한 경우 이득 -\u003e 수수료 절감 단점 -\u003e 중고차를 구매인은 하자 발생 시 중재자 없음 블록체인을 통한 중고차 직거래? 아직은 희망사항일 뿐, 해결해야하는 문제 다수 존재 개인정보 보호 문제 해결 브로드캐스팅 모든 노드가 블록체인 데이터 확인 가능 개인정보가 담기게 된다면 -\u003e 모든 노드가 개인정보 확인 가능 브로드캐스팅을 사용하는 한 개인정보를 담아서는 안 됨 블록체인을 이용한 거래 개인 정보 불필요한 거래 성사 전까지 해결 요소 많음 ","date":"2022-03-24","objectID":"/archives/til/20220324/:5:8","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 스마트 계약 ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"스마트 계약 법률가 Nick Szabo -\u003e 1990년대 자신의 아이디어 제 3자의 개입 없이도 스스로 계약을 집행할 수 없을까? 디지털 환경을 잘 꾸미면 제 3자 개입 없이 계약을 집행할 수 있을 거라 생각 제 3가 개입하지 않아도 계약 집행 가능 ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"대부분의 계약 공증을 위한 변리사, 법무사, 변호사 ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"Nick Szabo 스마트 계약 스스로 디지털화 되어 집행하는 계약 블록체인의 직접 거래와 같은 맥락 ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인 블록체인에 기록할 수 있는 것 정적인 내용 비트코인 거래 기록 외 다른 기록을 하기 위해서는 프로그램 자체를 수정해야 한다. 프로그램을 수정하지 않고 다른 용도로 블록체인을 사용할 방법이 없을까 -\u003e 동적인 데이터를 담으면 어떨까? ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록에 담긴 내용이 컴퓨터 프로그래밍이라면? 프로그램을 통해 명시한 조건에 따라 다른 결과 도출 디지털 환경을 통한 스마트 계약 -\u003e Nick Szabo 아이디어 동일 프로그램을 호출하여 계약을 집행 프로그램 -\u003e 계약내용 , 저장장치 -\u003e 프로그램을 불러오는 장치 닉 사보의 스마트 계약이 실행 될지도 모름 ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:5","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"Smart contract 정적인 거래내역 이외에 거래내역 자체를 컴퓨터 프로그램으로 기술하는 방식 호출이 가능하여 호출 때마다 실행 메세지를 통한 매개 변수에 따라 서로 다른 작용 동적으로 여러가지 다른 용도 사용 가능 ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:6","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인 블록체인의 스마트 컨트랙트 아주 기초적으로 구현되어 있음 사카시 나카모토도 스마트 컨트랙트를 구현해둠 -\u003e 실행을 위한 도구는 미제공 ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:7","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움 스마트 컨트랙트 모습을 완전히 갖춘 최초의 블럭체인 ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:8","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"계약과 컨트랙트(Contract) 계약 : 금융, 결제에 국한. 국한적 의미 컨트랙트 : 금융, 결제 외 광범위한 의미. 범용적 의미 거래내역, 계약, 컨트랙트는 기본적으로 같은 의미 ","date":"2022-03-24","objectID":"/archives/til/20220324/:6:9","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 이더리움에서의 스마트 계약 ","date":"2022-03-24","objectID":"/archives/til/20220324/:7:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움에 구현된 스마트 계약 스마트 계약 : 제3자의 개입없이 스스로 집행하는 계약의 구상 스마트 계약 구현 방법 정적인 기록이 아닌 프로그램 기록 이더리움에서는 프로그램화 된 내용을 블록에 쉽게 담을 수 있는 환경을 제공 -\u003e IDE(Integrated development Environment) 원하는 프로그램 작성 -\u003e 컴파일 -\u003e 이더리움에 불러오도록 저장 기존비트코인(정적인 기록 저장) \u003c-\u003e IDE(프로그램 저장) 사용자가 작성 프로그램 결정 -\u003e 그 방식에 따라 무한가지 용도 솔리더티 이더리움에 사용되는 언어 솔리더티를 사용하여 프로그램 -\u003e 컴파일 -\u003e 코드저장 언제든 호출 가능하고 호출되면 프로그램 실행, 결과는 블록체인에 저장 같은 기록이라도 실행될 때의 매개 변수, 컨디션에 따라 다른 겨로가 도출 ","date":"2022-03-24","objectID":"/archives/til/20220324/:7:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"프로그램을 통한 암호화폐 전달 기능 비트코인을 통해 축구 내기를 한 경우 제3자가 필요 승자에게 비트코인 전달이 제대로 이루어졌는지 중재해야함 이더리움을 통해 축구 내기를 한 경우 축구 내기 프로그래밍 당사자가 만날 필요 없음 승자에게 자동으로 이더리움 전송 내기 프로그래밍 하기 스마트 컨트랙트 호출, 내기 참여 결과에 따라 이더리움 전송 기다리기 ","date":"2022-03-24","objectID":"/archives/til/20220324/:7:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"컴퓨터를 범용기계라고 하는 이유 게임 소프트웨어 설치 : 게임기 스프레드 시트 사용 : 회계용도 어떤 프로그램을 구동하느냐에 따라 용도 변경 비트코인 하나의 용도만 가진 기계 이더리움 최초의 범용 블록체인 용도 무한대 가능 ","date":"2022-03-24","objectID":"/archives/til/20220324/:7:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"스마트계약 해결애햐할 문제 이더리움을 이용한 스마트 계약 -\u003e 여전히 해결해야 할 문제 다수 ","date":"2022-03-24","objectID":"/archives/til/20220324/:7:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"중개인이 없는 거래 제 3자의 개입 없이 블록체인 거래 필요 없는 수수료 절감과 함께, 한 번 기록되면 변경되지 않는 플랫폼을 구축하는 것을 목표로 함 ","date":"2022-03-24","objectID":"/archives/til/20220324/:8:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"스마트 계약 스마트 컨트랙트는 제 3자의 개입 없이도 계약을 실행할 수 있는 디지털 환경에 대한 개념 이더리움에 의해 블록체인에 구현 ","date":"2022-03-24","objectID":"/archives/til/20220324/:9:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"이더리움에서의 스마트 계약 이더리움에서는 솔리더티 등의 언어로 프로그램을 작성할 수 있는 통합 환경 제공 프로그램을 통해 여러 조건을 정의 할 수 있음 프로그램은 컴파일 된 후 블록에 저장되고 호출되어 실행 됨 ","date":"2022-03-24","objectID":"/archives/til/20220324/:10:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220324","uri":"/archives/til/20220324/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 원리 - (5) 비가역성 블록체인 원리 (6) - 하드 포크와 소프트 포크 ","date":"2022-03-21","objectID":"/archives/til/20220321/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 하드 포크와 소프트 포크의 기본 개념 ","date":"2022-03-21","objectID":"/archives/til/20220321/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"하드 포크와 소프트 포크 동일한 블록에서 노드가 다른 행동을 하는 이유 중앙화 서버 : 하나의 소프트웨어를 여러 사람이 접속 블록체인 : 각자의 소프트웨어 접속 -\u003e 모든 사람의 소프트웨어 버전이 다르기 때문에 발생 블록체인의 소프트웨어 변경 최신 소프트웨어 사용자 -\u003e 모든 변경이 반영된 상태로 사용 이전 소프트웨어 사용자 -\u003e 변경이 반영되지 않은 형태로 사용 하드포크, 소프트 포크 동일한 블록에 대해 서로 다른 규칙을 적용, 서로 다른 결론에 이르는 현상 규칙이 상충시 발생하는 두 가지 현상 과거에는 유효하던 규칙이 지금은 무효화 과거에는 무효하던 규칙이 지금은 유효화 -\u003e 결국 블록체인 데이터에 영향을 미치게 됨 ","date":"2022-03-21","objectID":"/archives/til/20220321/:1:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 하드 포크 ","date":"2022-03-21","objectID":"/archives/til/20220321/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"하드 포크 하나의 네트워크 안에 두 개의 블록체인 데이터 생성 이전 소프트웨어 사용 그룹이 모드 업데이트 하기전까지 절대 하나로 합쳐지지 않는 현상 갈라진 상태가 그대로 고착 과거에는 무효이던 규칙이 유효화되는 경우 발생 하드 포크 예시 블록의 크기가 바뀐 경우 비트코인의 블록의 크기 1MB -\u003e 2MB 경우 무효 및 기각 소프트웨어 변경으로 2MB 블록 허용한 경우 이전 버전, 최신 버전 사용자 서로 다른 블록생성 최신 버전이 사용자가 생성한 블록은 이전 버전 사용자 규칙을 어기게 된 블록 ","date":"2022-03-21","objectID":"/archives/til/20220321/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"소프트 포크 과거에는 유효이던 규칙이 무효화되는 경우 발생 과거 사용규칙 -\u003e 심각한 결함을 발견 -\u003e 사용불가 판단 이전 노드는 최신 소프트웨어 블록에 블록체인 데이터 강제적 통일 소프트 포크의 성공 여부는 채굴업자의 협조 여부에 달림 -\u003e 최신 버전 사용 채굴업자 소프트 포크 성공 가능성 유효하던 규칙을 무효화한 소프트웨어를 배포한 경우 최신 소프트웨어 사용자 무효화된 규칙 삭제한 블록 생성 이전 소프트웨어 사용자 무효화 된 규칙 포함한 블록 생성 이전 소프트웨어 사용자 -\u003e 다양한 블록 생성 가능 소프트웨어를 채굴업자들이 많이 사용하게 하려면 소프트 포크 감행 전 반드시 협조 요청 ","date":"2022-03-21","objectID":"/archives/til/20220321/:2:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"하드포크 소프트 포크 비교 발생 하드포크 : 과거에는 무효이던 규칙이 유효화되는 경우 발생 소프트포크 : 과거에는 유효이던 규칙이 무효화되는 경우 발생 예시 하드포크 : 1MB -\u003e 2MB 블록크기 허용 최신 사용자 : 유효 이전 사용자 : 무효 소프트포크 : 과거 사용한 규칙 -\u003e 결함 -\u003e 미사용 및 삭제 최신 사용자 : 무효화된 규칙 미사용 -\u003e 이전 사용자 제작 불록 -\u003e 무효함 이전 사용자 : 무효화된 규칙 사용 -\u003e 최신 사용자 제작 블록 -\u003e 유효함 통일 시점 하드 포크 기존 블록은 유효하지 않으므로 업그레이드 블록을 따라가지 않음 모든 노드가 새로운 블록체인으로 업그레이드 할 때 하나의 블록체인 데이터로 통일 소프트 포크 기존 블록은 업그레이드 블록이 유효한 블록으로 인정 최신 소프트웨어 버전의 블록체인 데이터를 이전 소프트웨어 사용자는 강제적으로 따라감 프로그램의 업그레이드 및 변경 블록체인의 경우 일괄 변경 가능성 매우 낮음 소프트웨어 업그레이드 여부는 노드를 운영하는 사람이 결정 중앙화 서버 중앙서버만 변경하면 일괄 변경 가능 소프트웨어 메인터넌스 업그레이드 블록체인에서 가장 어려운 부분 가급적 자제하는 것이 바람 채굴업자 사전 협약으로 성공확률 높이는 것 중요 채굴업자 동의 없이는 블록 생산이 거의 불가능 블록체인 데이터는 중앙화 서버에 비해 소프트웨어 관리가 어려움 ","date":"2022-03-21","objectID":"/archives/til/20220321/:2:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 비가역성의 의미 ","date":"2022-03-21","objectID":"/archives/til/20220321/:3:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"비가역적 기록 기록 후 어떠한 경우에서도 변경하지 못하도록 하는 성질 블록체인은 비가역적 성질을 가지기 위한 방법에 대한 연구와 관련이 있음 현실적으로 비각역적 기록성을 가진 장치의 제작은 불가능 비가역적 기록장치처럼 제작하는 것은 가능 대표적인 방법은 작업증명 방식을 사용한 해시퍼즐 블록체인 기록을 하기 힘든 장치 기록 후 수정이 매우 힘든 장치 비가역성을 소프트웨어로 구현하기 위한 방식 기록의 무결성 유지 방법 : 모든 노드가 항상 검증에 참여 비가역적 기록장치가 존재하지 않는다면 주기적으로 기록의 변경여부를 모든 노드가 다시 검증해야 하는 문제점 발생 비가역적 기록장치의 필요성 최초 기록의 정확한 검증 가능 주기적인 검증 노력 불필요 검증 과정 단순화를 위해 비가역적 장치 필요 모든 노드가 연속적으로 검증 반복 -\u003e 비가역적 기록장치 불필요 비가역적 장치의 부재 -\u003e 신규 블록 생성에 있어 문제 발생 블록체인의 사이클 누가 기록할 것인지 선발(리더 선출) 선출 된 리더가 기록 모든 노드가 기록의 규칙 준수 여부 확인 (검증) 비가역적 보관 = 동의 합의 -\u003e 한 번의 검증을 마치는 문제는 시스템의 현실적 구축과 직결되는 문제가 될 수 있음. -\u003e 제대로 된 검증 규칙으로 하나의 블록체인이 형성됨 -\u003e 비가역적 보관을 할 수 있는 장치가 존재하지 않는 경우 현실적인 에너지 낭비 문제 발생 기록의 검증 + 비가역성 = 기록에 대한 신뢰 생성 재검증 하지 않더라도 영속적으로 이어짐 사카시 나카모토 작업증명 방식으로 비가역성 증명 -\u003e 수시로 재검증을 해야 하는 과정이 반복되면 블록체인은 존재 불가 ","date":"2022-03-21","objectID":"/archives/til/20220321/:3:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 비가역성의 구현 ","date":"2022-03-21","objectID":"/archives/til/20220321/:4:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인에서 비가역성을 구현하기 위해 활용 해시 함수 작업증명 ","date":"2022-03-21","objectID":"/archives/til/20220321/:4:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"비가역성의 구현 단계 1단계 : 작업증명 블록체인은 최초 기록과 수정이 어려운 장치 기록이 항상 작업증명을 거치도록 만들어짐 블록체인은 최초 기록과 수정에 에너지가 많이 소모됨 해시 퍼즐 해결을 위해 10분이상 쉬지 않고 해시 함수를 반복 계산 작업이 10분 안에 이루어질 수 있도록 난이도 조절 정확한 기록을 위해 소프트웨어를 이용한 기록을 어렵게 만듦 블록체인에 정보를 기록하기 위해 반드시 해시퍼즐 해결 블록체인의 기록 시 한 번에 진실을 쓰려고 노력하게 됨 2단계 : 연쇄해시를 통한 작업변경의 기하급수적 증가 해시퍼즐 일련의 과정을 통해 특정 목표값보다 더 작은 값을 찾는 과정 블록헤더에는 이전 해시값이 들어있음 현재 블록의 해시값을 찾을 때 이전 블록 해시값을 포함하여 계산함 앞에 있는 블록의 값이 변경되는 경우, 이후 블록의 해시값도 변경됨 연쇄 해시의 효과 해시 퍼즐을 미리 풀 수 없음 현재의 값 계산을 위해 바로 직전 블록의 해시 값이 존재 해야 하므로 불가능 하다. 바로 직전에 만들어진 블록의 다음 블록만 생성 가능 이전 블록의 해시값이 변경 되면 이후 값은 모두 변경됨 특정 블록의 특정값을 아무도 모르게 변경할 수 없음 블록체인의 계산 현재 블록의 해시값은 연쇄적으로 시작된 모든 해시값이 계산됨 제네시스 블록이 변경되면 이후의 모든 블록값이 변경됨 -\u003e 모든 블록의 해시값을 다시 계산 특정값을 변경하기 위해서는 바꾸려는 블록 이후의 모든 블록 해시값을 다시 계산 블록체인의 작업증명은 오래된 기록이 변경될 수록 작업량이 기하급수적으로 늘어남 Prohibitively Expensive 엄두도 못 낼 정도의 과도한 비용 소모를 의미 비가역성 구현 방식은 변경 자체가 거의 불가능한 상태로 만들어졌음을 의미함. 블록체인은 정말 변경이 불가능한가 방금 만들어진 블록 -\u003e 하나의 해시 퍼즐만 계산하면 변경 가능 이중사용을 위해 6개의 블록을 만들어라 점차 현재 값의 변경이 어려워짐 블록의 깊이가 깊어질수록 변경 가능성은 기하급수적으로 낮아짐 ","date":"2022-03-21","objectID":"/archives/til/20220321/:4:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220321","uri":"/archives/til/20220321/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 원리 - (4) 탈중앙화 합의 및 이중사용 ","date":"2022-03-17","objectID":"/archives/til/20220317/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 탈중앙화 합의 규칙의 개념 ","date":"2022-03-17","objectID":"/archives/til/20220317/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"탈중앙화 합의 규칙 규칙 미준수 -\u003e 폐기 규칙 준수 -\u003e 동의 탈중앙화 합의 규칙에는 규칙을 지켰을 때도 퇴출하는 방식이 필요 ","date":"2022-03-17","objectID":"/archives/til/20220317/:1:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인의 특징 구성상 P2P 혹은 피어투피어 방식으로 이루어짐 특정 서버가 존재하지 않음 브로드캐스팅을 통해서 자신의 피어를 통한 데이터 전송을 받고 있음 모든 노드는 현재 자신이 가지고 있는 데이터와 피어로부터 전달받은 데이터에 의존해서 모든것을 판단해야 함 중앙서버 중앙 통제 서버가 모든 지시를 내림 -\u003e 노드는 지시에 따름 블록체인 모든 노드가 동등한 권리와 의무를 가짐 -\u003e 지시를 받을 수 없는 구조 블록체인에서 데이터를 수집할 수 있는 방법 네트워크를 통해 정보 수집을 위해 피어를 통한 방식을 사용 현재 데이터와 피어가 준 데이터에 기초하여 모든 업무를 처리 서로 다른 블록을 가지고 검증에 임하게 되는 경우 서로 다른 데이터로 구성된 블록체인이 생성됨 규칙을 위반한 적이 없음 서로의 노드가 각자 먼저 해시 퍼즐을 풀었다고 생각함 전파 속도가 늦어져 다른 내용을 만들게 됨 하나의 네트워크에 서로 다른 두 진실이 존재 하나의 동일한 진실만 기록해야 하므로 두 노드 중 하나를 퇴출 ","date":"2022-03-17","objectID":"/archives/til/20220317/:1:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"탈중앙화 합의 과정 서로 내용이 상이하여 하나의 값으로 통일하는 과정 더 긴 길이의 노드가 이기게 됨 블록체인의 데이터가 상이함을 발견하는 순간 두 블록체인의 길이를 비교함 동일한 규칙을 지켰음에도 서로 내용이 다르다면 길이를 비교하고 긴 것을 따라 가게 됨 블록체인 데이터가 상이한 이유 P2P 시스템인 블록체인에 전체 상황을 일괄적으로 통제해서 알려 줄 시스템이 없기 때문 블록체인 데이터의 표현 난이도가 일정한 경우 -\u003e 블록체인 길이로 표현 가능 (대부분의 경우) 난이도가 다른 경우 -\u003e 블록체인 무게를 통해 표현 가능 상충된 블록체인이 하나로 맞춰짐 언제든 동일한 데이터 유지 퇴출된 블록에 포함된 보상금 소멸 ","date":"2022-03-17","objectID":"/archives/til/20220317/:1:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 이중사용 ","date":"2022-03-17","objectID":"/archives/til/20220317/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"이중사용 동일한 암호화폐를 여러번 사용하려는 악의적 시도를 의미 브로드캐스팅을 통해 노드들이 거래내역이 정상인지 판단 -\u003e 상충된다는 사실이 발견되면 폐기 블록을 생성하는 노드에 두 거래내역 중 하나만 전달 된 경우 -\u003e 둘 중 하나만 먼저 처리 두 가지의 경우가 모두 처리되는 일은 없음 -\u003e 시스템적으로 이중사용은 완벽히 해결 ","date":"2022-03-17","objectID":"/archives/til/20220317/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 이중사용의 상거래적 측면에서의 해석 ","date":"2022-03-17","objectID":"/archives/til/20220317/:3:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"이중사용의 상거래 측면의 해석 시스템상으로 완전히 해결하였으나, 상거래 측면에서는 미해결 기록된 내용이 확인 되어야 한다. 탈중앙화의 합의과정에 의해 거래가 취소 될 수도 있다. ","date":"2022-03-17","objectID":"/archives/til/20220317/:3:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인을 안전하게 사용 방법 이론상 대체로 6개의 블록이 생성될 때까지 기다려야 한다. 거래의 즉시성을 해침 일반 상거래에서는 부적절 할 수 있다. ","date":"2022-03-17","objectID":"/archives/til/20220317/:3:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220317","uri":"/archives/til/20220317/"},{"categories":["TIL \u0026 Issue Note"],"content":"Getting Started ","date":"2022-03-16","objectID":"/archives/til/20220316/:0:0","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"What is React ? 사용자 인터페이스를 구축하기 위한 자바스크립트 라이브러리 모바일 앱처럼 상호작용과 반응성이 높은 사용자 환경을 제공 ","date":"2022-03-16","objectID":"/archives/til/20220316/:1:0","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"모바일 앱 화면 전환이 빠르고 사용자 반응성이 높음 ","date":"2022-03-16","objectID":"/archives/til/20220316/:1:1","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"웹 전통적인 웹사이트의 전환은 1) 링크,버튼 등 요청 2) 서버에서는 응답을 받고 새로운 HTML을 그림 서버와 요청과 응답 작업으로 인해 상호작용이 투박함 서버에서 처리한 HTML이 로드되는 것을 기다려야 함 ","date":"2022-03-16","objectID":"/archives/til/20220316/:1:2","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"자바스크립트 사용자가 보는 것을 조작할 수 있는 프로그래밍 언어 DOM에 접근하고 조작할 수 있다. HTML 페이지를 fetch하지 않아도 사용자가 보는 것을 바꿀 수 있다. ","date":"2022-03-16","objectID":"/archives/til/20220316/:1:3","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"왜 React를 사용해야 하는가? ","date":"2022-03-16","objectID":"/archives/til/20220316/:2:0","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"Javascript 모든 단계를 일일이 지정해야 한다. 명령형 접근 ","date":"2022-03-16","objectID":"/archives/til/20220316/:2:1","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"React 사용자 지정 HTML 구성요소(컴포넌트) 애플리케이션은 작은 블록 단위 즉 컴포넌트로 단위로 분해하여 관리함. 높은 수준의 Syntax 제공 ","date":"2022-03-16","objectID":"/archives/til/20220316/:2:2","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"Building Single-Page-Application (SPAs) ","date":"2022-03-16","objectID":"/archives/til/20220316/:3:0","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"React Alternative ","date":"2022-03-16","objectID":"/archives/til/20220316/:4:0","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"React 리액트의 경우 라이브러리 특정 기능이 필요하면 서드 파티 라이브러리를 추가해야 함 ","date":"2022-03-16","objectID":"/archives/til/20220316/:4:1","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"Angular 프론트엔드 프레임워크 리액트 보다 더 많은 기능을 가지고 있음 타입스크립트 내장 ","date":"2022-03-16","objectID":"/archives/til/20220316/:4:2","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"Vue.js Angular, React를 조금씩 섞어놓은 버전 라우팅 등 일부 기능 제공 JavaScript Refresher ","date":"2022-03-16","objectID":"/archives/til/20220316/:4:3","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"let \u0026 const 둘 다 변수를 선언할 때 사용 이전에는 var 키워드를 사용하여 선언함 let : 가변변수 선언시 사용 const : 처음 값을 할당한 후 바꾸지 않을 경우 사용. 상수 선언시 주로 const를 위주로 사용함 ","date":"2022-03-16","objectID":"/archives/til/20220316/:5:0","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"Arrow Function 함수 선언 방법 function myFunc() { // ... } 함수 선언 방법 - Arrow Function const myFunc = () =\u003e { // ... } Arrow Function은 this가 들어가서 발생하는 문제를 해결한다. this가 항상 원하는 객체를 참조 하지 않는 문제를 해결 ","date":"2022-03-16","objectID":"/archives/til/20220316/:6:0","tags":["TIL","javascript","react"],"title":"[TIL \u0026 Issue Note] 20220316","uri":"/archives/til/20220316/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 원리 (3) - 작업증명 : 해시 퍼즐과 난이도 ","date":"2022-03-15","objectID":"/archives/til/20220315/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 블록만들기와 해시 퍼즐 ","date":"2022-03-15","objectID":"/archives/til/20220315/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시 퍼즐 무차별 대입법 -\u003e 특정 값 -\u003e 무한 반복 산수 문제 해시 퍼즐을 푸는 수학적 공식은 없음 무수히 반복되는 산수 문제 해결 해시를 통해 얻게 되는 고유한 값 32 Byte 값 -\u003e SHA-256 - 유효한 블록의 해시값을 찾을 때까지 무한 반복 해시 퍼즐 정답 = 블록 고유 해시값 제네시스 블록 해시값 = 2의 32승 번 값 계산 -\u003e 약 10분동안 계산 ","date":"2022-03-15","objectID":"/archives/til/20220315/:1:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시 퍼즐 풀이 블록 헤더의 넌스값을 0 으로 설정 비트코인 해시 함수를 연속 2번 해싱 (SHA-256) : 임의의 32 Byte 값 블록 전체를 해시함수를 연속 두 번 적용하여 나온 해시값 H와 주어진 목표값 T 값을 비교 주어진 값보다 더 작거나 갖지 않다 -\u003e 넌스 1증가 (1 ~ 32 까지 증가) -\u003e 임의의 32 Byte 값 생성 반복 판단박스 목표 값보다 T보다 작아질 때까지 반복 ","date":"2022-03-15","objectID":"/archives/til/20220315/:1:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"넌스값 입력의 사소한 변화 32 Byte 충분히 작은 값이 나올 때까지 반복 T(목표값) -\u003e 목표값이 작을 수록 만족 힘듦 ","date":"2022-03-15","objectID":"/archives/til/20220315/:1:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"작업증명 퍼즐을 이용해서 의도적으로 막대한 에너지를 소모하게 만든 방식 스팸 방지를 위해 개발 의도적으로 막대한 에너지를 소모하게 하여 그 일을 억제 최초 기록 및 변경에 막대한 에너지 소모 -\u003e 반대 급부의 경제적 이득이 없으면 변경 이유 없다 최초의 기록된 노드의 검증 -\u003e 합당한 이유 없다면 정상적 기록을 통한 보상금 -\u003e 합리적 선택 스팸 방지 네트워크 과부하 문제 어떤 작업을 반드시 해야만 되도록 부과 -\u003e 스팸 억제 ","date":"2022-03-15","objectID":"/archives/til/20220315/:1:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 해시 퍼즐과 난이도 ","date":"2022-03-15","objectID":"/archives/til/20220315/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시 퍼즐과 난이도 목표값이 작아지면 해시퍼즐을 찾을 확률이 줄어듬 목표값을 성취하려면 과정 반복 필요 ","date":"2022-03-15","objectID":"/archives/til/20220315/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시 퍼즐의 비유 더 작은 해시 값 찾기 = 목표 값 찾기 해시 함수를 통해 얻는 값 32 byte로 이루어진 값이 어떤 특정 패턴을 이룰 수 있는 방법 -\u003e 0000 (0), 1111 (2의32승-1) 목표값은 작아질 수록 ㅎ시행횟수 증가 -\u003e 오래시간 소요 목표값을 조정하여 목표값에 맞는 해시값을 찾는데 필요한 계산횟수 횟수는 오래 걸리지만 시간은 10분 소요 -\u003e 과거에 비해 빠른 컴퓨터 난이도 조절 이유 컴퓨터가 발달 하여도 10분에 하나씩 블록 생성 목표값과 해시값의 관계 1,209,600초 -\u003e 10분이하로 블록 생성 늦은 시간 -\u003e 하나의 블록생성시 10분 이상 걸림 원래 소요시간보다 적을 겨우 -\u003e 난이도 상승 원래 소요시간보다 낮음 -\u003e 난이도 하향 ","date":"2022-03-15","objectID":"/archives/til/20220315/:2:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"목표값 ","date":"2022-03-15","objectID":"/archives/til/20220315/:2:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"무어의 법칙 반도체의 발달 속도 - 18 개월마다 반도체의 직접도가 두배가 되어 18개월마다 컴퓨터 속도 2배 항샹 지속적으로 난이도조절 2009 ~ 2017 63배 무어의 법칙에 따른 자연적인 증가 막대한 하드웨어의 투자 + 전용 기계 -\u003e 인위적 수치 난이도 증가는 블록체인의 영속성에 영향 ","date":"2022-03-15","objectID":"/archives/til/20220315/:2:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220315","uri":"/archives/til/20220315/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 원리(2) - 블록의 구조 ","date":"2022-03-14","objectID":"/archives/til/20220314/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 블록의 이해 ","date":"2022-03-14","objectID":"/archives/til/20220314/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록 (Block) 의미 있는 묶음 = 1 BLOCK 어떤 의미있는 단위를 한 블록으로 정의 특정 데이터를 다루는 단위 비트코인 블록체인 1 MB 까지의 한도 내에서 거래내역을 기록한 단위 (2000 ~ 3000 거래 내역) 비트코인 캐시 (8MB 까지 허용), 비트코인 골드 이더리움 블록체인 이론적인 한도는 없음 비트코인 블록의 구조 블록 헤더 : 데이터의 요약 정보 블록 헤더의 크기 : 80 Byte 항상 일정한 크기를 유지 블록 데이터 : 실제의 데이터를 담는 부분 ","date":"2022-03-14","objectID":"/archives/til/20220314/:1:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 블록의 구성요소 ","date":"2022-03-14","objectID":"/archives/til/20220314/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인의 구성 요소 블록 크기 : 4 Byte 거래내역 개수 : 가변 (1 ~ 9 Byte) 트랜잭션 : 가변 트랜잭션 크기는 기록된 트랜잭션 개수에 따라 변화 블록체인의 특징 1. 실제 거래내역 개수가 적을 때 실제로 개수를 저장 블록체인의 특징 2. 거래내역 개수가 많아질 때는 바이트를 사용 거래내역 개수의 규칙 1 ~ 9 Byte로 제한 선두 바이트 : 거래 개수에 적혀 있는 바이트 표시 -\u003e 전체 데이터 바이트 절약 거래내역 개수 = 트랜잭션 개수 ","date":"2022-03-14","objectID":"/archives/til/20220314/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인 트랜잭션 하나의 비트코인 주소로부터 다른 비트코인의 주소로 거래 하나의 비트코인 주소로부터 다른 하나의 비트코인의 주소로 거래 하나의 비트코인 주소로부터 다른 다수의 비트코인 주소로 거래 기록 개수에 대한 제한 없음 수령자가 늘 수록 더 많은 저장 공간 필요 하나의 거래의 최소 크기 166Byte -\u003e 실제 거래내역 크기는 300 Byte 초과 ( 거스름돈, 다수의 수령자) 이론적으로 5,000 ~ 6,000 개의 거래내역 포함 -\u003e 실제 거래내역은 3,000 개 미만 ","date":"2022-03-14","objectID":"/archives/til/20220314/:2:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 블록헤더의 구성요소 ","date":"2022-03-14","objectID":"/archives/til/20220314/:3:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록헤더의 구성 요소 버전 정보 - 4byte 이전 블록 해시 값 - 32 byte 머클트리 루트 - 32 byte 타임스탬프 - 4 byte 타깃 난이도 - 4 byte 난스 - 4 byte 버전 정보 (4 Byte) 블록을 만들 당시의 소프트웨어 버전을 의미 =법령정보 -\u003e 버전에 따라 서로 다른 규칙 적용 -\u003e 블록 무결성의 확인 부분이 상이 시간의 흐름에 따른 법의 변화 -\u003e 소프트웨어 버전에 따라 블록 생성의 규칙이 변화 어떤 규칙을 사용해 블록을 검증할지 알려주는 값 이전 블록 해시 값 (32Byte) 현재의 블록에 이전 블록의 데이터 값이 포함 SHA256 32 Byte 해시 값 일련의 과정을 통해 이전 블록에서 해시 값을 생성 생성된 해시 값이 현재 블록에도 기록 모든 블록은 자기의 특정 값을 가지며 다음 블록에 전달 해시 값 기록의 이유 이전 기록과 비교로 변조 여부 확인 블록의 어떤 값이 변경되었음을 손쉽게 탐지 머클트리 루트 (32 Byte) 블록 데이터에 담겨 있는 모든 트랜잭션의 요약 정보 블록 데이터에 모든 트랜잭션 -\u003e 하나의 해시 값으로 요약 1 MB에 달하는 3,000 개의 트랜잭션 요약 블록 데이터에 모든 트랜잭션 -\u003e 단 32 Byte의 해시 값 -\u003e 머클트리 루트에 데이터로 저장 타임스탬프 (4 Byte) 블록이 만들어진 시간 기록 블록의 생성 시간을 파악 가능 타깃 난이도 비트 (4 Byte) 블록 생성의 난이도에 대한 값을 저장하는 비트 일련의 공식을 통해 32 Byte 로 변환 넌스 (Nonce, 4byte) 해시 퍼즐의 정답 해시 퍼즐을 가장 먼저 해결한 노드가 요청서를 기록 해시 퍼즐의 정답 -\u003e 넌스를 찾는 과정 모든 가능한 조합을 통한 무차별 대입법 무수한 계산을 통해 정답을 찾은 정수 ","date":"2022-03-14","objectID":"/archives/til/20220314/:3:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 마다 서로 다른 정의 가능 비트코인 헤더의 크기 헤더의 크기는 80 Byte 고정 6개의 필드 이더리움 헤더 최소 508 Byte로 가변적 15개의 필드 ","date":"2022-03-14","objectID":"/archives/til/20220314/:3:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록헤더 실제 블록에 담겨 있는 모든 데이터에 대한 정밀한 요약 블록 데이터의 기능에 따라서 서로 다르게 정의 블록체인 원리 (3) - 작업증명 : 해시 퍼즐과 난이도 ","date":"2022-03-14","objectID":"/archives/til/20220314/:3:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 블록만들기와 해시 퍼즐 ","date":"2022-03-14","objectID":"/archives/til/20220314/:4:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시 퍼즐 무차별 대입법 -\u003e 특정 값 -\u003e 무한 반복 산수 문제 해시 퍼즐을 푸는 수학적 공식은 없음 무수히 반복되는 산수 문제 해결 해시를 통해 얻게 되는 고유한 값 32 Byte 값 -\u003e SHA-256 - 유효한 블록의 해시값을 찾을 때까지 무한 반복 해시 퍼즐 정답 = 블록 고유 해시값 제네시스 블록 해시값 = 2의 32승 번 값 계산 -\u003e 약 10분동안 계산 ","date":"2022-03-14","objectID":"/archives/til/20220314/:4:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시 퍼즐 풀이 블록 헤더의 넌스값을 0 으로 설정 비트코인 해시 함수를 연속 2번 해싱 (SHA-256) : 임의의 32 Byte 값 블록 전체를 해시함수를 연속 두 번 적용하여 나온 해시값 H와 주어진 목표값 T 값을 비교 주어진 값보다 더 작거나 갖지 않다 -\u003e 넌스 1증가 (1 ~ 32 까지 증가) -\u003e 임의의 32 Byte 값 생성 반복 판단박스 목표 값보다 T보다 작아질 때까지 반복 ","date":"2022-03-14","objectID":"/archives/til/20220314/:4:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"넌스값 입력의 사소한 변화 32 Byte 충분히 작은 값이 나올 때까지 반복 T(목표값) -\u003e 목표값이 작을 수록 만족 힘듦 ","date":"2022-03-14","objectID":"/archives/til/20220314/:4:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"작업증명 퍼즐을 이용해서 의도적으로 막대한 에너지를 소모하게 만든 방식 스팸 방지를 위해 개발 의도적으로 막대한 에너지를 소모하게 하여 그 일을 억제 최초 기록 및 변경에 막대한 에너지 소모 -\u003e 반대 급부의 경제적 이득이 없으면 변경 이유 없다 최초의 기록된 노드의 검증 -\u003e 합당한 이유 없다면 정상적 기록을 통한 보상금 -\u003e 합리적 선택 스팸 방지 네트워크 과부하 문제 어떤 작업을 반드시 해야만 되도록 부과 -\u003e 스팸 억제 ","date":"2022-03-14","objectID":"/archives/til/20220314/:4:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 해시 퍼즐과 난이도 ","date":"2022-03-14","objectID":"/archives/til/20220314/:5:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시 퍼즐과 난이도 목표값이 작아지면 해시퍼즐을 찾을 확률이 줄어듬 목표값을 성취하려면 과정 반복 필요 ","date":"2022-03-14","objectID":"/archives/til/20220314/:5:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시 퍼즐의 비유 더 작은 해시 값 찾기 = 목표 값 찾기 해시 함수를 통해 얻는 값 32 byte로 이루어진 값이 어떤 특정 패턴을 이룰 수 있는 방법 -\u003e 0000 (0), 1111 (2의32승-1) 목표값은 작아질 수록 ㅎ시행횟수 증가 -\u003e 오래시간 소요 목표값을 조정하여 목표값에 맞는 해시값을 찾는데 필요한 계산횟수 횟수는 오래 걸리지만 시간은 10분 소요 -\u003e 과거에 비해 빠른 컴퓨터 난이도 조절 이유 컴퓨터가 발달 하여도 10분에 하나씩 블록 생성 목표값과 해시값의 관계 1,209,600초 -\u003e 10분이하로 블록 생성 늦은 시간 -\u003e 하나의 블록생성시 10분 이상 걸림 원래 소요시간보다 적을 겨우 -\u003e 난이도 상승 원래 소요시간보다 낮음 -\u003e 난이도 하향 ","date":"2022-03-14","objectID":"/archives/til/20220314/:5:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"목표값 ","date":"2022-03-14","objectID":"/archives/til/20220314/:5:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"무어의 법칙 반도체의 발달 속도 - 18 개월마다 반도체의 직접도가 두배가 되어 18개월마다 컴퓨터 속도 2배 항샹 지속적으로 난이도조절 2009 ~ 2017 63배 무어의 법칙에 따른 자연적인 증가 막대한 하드웨어의 투자 + 전용 기계 -\u003e 인위적 수치 난이도 증가는 블록체인의 영속성에 영향 ","date":"2022-03-14","objectID":"/archives/til/20220314/:5:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220314","uri":"/archives/til/20220314/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인과 중앙집중 시스템과의 차이점 (2) - 일처리 방식 ","date":"2022-03-10","objectID":"/archives/til/20220310/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 브로드캐스팅 Broadcasting 네트워크에 참여한 모든 노드에게 모든 데이터를 전달하는 방식 중앙서버 방식 : 중앙 서버와 특정 노드 사이에만 데이터 전달이 일어남 블록체인 : 시간이 흐림에 따라 데이터가 모든 노드에 전달 블록체인에서는 모든 데이터를 브로드캐스팅을 통해 전달 Gossip protocol 귓속말을 하듯 피어를 통해 데이터를 전달한다. 모든 데이터 -\u003e 모든 노드 -\u003e 블록체인에 참여한 노드는 동일한 데이터를 가지고 있다. 블록체인의 모든 전송 방식은 브로드 캐스팅에 의존한다. 브로드캐스팅으로 인한 블록체인의 특성 1. 저장된 모든 내용은 비밀로 할 수 없다 모든 노드의 모든 데이터 공유 -\u003e 데이터 자체의 보안 방법 없음 개인정보가 들어가 있는 데이터는 절대 사용하면 안됨 2. 브로드캐스팅 되는 시간은 노드 별로 상이할 수 있다. 노드마다 데이터를 처리하는 컴퓨터 능력과 네트워크 용량 차이 같은 데이터를 가지는 시간은 노드 별로 상이 특정 순간의 노드 -\u003e 서로 다른 데이터를 가짐 -\u003e 시간이 흐름에 따라 궁극적으로 모든 노드가 동일한 데이터를 갖게 된다. 3. 시간이 흐르면, 모든 노드는 동일한 데이터를 전달 받는다. 중앙화 시스템과 블록체인 시스템의 차이 중앙화 시스템 : 특정 메세지를 특정 노드와 중앙서버로만 통신한다. 블록체인시스템: 모든 메세지 모든 노드에 브로드 캐스팅 한다. ","date":"2022-03-10","objectID":"/archives/til/20220310/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 거래내역의 작성 및 전송 중앙화 시스템 -\u003e 웹서버 이용 블록체인 시스템 -\u003e 지갑 소프트웨어 이용 ","date":"2022-03-10","objectID":"/archives/til/20220310/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"중앙화 시스템과 블록체인 시스템의 기본적인 동작 방식 중앙화 시스템의 대표적인 은행의 경우 계좌번호를 이용하여 이체 금액 입력 후 전송한다. 블록체인의 경우에도 비트코인 주소를 통해 암호화폐를 전송한다. -\u003e 주소가 복잡한 것 이외에 크게 다르지 않음 중앙화 시스템의 경우 은행이 모든 이체를 처리하고 처리 시간을 예측 할 수 있다. 블록체인 시스템은 요청 할 때마다 처리하는 사람이 달라지며 수수료에 따라 처리 시간도 달라진다. ","date":"2022-03-10","objectID":"/archives/til/20220310/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"이체의 처리 중앙화 시스템 : 중앙 서버가 모든 이체 처리 블록체인 : 브로드캐스팅 후 매번 다른 노드가 처리 브로드캐스팅 이후의 이체 처리 단계는? 트랜잭션 작성 Peer전파를 통한 브로드 캐스팅 각 노드 대기열에서 대기 브로드 캐스팅 특정 순간의 노드 노드마다 데이터의 순서가 다를 수 있다. 요청서 마다 전달 받는 순서는 다르나 -\u003e 시간이 흐름에 따라 모든 노드는 모든 데이터를 수령하게 된다 메세지를 누가 처리할 것인지 정하는 규칙이 필요함 브로드캐스팅 데이터를 누가 처리할 것인지 규칙이 필요하다. 은행 : 계좌이체 -\u003e 요청한 계좌이체 -\u003e 장부에 기록 블록체인 : 계좌이체 -\u003e 계좌이체를 요청한 메세지 -\u003e 누군가 기록 ","date":"2022-03-10","objectID":"/archives/til/20220310/:2:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 리더의 선출과 검증 ","date":"2022-03-10","objectID":"/archives/til/20220310/:3:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"리더 선출 거래 내역을 적을 수 있는 권한을 가진 사람을 선출하는 것 해시 퍼즐을 가장 먼저 해결한 노드가 요청서를 기록함 해시 퍼즐 많은 시간과 에너지를 소모하여 겨우 해결할 수 있는 문제 계산의 복잡도 -\u003e 무차별 대입법에 의한 모든 경우 순차적 계산 -\u003e 계산을 가장 먼저 한 특정 노드에게 기록 권한을 줌 리더 선출 시 중요한 부분 문제 해결을 가장 먼저 해결 비트코인과 이더리움 노드 -\u003e 해시 퍼즐을 풀기 위해 컴퓨팅 자원 소모 비트코인 해시퍼즐 10분 정도 소요 블록체인 시스템의 문제 발생 중앙화시스템의 경우 기록을 기록한 은행을 신뢰함 블록체인 -\u003e 해시퍼즐을 통해 메세지 기록할 수 있는 전권 획득-\u003e 그러나 특정 노드에 기록 후 검증하는 절차 필요함. 작업증명 모든 노드가 블록에 기록된 데이터를 검증에 참여할 수 있다. 검증시에는 어떠한 자격 조건도 필요 없으며 원할 때 누구든지 시스템에 참여하여 기록 전체에 대해 검증 가능하다. 작업증명을 통해 블록체인 시스템의 투명성을 확보할 수 있다. 블록 검증 이후 두 가지 상황 전달받은 블록 에 대한 동의 -\u003e 블록에 대한 기각 -\u003e 블록에 대해 동의하지 않으면 블록을 폐기 비트코인 : 평균 10분에 한번 씩 이더리움 : 평균 15초에 한번 씩 합의 네트워크의 모든 노드가 동일한 블록에 대해 동의함 모든 노드의 저장된 데이터가 일치하게 됨 매번 리더 선출 -\u003e 하나의 블록에 대한 기록을 수행한 노드는 단 하나 각각의 블록 -\u003e 리더로 선출된 노드 = 중앙 서버의 역할 수행 블록체인에서 하나의 진실을 유지하는 비결 각각의 블록 단위로 리더 선출 리더가 중앙 서버의 역할 수행 =\u003e 중앙 서버 없이도 거래할 수있는 블록체인 시스템 탄생 블록체인 원리(1) - 해시 함수와 암호화 기법 ","date":"2022-03-10","objectID":"/archives/til/20220310/:3:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 해시 함수 ","date":"2022-03-10","objectID":"/archives/til/20220310/:4:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"해시함수 입력 길이와 상관없이 항상 일정한 길이의 출력을 나타내는 함수 충돌회피 기능 : 입력이 달라지면 출력이 달라진다. 해시함수 성질 임의의 입력에 일정한 길이만 출력한다. 입력이 변경되면 출력이 변경되는 성질 -\u003e 입력의 사소한 변화도 감지할 수 있다. 출력값으로 입력값 유추가 불가능 하다. 충돌회피기능의 해시 함수 입력의 사소한 변화 -\u003e 완전히 다른 출력 산출 문서의 변경 여부를 해시 값 만으로 감지 ","date":"2022-03-10","objectID":"/archives/til/20220310/:4:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 비대칭 암호화 기법 ","date":"2022-03-10","objectID":"/archives/til/20220310/:5:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"암호화 함수 특정 입력 메세지를 알아볼 수 없는 출력 메세지로 변경 문장 내용의 보호를 목적 암호를 원래 문장으로 만드는 방법을 모른다면 내용 추측이 불가능 메세지를 복원할 수 있는 방법이 존재 암호화 \u003c-\u003e 복호화 ","date":"2022-03-10","objectID":"/archives/til/20220310/:5:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"암호화 함수 종류 해시함수 -\u003e 단방향 함수 암호화 함수는 복호화 과정을 통해 암호화 된 원래 문장을 확인할 수 있다.-\u003e 암호화/복호화 시 특정 데이터를 이용 ","date":"2022-03-10","objectID":"/archives/til/20220310/:5:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"대칭형, 비대칭형 암호화 대칭형 암호화 기법 -\u003e 암호화/복호화 키가 동일 비대칭형 암호화 기법 -\u003e 암호화/복호화 키가 다름 공인인증서 공인인증서의 이용의 경우 비대칭 암호화 기법 디지털 서명 기법 ","date":"2022-03-10","objectID":"/archives/til/20220310/:5:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"비대칭 암호화 기법 개인키 : 자신만 간직하는 비밀키 공개키 : 모든 사람이 공유 비밀키로 암호화 진행 시 공개키로만 복호화 가능, 공개키로 암호화 시 비밀키로만 복호화 가능 블록체인에서 문서의 무결성 기여 디지털 서명과도 연관이 있다 -\u003e 개인키를 이용하여 특정 문서의 제작자임을 증명하는 방식 ","date":"2022-03-10","objectID":"/archives/til/20220310/:5:4","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 블록체인에서 해시 함수와 암호화 기법의 이용 ","date":"2022-03-10","objectID":"/archives/til/20220310/:6:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인에서 해시 함수와 암호화 기법 이용 해시함수 : 입력 메세지의 변경 여부 탐지 비대칭 암호화 기법 : 디지털 서명 수행 -\u003e 비트코인 블록체인 : 거래내역에 대한 특정 해시 값을 기록 -\u003e 해시 값의 변경은 입력 메세지의 변조를 의미 ","date":"2022-03-10","objectID":"/archives/til/20220310/:6:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"거래내역 브로드 캐스팅 A의 거래내역을 해시값을 R이 기록한 해시값과 비교 검증 비트코인 블록체인 -\u003e 거의 모든 기록을 해시 함수로 기록 -\u003e 32바이트로 기록 값을 항시 검증 -\u003e 기록의 조작 여부를 판별 블록체인에서 비대칭 암호화 기법 비트코인 수령자 보호 거래내역의 조작 방지 공개키를 이용하여 수령자 보호 비트코인 주소를 통해 주고받음 브로드캐스팅을 통해 모든 노드에게 노출 비트코인 주소 공개키에 대한 정보 공개키로 잠긴 정보는 한 쌍이 되는 개인키를 가진 사람만이 열람 가능 공개키를 이용하여 개인키를 갖은 수령자만 거래내역을 복호화 가능 A는 B에게 비트코인을 주었다는 사실을 기록 -\u003e A의 개인키 -\u003e A의 공개키로 이 사실이 복호화 공개키로 수령자만이 비트코인을 받을 수있도록 보호 개인키를 이용하여 실제 거래자를 증명 -\u003e 비대칭 암호화 기법 ","date":"2022-03-10","objectID":"/archives/til/20220310/:6:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220310","uri":"/archives/til/20220310/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인과 중앙집중 시스템과의 차이점 (1) ","date":"2022-03-08","objectID":"/archives/til/20220309/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220308","uri":"/archives/til/20220309/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 중앙화 시스템과 분산 시스템 ","date":"2022-03-08","objectID":"/archives/til/20220309/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220308","uri":"/archives/til/20220309/"},{"categories":["TIL \u0026 Issue Note"],"content":"분산 시스템의 정의 각각의 꼭지점 = 하나의 서버 모드 꼭짓점 = 노드 직접적으로 연결된 노드 = 피어 ![[Pasted image 20220308110403.png]] ","date":"2022-03-08","objectID":"/archives/til/20220309/:1:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220308","uri":"/archives/til/20220309/"},{"categories":["TIL \u0026 Issue Note"],"content":"중앙집중 시스템과 분산시스템 중앙집중 시스템 대표적인 예시 은행 -\u003e 은행이 운영하는 웹 서버에 연결 은행 이용자가 모두 동일한 서버를 이용 사용자의 수와 상관없이 사용자가 사용하는 시스템은 동일 특징 설계와 운영이 간편한 중앙집중 시스템 -\u003e 기능 추가 시 별도의 절차 없이 모든 사용자에게 적용. 서버에 이상이 생길 경우 모든 사용자가 이용 불가 분산 시스템 여러 개의 서버가 일을 나누어 처리 여러 서버가 일을 분담하는 분산 시스템 분산시스템의 장점 일의 효울성이 높다. 처리 속도가 신속함 중앙시스템이 고장이 나면 모든 서비스가 중단되지만 분산 시스템은 그렇지 않다. 중앙시스템과 비교 중앙시스템의 경우 하나의 서버 공격으로 자원 탈취나 서비스 마비 가능성이 높다 -\u003e 외부 공격에 매우 취약 여러 개의 서버가 마비 된 서버를 대신하여 서비스를 처리 -\u003e 일이 많아 분산될 수록 해커의 공격으로 안전 분산시스템의 단점 단일 서버에 비해 구성 비용이 상당하다. 특정 순간에 데이터 간의 내용이 상이하다. 여러 개의 서버의 저장 데이터를 동기화 하는 과정이 필요함 -\u003e 상이한 내용이 같아지도록 데이터를 복사하는 과정 필요 중앙집중 시스템 vs 분산시스템 장/단점에 따라 구성을 결정 경우에 따라서는 혼합할 수 있다. -\u003e 특정한 기능은 중앙서버에서 처리하고 나머지는 분산 서비스로 처리 = 하이브리드시스템 ","date":"2022-03-08","objectID":"/archives/til/20220309/:1:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220308","uri":"/archives/til/20220309/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 분산 시스템과 블록체인 시스템 ","date":"2022-03-08","objectID":"/archives/til/20220309/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220308","uri":"/archives/til/20220309/"},{"categories":["TIL \u0026 Issue Note"],"content":"P2P(Peer-to-Peer) 대표적인 것 -\u003e 파일이나 노래 파일 공유 네트워크의 모든 노드 서버의 역할 요청자 역할 -\u003e 모든 노드가 동등하게 역할을 수행한다. ","date":"2022-03-08","objectID":"/archives/til/20220309/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220308","uri":"/archives/til/20220309/"},{"categories":["TIL \u0026 Issue Note"],"content":"분산서버로써 블록체인 시스템의 특징 모든 노드가 공유해서 들여다볼 수 있도록 설계되어 있다. 블록체인 시스템은 기본적으로 반복적으로 수행 -\u003e 반복 검증으로 정확성, 투명성 획득 데이터 자체는 전혀 보호되지 않고 모든 노드가 공유하는 구조 데이터 위조/변조/서비스 무력화에 안전 블록체인을 이용하는 것은 효율성 저하 =\u003e 시스템의 목적이 상이 블록체인 시스템은 기본적으로 반복적으로 수행 -\u003e 반복 검증으로 정확성, 투명성 획득 데이터 변경 시 모든 노드가 검증 효율성 X 투명성, 안전성 블록체인 안전의 양면성 데이터 자체 보호에 무력 다만 데이터의 변형과 서비스 무력화에 저항 ","date":"2022-03-08","objectID":"/archives/til/20220309/:2:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220308","uri":"/archives/til/20220309/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 시스템의 잘못된 상식 분산 시스템을 이용하므로 효율적이다 ? 현재의 블록체인 시스템으로 효율성을 논하는 것은 불가능 -\u003e 중앙화 시스템과 분산 시스템의 차이 -\u003e 일의 분산을 통해서 효율성 확보 -\u003e 일반적 분산 시스템과 블록체인 시스템 차이 -\u003e 일의 중복을 통해서 투명성과 기록 불변성을 확보 ","date":"2022-03-08","objectID":"/archives/til/20220309/:2:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220308","uri":"/archives/til/20220309/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 블록체인의 특성 종합 블록체인 시스템 모든 노드가 동등함을 의미 -\u003e 같은 역할과 의무가 부여됨 해커의 목적 분산 최근 블록체인은 특정 노드가 특정 역할을 수행 속도 등의 성능 향상 -\u003e 안전성의 상대적 취약 비트코인 블록체인 정의 -\u003e 모든 노드는 상호 동등 같은 역할과 의무가 부여 -\u003e 각 노드가 모든 역할을 반복하여 비효율적 시스템의 변경에는 항상 장/단점이 존재 모든 노드가 동등하여 해커로부터 안전하나 -\u003e 모든 일을 반복함으로 비효율적인 시스템 현업에서 원하는 투명성 정도 희생해도 되는 효율성 정도-\u003e 특정 노드의 역할을 결정 Denial of Service Dos 공격으로부터 가장 안전한 시스템 블록체인 시스템은 효율을 위한 시스템. ","date":"2022-03-08","objectID":"/archives/til/20220309/:3:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220308","uri":"/archives/til/20220309/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인과 중앙집중 시스템과의 차이점 (1) ","date":"2022-03-07","objectID":"/archives/til/20220307/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220307","uri":"/archives/til/20220307/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 중앙화 시스템과 분산 시스템 ","date":"2022-03-07","objectID":"/archives/til/20220307/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220307","uri":"/archives/til/20220307/"},{"categories":["TIL \u0026 Issue Note"],"content":"분산 시스템의 정의 각각의 꼭지점 = 하나의 서버 모드 꼭짓점 = 노드 직접적으로 연결된 노드 = 피어 ","date":"2022-03-07","objectID":"/archives/til/20220307/:1:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220307","uri":"/archives/til/20220307/"},{"categories":["TIL \u0026 Issue Note"],"content":"중앙집중 시스템과 분산시스템 중앙집중 시스템 대표적인 예시 은행 -\u003e 은행이 운영하는 웹 서버에 연결 은행 이용자가 모두 동일한 서버를 이용 사용자의 수와 상관없이 사용자가 사용하는 시스템은 동일 특징 설계와 운영이 간편한 중앙집중 시스템 -\u003e 기능 추가 시 별도의 절차 없이 모든 사용자에게 적용. 서버에 이상이 생길 경우 모든 사용자가 이용 불가 분산 시스템 여러 개의 서버가 일을 나누어 처리 여러 서버가 일을 분담하는 분산 시스템 분산시스템의 장점 일의 효울성이 높다. 처리 속도가 신속함 중앙시스템이 고장이 나면 모든 서비스가 중단되지만 분산 시스템은 그렇지 않다. 중앙시스템과 비교 중앙시스템의 경우 하나의 서버 공격으로 자원 탈취나 서비스 마비 가능성이 높다 -\u003e 외부 공격에 매우 취약 여러 개의 서버가 마비 된 서버를 대신하여 서비스를 처리 -\u003e 일이 많아 분산될 수록 해커의 공격으로 안전 분산시스템의 단점 단일 서버에 비해 구성 비용이 상당하다. 특정 순간에 데이터 간의 내용이 상이하다. 여러 개의 서버의 저장 데이터를 동기화 하는 과정이 필요함 -\u003e 상이한 내용이 같아지도록 데이터를 복사하는 과정 필요 중앙집중 시스템 vs 분산시스템 장/단점에 따라 구성을 결정 경우에 따라서는 혼합할 수 있다. -\u003e 특정한 기능은 중앙서버에서 처리하고 나머지는 분산 서비스로 처리 = 하이브리드시스템 ","date":"2022-03-07","objectID":"/archives/til/20220307/:1:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220307","uri":"/archives/til/20220307/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 분산 시스템과 블록체인 시스템 ","date":"2022-03-07","objectID":"/archives/til/20220307/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220307","uri":"/archives/til/20220307/"},{"categories":["TIL \u0026 Issue Note"],"content":"P2P(Peer-to-Peer) 대표적인 것 -\u003e 파일이나 노래 파일 공유 네트워크의 모든 노드 서버의 역할 요청자 역할 -\u003e 모든 노드가 동등하게 역할을 수행한다. ","date":"2022-03-07","objectID":"/archives/til/20220307/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220307","uri":"/archives/til/20220307/"},{"categories":["TIL \u0026 Issue Note"],"content":"분산서버로써 블록체인 시스템의 특징 모든 노드가 공유해서 들여다볼 수 있도록 설계되어 있다. 블록체인 시스템은 기본적으로 반복적으로 수행 -\u003e 반복 검증으로 정확성, 투명성 획득 데이터 자체는 전혀 보호되지 않고 모든 노드가 공유하는 구조 데이터 위조/변조/서비스 무력화에 안전 블록체인을 이용하는 것은 효율성 저하 =\u003e 시스템의 목적이 상이 블록체인 시스템은 기본적으로 반복적으로 수행 -\u003e 반복 검증으로 정확성, 투명성 획득 데이터 변경 시 모든 노드가 검증 효율성 X 투명성, 안전성 블록체인 안전의 양면성 데이터 자체 보호에 무력 다만 데이터의 변형과 서비스 무력화에 저항 ","date":"2022-03-07","objectID":"/archives/til/20220307/:2:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220307","uri":"/archives/til/20220307/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 시스템의 잘못된 상식 분산 시스템을 이용하므로 효율적이다 ? 현재의 블록체인 시스템으로 효율성을 논하는 것은 불가능 -\u003e 중앙화 시스템과 분산 시스템의 차이 -\u003e 일의 분산을 통해서 효율성 확보 -\u003e 일반적 분산 시스템과 블록체인 시스템 차이 -\u003e 일의 중복을 통해서 투명성과 기록 불변성을 확보 ","date":"2022-03-07","objectID":"/archives/til/20220307/:2:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220307","uri":"/archives/til/20220307/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 블록체인의 특성 종합 블록체인 시스템 모든 노드가 동등함을 의미 -\u003e 같은 역할과 의무가 부여됨 해커의 목적 분산 최근 블록체인은 특정 노드가 특정 역할을 수행 속도 등의 성능 향상 -\u003e 안전성의 상대적 취약 비트코인 블록체인 정의 -\u003e 모든 노드는 상호 동등 같은 역할과 의무가 부여 -\u003e 각 노드가 모든 역할을 반복하여 비효율적 시스템의 변경에는 항상 장/단점이 존재 모든 노드가 동등하여 해커로부터 안전하나 -\u003e 모든 일을 반복함으로 비효율적인 시스템 현업에서 원하는 투명성 정도 희생해도 되는 효율성 정도-\u003e 특정 노드의 역할을 결정 Denial of Service Dos 공격으로부터 가장 안전한 시스템 블록체인 시스템은 효율을 위한 시스템. ","date":"2022-03-07","objectID":"/archives/til/20220307/:3:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220307","uri":"/archives/til/20220307/"},{"categories":["TIL \u0026 Issue Note"],"content":"변수 변수를 만들고 초기화 하는 코드는 다음과 같다. // 변수를 생성하고 초기화 한다. var name = 'Bob'; 변수는 참조를 저장한다. name으로 불리는 변수는 “Bob\"이라는 문자열을 갖는 String 객체의 참조를 포함한다. name의 변수 타입은 String으로 유추할 수 있지만 해당 유형을 명시적으로 변경할 수 있다. 객체가 단일 타입으로 제한되지 않은 경우 Object 타입(필요하면 dynamic)으로 지정할 수 있다. Object name = 'Bob'; 유추가능한 명시적인 타입으로 지정할 수도 있다. String name = 'Bob'; ","date":"2022-03-05","objectID":"/archives/til/20220305/:1:0","tags":["TIL","dart"],"title":"[TIL \u0026 Issue Note] 20220305","uri":"/archives/til/20220305/"},{"categories":["TIL \u0026 Issue Note"],"content":"기본값 nullable 타입의 초기값은 null이다. (null-safety를 선택하지 않으면 모든 변수는 nullable 타입) 숫자 타입도 초기값은 null이다. (숫자 타입도 다트에서는 Object이기 때문) int? lineCount; assert(lineCount == null); null 안전을 활성화 한 경우 null을 허용하지 않는 변수 값을 사용하기 전에 초기화해야 한다. int lineCount = 0; 선언된 로컬 변수를 초기화 할 필요는 없지만 사용하기 전에 값을 할당해야 한다. 다음 코드는 Dart가 print()를 전달할 때 null이 아닌 lineCount를 감지하기 때문에 유효하다. int lineCount; if (weLikeToCount) { lineCount = countLines(); } else { lineCount = 0; } print(lineCount); 최상위 및 클래스 변수는 느리게 초기화 되며, 초기화 코드는 변수가 처음 사용될 때 실행된다. ","date":"2022-03-05","objectID":"/archives/til/20220305/:1:1","tags":["TIL","dart"],"title":"[TIL \u0026 Issue Note] 20220305","uri":"/archives/til/20220305/"},{"categories":["TIL \u0026 Issue Note"],"content":"Late 변수 다트 2.12에서 late 변수가 추가되었고 아래 두 가지 경우 사용한다. non-nullable 변수를 선언할 때 초기화하지 않고 선언 후에 초기화 할 때 게으른 초기화lazily initializing를 위해서 다트의 제어 흐름 분석은 non-nullable 변수가 사용하기 전에 null이 아닌 값으로 설정된 경우를 탐지할 수 있지만 가끔 분석에 실패한다. 실패하는 두가지 일반적인 경우는 최상위 변수와 인스턴스 변수이다. 다트에서는 변수 값의 설정 여부를 확인할 수 없기 때문에 에러가 발생한다. 변수를 사용하기 전에 값을 설정했지만 다트에서 동의하지 않는 경우 변수에 late 지시자를 통해 다음과 같이 오류를 수정할 수 있다. late String description; void main() { description = 'Feijoada!'; print(description); } 변수에 late를 선언하면 변수가 처음 사용될 때 초기화가 실행된다. 이렇게 게으른 초기화는 다음과 같은 경우에 유용하다. 변수가 필요하지 않을 수도 있으며 초기화하는데는 많은 비용이 든다. 인스턴스 변수를 초기화 하거나 또는 인스턴스 변수가 this에 접근해야 할때 아래 예제에서 temperature 변수는 사용되지 않을 수 있다. 아래처럼 선언하면 temperature라는 변수가 사용될 때 초기화 된다. // This is the program's only call to _readThermometer(). late String temperature = _readThermometer(); // Lazily initialized. ","date":"2022-03-05","objectID":"/archives/til/20220305/:1:2","tags":["TIL","dart"],"title":"[TIL \u0026 Issue Note] 20220305","uri":"/archives/til/20220305/"},{"categories":["TIL \u0026 Issue Note"],"content":"Final과 const 변수를 변경할 생각이 없는 경우 var 대신 final과 const를 사용한다. final 변수는 한번만 값을 설정 할 수 있다. const 변수는 컴파일 타임 상수로 컴파일 하는 동안에 값이 정해진다. const 변수는 암시적으로 final 이다.(?) 아래는 final 변수의 예제이다. final 변수는 값을 변경 할 수 없다. final name = 'Bob'; // Without a type annotation final String nickname = 'Bobby'; name = 'Alice'; // Error: a final variable can only be set once. const 변수는 컴파일 타임 상수(compile-time constants) 이다. 컴파일 시에 값이 정해진다. const 변수가 클래스 레벨에 있는 경우 static const 라고 한다. 변수를 선언하는 곳에서 숫자나 문자열 리터럴과 같은 상수 값이나 산술 연산에 대한 결과 값을 설정한다. const bar = 1000000; // Unit of pressure (dynes/cm2) const double atm = 1.01325 * bar; // Standard atmosphere const 키워드는 상수 변수를 선언하고 작성할 뿐만 아니라 상수 값을 생성하는 생성자를 선언하는 에도 사용할 수 있다. 또한 모든 변수는 상수 값을 가질 수 있다. var foo = const []; final bar = const []; const baz = []; // `const []` 동등 위의 예제에서 baz와 같이 const 선언 초기화 표현식에 const를 생략할 수 있다. 자세한 내용은 DON’T use const redundantly 참고한다. non-final, non-const 변수의 값이라도 const 값을 사용하는 동안 값을 변경 할 수 있다. foo = [1, 2, 3]; // Was const [] 아래 const 변수는 값을 바꿀 수 없다. baz = [42]; // Error: Constant variables can't be assigned a value. 타입 검사와 캐스트 (is와 as)와 collection if, 스프레드 연산자(… and …?)를 사용하여 상수를 정의할 수 있다. const Object i = 3; // Where i is a const Object with an int value... const list = [i as int]; // Use a typecast. const map = { if (i is int) i: 'int' } // Use is and collection if. const set = { if (list is List\u003cint\u003e) ...list} // ...and a spread. ","date":"2022-03-05","objectID":"/archives/til/20220305/:1:3","tags":["TIL","dart"],"title":"[TIL \u0026 Issue Note] 20220305","uri":"/archives/til/20220305/"},{"categories":["TIL \u0026 Issue Note"],"content":"Built-in types 다트 언어의 내장형 타입이다. Numbers (int, double) Strings (String) Booleans (bool) Lists (List, also known as arrays) Sets (Set) Maps (Map) Runes (Runes; often replaced by the characters API) Symbols (Symbol) The value null (Null) 이러한 내장타입은 리터럴을 사용하여 Object로 만들 수 있는 기능을 포함한다. 예를들어 this is a string 은 문자열 리터럴이며 true는 boolean 리터럴이다. 다트의 모든 변수는 Object를 참조하기 때문에 생성자를 사용하여 변수를 초기화 할 수 있다. 내장형 타입 중 일부는 자체 생성자가 있다. 예를들면, Map() 생성자를 사용하여 Map 타입을 작성할 수 있다. 일부 타입을 또한 다트 언어에서 특별한 역할을 가지고 있다. Object: Null을 제외한 모든 다트 클래스 Future and Stream: 비동기 지원 Iterable: for-in loops and in synchronous generator functions. Never: 표현식이 성공적으로 계산을 마칠 수 없음을 나타낸다. 항상 예외를 발생시키는 함수에 가장 많이 사용 dynamic: 정적 검사를 실행 중지함을 나타낸다. 일반적으로 Object 또는 Object? 대신 사용한다. void: 값이 사용되지 않음을 나타낸다. 반환 유형으로 자주 사용된다. ","date":"2022-03-05","objectID":"/archives/til/20220305/:1:4","tags":["TIL","dart"],"title":"[TIL \u0026 Issue Note] 20220305","uri":"/archives/til/20220305/"},{"categories":["TIL \u0026 Issue Note"],"content":"Important concepts 변수에 넣을 수 있는 것은 Object이고, 모든 Object는 Class의 인스턴스이다. numbers, functions, null 조차 객체이다. 모든 객체는 Object 클래스를 상속한다. Dart가 강타입 언어이긴하나, 타입을 추론 할 수 있기 때문에 명시는 선택사항이다. null-safety를 활성화 하면, 특별히 선언하지 않으면 변수에는 null을 포함할 수 없다. nullable한 변수는 타입 뒤에 ? 붙인다. int?는 변수가 integer일 수도 있고 null일 수도 있다. Dart에서 null을 평가하는 것을 동의하지 않는다면 !를 붙여 null이 아님을 명시할 수 있다.(?) 모든 타입을 허용하고 싶을 땐 Object? (null-safety 가 활성화) 또는 Dynamic Type으로 런타임 시 타입을 체크할 수 있다. List\u003cint\u003e, List\u003cObject\u003e와 같은 제네릭 타입을 지원한다. main() 함수와 같은 최상위 함수, class 또는 object에 연결된 함수(각각 정적 및 인스턴스 메서드)를 지원한다. 또한 함수내에 함수 (중첩 혹은 지역 함수)를 만들 수 있다. 마찬가지로, Dart는 최상위 변수와 class 또는 객체에 연결된 변수(정적, 인스턴스 변수)를 지원한다. 인스턴스 변수는 fields 또는 properties 라고도 한다. 자바와는 달리 Dart는 접근 제어자가 없다. 식별자 이름이 _로 시작하면 private 나타낸다. 식별자는 _로 시작할 수 있고 그 뒤에 숫자와 문자를 조합해서 사용 가능하다. Dart는 런타임 값을 갖는 표현식expressions과 그렇지 않은 구문statement 두가지가 있다. 조건부 표현식 condition? expr1 : expr2 는 expr1 또는 expr2 의 값을 갖는다. if-else 구문은 값을 갖지 않는다. 구문은 하나 혹은 많은 표현식을 포함하지만, 표현식은 구문을 직접적으로 포함할 수 없다. Dart Tool은 warnings와 errors를 보고 할 수 있다. warnings 코드가 작동하지 않을 수 있다는 표시 errors는 컴파일 타임 또는 런타임에 표시될 수 있다. 컴파일 타임시 오류는 코드가 실행되지 않는다. 런타임 오류는 코드가 실행되는 동안 예외가 발생한다. ","date":"2022-03-04","objectID":"/archives/til/20220304/:1:0","tags":["TIL","dart"],"title":"[TIL \u0026 Issue Note] 20220304","uri":"/archives/til/20220304/"},{"categories":["TIL \u0026 Issue Note"],"content":"Keywords ","date":"2022-03-04","objectID":"/archives/til/20220304/:2:0","tags":["TIL","dart"],"title":"[TIL \u0026 Issue Note] 20220304","uri":"/archives/til/20220304/"},{"categories":["TIL \u0026 Issue Note"],"content":"예약어 목록 아래는 Dart언어가 처리하는 특별한 단어들이다. Keywords 키워드를 식별자로 사용을 피해야한다. 하지만 필요에 따라 윗첨자표시가 된 예약어는 식별자로 사용이 가능하다. 윗첨자1은 문맥 키워드contextual keywords로, 특정 장소에만 의미가 있다. 어디에서든 식별자로 유효하다. 윗첨자2는 빌트인 식별자built-in identifiers로, 이 키워드는 대부분에 곳에서 식별자로 유효하나 class나 타입이름, import 접두사로 사용할 수 없다. 윗첨자3은 제한된 예악어로 비동기 지원과 연관이 있다. async, async*, 또는 sync*로 표기된 함수 본문안에서는 await나 yield가 식별자로 사용할 수 없다. ","date":"2022-03-04","objectID":"/archives/til/20220304/:2:1","tags":["TIL","dart"],"title":"[TIL \u0026 Issue Note] 20220304","uri":"/archives/til/20220304/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 블록체인의 탄생 배경 ","date":"2022-03-03","objectID":"/archives/til/20220303/:0:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"개요 블록체인의 작동원리와 기반 기술 세부기술에 대한 자세한 설명을 통해 블록체인의 정한 효용 초보자와 프로그래머에게 모두 열린 학습 비유를 통한 원리 이해 현업에 발판이 되는 전문 지식 ","date":"2022-03-03","objectID":"/archives/til/20220303/:1:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 블록체인의 탄생 배경 Cipherpunk 운동 Cipher(암호) + Punk의 합성어 암호로 개인의 프라이버시 보호를 극대화하고자 했던 행동주의자 등장 배경 1980년대 미국, 국가나 대형 기관에 의한 개인의 인권 및 개인정보 침해 심각 개인의 프라이버시 보호하고자 하는 의식 확산 암호화 기술은 국가/군 기관이 점유 -\u003e 개인에게는 허용 불가 1970년 IBM에서 일반인들도 사용할 수 있는 암호화 체계 등장 -\u003e DES (Data Encryption Standard, DES) 1983년, E-cash (David Chaum) 모든 금융 거래의 이체 내역 암호화 은행과의 제휴를 통해 계좌 이체 내역에 대해서만 본인이 알 수 있도록 함. 1998년, B-money (WeiDai) 분합산의 계산 퍼즐 사용 2002년, Hash cash(Adam back) Hal Finney 비트코인 1983년부터 시작되어 쌓여온 많은 기술들이 집대성 된 소프트웨어 2008년 인터넷에 9페이지 분량의 논문으로 게재 -\u003e 2009년 1월 3일 소프트웨어로 등장함 최초의 블록체인 비트코인 기반 기술 이미 존재하던 기술과 새로운 방식의 조합 기존 중앙서버로만 처리 -\u003e 현재 중앙 서버 없이 처리 가능 ","date":"2022-03-03","objectID":"/archives/til/20220303/:1:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 사토시 나카모토와 비트코인 사토시 나카모토 - 익명의 단체이며, 5~6명의 정도가 모인 단체 비트코인의 목적 비트코인을 사용해서 서로 금융거래 시 익명성 보장한다. -\u003e 개인의 프라이버시 보호 비트코인의 특징 2009년 1월 3일 최초의 블록(제네시스 블록) 탄생 2009년 1월 9일부터 블록 본격적으로 생산 시작 -\u003e 평균에 10분에 하나씩 2017년 말 대략 50만개 이상 생성 -\u003e 약 3억개의 거래 내역 보유 블록(Block) 논리적인 데이터 단위 예시) 데이터베이스 관점에서 학생을 식별할 수 있는 데이터 (이름, 성적, 성별, 반 등) 비트코인에서 블록의 정의 1MB 까지 담을 수 있는 논리적 저장장치 이더리움에서 블록 개념은 조금 다름 비트코인/블록체인에서의 블록 거래내역이 약 3천개 정도가 담긴 논리적인 저장 단위 비트코인논문에는 블록체인이라는 고유명사가 사용 되지 않음 -\u003e 블록체인에 대한 정확한 정의 없다. 어떤 계정이 다른 계정으로의 얼마 정도의 비트코인이 주고받았다는 거래내역의 기록 블록 체인 블록들이 만들어진 순서대로 차곡차곡 쌓여서 마치 쇠사슬에 묶여있는 모양 블록체인에 대한 정의 -\u003e 각자의 방식대로 다양한 해석이 존재 -\u003e 블록체인에 대한 정의가 상호간 불일치 ","date":"2022-03-03","objectID":"/archives/til/20220303/:1:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 0 번째 블록과 500,000 번째 블록 비교 구분 제네시스 블록 500,000번째 블록 블록번호(높이) 0 500,000 생성 시각 2009-01-03 2017-12-18 크기(바이트) 285 2,701 2009년 : 비트코인을 사용한 사람이 없었으므로 거래내역이 존재하지 않음 2017년: 비트코인의 거래가 활발 비트코인의 제약조건 한 블록당 1MB를 넘기지 못하는 제약 조건이 있다. 블록크기의 제약은 거래를 처리하는 시간과 연관이 있다. 비트코인의 수요가 늘더라도 처리 능력이 그것을 따라가지 못함을 암시 비트코인 보상금 블록을 생성한 사람들에게 보상금이 주어짐 고정금인 보조금 + 변동금인 수수료 -\u003e 거래내역으로부터 거둬들인 금액 비트코인의 소유주가 건네주는 사람을 대신하여 수수료를 지불 -\u003e 수수료 액수에 따라 비트코인 처리 속도가 좌우 블록생성에 경쟁의 동인 -\u003e 비트코인 시세 영향 (시세하락 시 블록생성의 동기부여가 저하) 비트코인 소유자가 결정 : 점점 많은 사람들이 수수료 경쟁 블록 생성의 난이도 에너지와 하드웨어의 상대 척도 필요 에너지의 지속적인 변화 1조 9000억 배 이상의 에너지 소모 블록 생성을 위한 에너지는 계속 증가 블록 생성에 대한 보상금, 난이도 -\u003e 블록체인이 영속성과 직결 구분 제네시스 블록 500,000번째 블록 블록 보조금 50 BTC 12.5 BTC 트랜잭션 수수료 0 BTC 3.39351625 BTC 비트코인 블록체인 기초지식 ","date":"2022-03-03","objectID":"/archives/til/20220303/:1:3","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"1. 블록체인과 전통적 거래원장의 비교 ","date":"2022-03-03","objectID":"/archives/til/20220303/:2:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"전통적인 거래원장 누구에게 얼마를 주었는지 원장/장부에 기록 거래내역이 순차적으로 기입 송신자, 수취자, 입금액 기록 ","date":"2022-03-03","objectID":"/archives/til/20220303/:2:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"블록체인 블록 = 전통적인 원장/장부의 페이지 블록체인 = 전체 장부 시간 순서에 맞춰서 기록하는 장치 = 거래내역을 순서대로 기록하는 저 장장치 한 번 쓰인 기록은 삭제나 변경이 불가능 -\u003e 블록체인의 속성 각각의 블록에서 지금까지 비트코인을 주고받은 모든 거래내역 확인 비트코인 거래 원장의 내용 보내는 사람의 비트코인 주소(비트코인주소 = 은행에서 계좌번호 역할) 받는 사람의 비트코인 주소 보내는 금액 수수료 비트코인 소유자가 비트코인을 처리하기 위해 블록을 만든 사람에게 지불하는 금액 수수료 액수에 따라 비트코인 유통 속도가 좌우 소유자가 스스로 수수료 책정 ","date":"2022-03-03","objectID":"/archives/til/20220303/:2:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"2. 비트코인 발행량 ","date":"2022-03-03","objectID":"/archives/til/20220303/:3:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인 발행량 비트코인은 새로운 블록이 생성 될 때마다 소프트웨어적으로 발생한다 -\u003e 보조금 개념 보상금 : 블록을 생성한 사람한테 주어짐 보조금 : 보상금 + 수수료 약 210,000 개마다 생성량이 저감되게 설계 = 보조금이 약 4년을 주기로 반감하도록 설계(210,000 4년 소요) 0번 블록 : 50 BTC -\u003e 500,000 블록 : 12.5 BTC 2140년이 되면 비트코인 발행 중단 = 발행량은 대략 2,100만 비트코인으로 추정 ","date":"2022-03-03","objectID":"/archives/til/20220303/:3:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인의 가치 비트코인은 한정된 자원 -\u003e 미래에는 금과 같은 가치가 될 것(?) 하지만 단순히 프로그램일 뿐 코드의 변경으로 발행량을 변경가능 비슷한 프로그램도 얼마든지 복제 가능 미래 화폐로서 가능성이 있는가? -\u003e 미래 가치는 사람들의 인식에 의해 결정 블록생성 보조금이 감소되게 되면 블록생성 보조금이 감소 -\u003e 수령하는 보상금 감소 -\u003e 비트코인 가치 폭락 =\u003e 블록을 만들 수 있는 동인 소멸 비트코인의 가치가 블록체인의 존립을 결정 결론 발행량이 제한 -\u003e 그 가치를 보장해 주지는 않음. 동인의 저하로 리스크 요인으로 작용할 수 있음 ","date":"2022-03-03","objectID":"/archives/til/20220303/:3:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"3. 비트코인과 이더리움 등의 거래 방식과 단위 ","date":"2022-03-03","objectID":"/archives/til/20220303/:4:0","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"단위 암호화폐의 경우 통용 화폐 단위에 비해서 매우 정교하고 작은 형태 달러 센트 + 달러 100센트 = 1달러 비트코인 사토시 + 비트코인 1억 사토시(Sat.) = 1비트코인(BTC) 이더리움 Ether + … + Wei 1Ether = 10^18 wei 1,000,0000 Szabo 1,000 Finney ","date":"2022-03-03","objectID":"/archives/til/20220303/:4:1","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"비트코인의 교환 방식 지폐를 물리적으로 나누어 지불하지 않는 것과 유사 전체 금액을 모두 지불하고 거스름돈을 돌려 받는 방식 소유자가 모든 내역을 기술하는 방식임 거스름돈도 소유자가 직접 작성해야 함 수령자는 어떤 거래내역도 기록하지 않음 소유자가 수수료를 부담함 정해진 액면으로서 블록에 기록 -\u003e 주고받은 거래내역 중 나머지 돈이 새로운 화폐로 발생 새로운 액면 단위 생성 -\u003e 생성되는 액면 가지 수 무한대 약속된 금액의 부재 -\u003e 합의된 거스름돈의 부재 -\u003e 거래가 반복됨에 따라 새로운 액면 발생 ","date":"2022-03-03","objectID":"/archives/til/20220303/:4:2","tags":["TIL","blockchain","bitcoin"],"title":"[TIL \u0026 Issue Note] 20220303","uri":"/archives/til/20220303/"},{"categories":["TIL \u0026 Issue Note"],"content":"What is React? 사용자 인터페이스를 구축하기 위한 자바스크립트 라이브러리. ","date":"2022-03-02","objectID":"/archives/til/20220302/:1:0","tags":["TIL","ssl","react","udemy"],"title":"[TIL \u0026 Issue Note] 20220302","uri":"/archives/til/20220302/"},{"categories":["TIL \u0026 Issue Note"],"content":"모바일 앱과 웹사이트 비교 모바일 앱 모바일 앱은 반응성이 매우 높은 사용자 환경을 제공한다. 화면 전환이 빠르기 때문에 사용하기 좋다. 웹사이트 웹사이트는 사용자 요청이 (링크나, 버튼을 클릭했을 때) 서버로 전송되고 전송된 결과(HTML 페이지)는 브라우저로 다시 전송되어 화면에 띄워지는 구조이다. 이러한 요청과 반응 사이클로 인해 동작이 모바일 앱에 비해서는 투박하고 지연이 있을 수 있다. ","date":"2022-03-02","objectID":"/archives/til/20220302/:1:1","tags":["TIL","ssl","react","udemy"],"title":"[TIL \u0026 Issue Note] 20220302","uri":"/archives/til/20220302/"},{"categories":["TIL \u0026 Issue Note"],"content":"자바스크립트 자바스크립트를 통해 Dom을 조작하고 이를 통해 HTML의 요소를 제어할 수 있다. 새로운 HTML 페이지를 렌더링 하지 않아도 이러한 요소를 바꿀 수 있다. ","date":"2022-03-02","objectID":"/archives/til/20220302/:1:2","tags":["TIL","ssl","react","udemy"],"title":"[TIL \u0026 Issue Note] 20220302","uri":"/archives/til/20220302/"},{"categories":["TIL \u0026 Issue Note"],"content":"왜 React.js가 필요할까? ","date":"2022-03-02","objectID":"/archives/til/20220302/:2:0","tags":["TIL","ssl","react","udemy"],"title":"[TIL \u0026 Issue Note] 20220302","uri":"/archives/til/20220302/"},{"categories":["TIL \u0026 Issue Note"],"content":"Vanila.js 자바스크립트는 모든 단계를 정의하고 구현해야 한다. 명령형 접근 이러한 방식에는 한계가 있거나 혹은 세부사항에 대해 개발자가 모두 신경 써야한다. ","date":"2022-03-02","objectID":"/archives/til/20220302/:2:1","tags":["TIL","ssl","react","udemy"],"title":"[TIL \u0026 Issue Note] 20220302","uri":"/archives/til/20220302/"},{"categories":["TIL \u0026 Issue Note"],"content":"React.js 리액트는 애플리케이션을 작은 구성요소로 나누고 조합하여 렌더링한다. 리액트의 구성요소에는 뚜렷한 과제가 존재하여 코드 유지보수와 관리가 쉽다. 더 현대적이고 풍부하고 복잡한 사용자 인터페이스를 구현할 수 있다. ","date":"2022-03-02","objectID":"/archives/til/20220302/:2:2","tags":["TIL","ssl","react","udemy"],"title":"[TIL \u0026 Issue Note] 20220302","uri":"/archives/til/20220302/"},{"categories":["TIL \u0026 Issue Note"],"content":"참고 react-vs-vanilla-js-example ","date":"2022-03-02","objectID":"/archives/til/20220302/:3:0","tags":["TIL","ssl","react","udemy"],"title":"[TIL \u0026 Issue Note] 20220302","uri":"/archives/til/20220302/"},{"categories":["Think Data Structures"],"content":"목표 자바 배열을 사용하여 요소를 저장하는 List 인터페이스 구현한다. ","date":"2022-02-26","objectID":"/archives/think-data-structures/think-data-structures-1/:1:0","tags":["data-structures","algorithm","java","interface"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/archives/think-data-structures/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"클래스 정의와 인스턴스 변수, 생성자 public class MyArrayList\u003cT\u003e implements List\u003cT\u003e { int size; // keeps track of the number of elements private T[] array; // stores the elements public MyArrayList() { array = (T[]) new Object[10]; size = 0; } } size 변수는 MyArrayList의 요소 개수를 추적한다. array 변수는 실제로 그 요소들을 저장하는 배열을 의미한다. 생성자는 10개의 요소를 갖는 빈 배열을 생성, size 변수는 0으로 설정한다. ","date":"2022-02-26","objectID":"/archives/think-data-structures/think-data-structures-1/:1:1","tags":["data-structures","algorithm","java","interface"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/archives/think-data-structures/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"add 메서드 살펴보기 boolean add(E e) @Override public boolean add(T element) { if(size \u003e= array.length) { T[] temp = (T[]) new Object[array.length * 2]; System.arraycopy(array, 0, temp, 0, array.length); array = temp; } array[size] = element; size++; return true; } 배열에 여분의 공간이 없으면 더 큰 배열을 만들어 복사 한다. 리스트 마지막에 요소를 추가한다. 리스트의 사이즈를 증가한다. ","date":"2022-02-26","objectID":"/archives/think-data-structures/think-data-structures-1/:1:2","tags":["data-structures","algorithm","java","interface"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/archives/think-data-structures/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"get 메서드 살펴보기 @Override public T get(int index) { if (index \u003c 0 || index \u003e= size) { throw new IndexOutOfBoundsException(); } return array[index]; } 인덱스가 범위를 벗어나면 IndexOutOfBoundsException 예외를 던진다. 배열의 인덱스 요소를 읽고 반환한다. ","date":"2022-02-26","objectID":"/archives/think-data-structures/think-data-structures-1/:1:3","tags":["data-structures","algorithm","java","interface"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/archives/think-data-structures/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"set 메서드 구현하기 E set(int index, E element) 이 목록에 지정된 위치에 있는 요소를 입력받은 요소로 변경한다. 인덱스를 검사하는 코드의 반복은 피한다. Parameter index - 교체 할 요소의 인덱스 element - 특정한 위치에 저장할 요소 @Override public T set(int index, T element) { T prev = get(index); array[index] = element; return prev; } get(index) 메서드를 사용하여 인덱스의 범위를 검사하는 코드의 중복을 피한다. 입력받은 요소를 array 입력받은 위치에 대입한다. 이전 요소를 리턴한다. ","date":"2022-02-26","objectID":"/archives/think-data-structures/think-data-structures-1/:1:4","tags":["data-structures","algorithm","java","interface"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/archives/think-data-structures/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"indexOf 구현하기 int indexOf(Object o) 이 목록에서 지정된 요소가 처음 나타나는 인덱스를 반환한다. 요소가 없으면 -1을 반환 (o==null ? get(i)==null : o.equals(get(i))) Parameter o - 검색할 요소 Return 이 목록에서 지정된 요소가 처음 나타나는 인덱스 private boolean equals(Object target, Object element) { if (target == null) { return element == null; } else { return target.equals(element); } } @Override public int indexOf(Object target) { for(int i = 0; i \u003c size; i++) { if(equals(target, array[i])) { return i; } } return -1; } 책에서는 배열의 요소를 대상 값과 비교하여 같으면 true를 반환하는 equals 헬퍼 메서드를 제공. (null 처리 포함) 리스트의 사이즈만큼 순회하면서 입력받은 요소와 같은 요소가 있는지 확인한다. 없는 경우 -1 ","date":"2022-02-26","objectID":"/archives/think-data-structures/think-data-structures-1/:1:5","tags":["data-structures","algorithm","java","interface"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/archives/think-data-structures/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"특정 위치에 add 하는 메서드 구현 void add(int index, E element) 요소를 리스트의 지정한 위치에 삽입. 삽입 된 위치에 있는 다음 요소들을 모두 오른쪽으로 이동. 배열을 더 크게 늘리는 코드는 반복하지 않는다. (?? 이건 다시 봐야겠다…) @Override public void add(int index, T element) { if (index \u003c 0 || index \u003e size) { throw new IndexOutOfBoundsException(); } // add the element to get the resizing add(element); // shift the elements for (int i=size-1; i\u003eindex; i--) { array[i] = array[i-1]; } // put the new one in the right place array[index] = element; } ","date":"2022-02-26","objectID":"/archives/think-data-structures/think-data-structures-1/:1:6","tags":["data-structures","algorithm","java","interface"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/archives/think-data-structures/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"remove 메서드 구현 E remove(int index) 지정한 위치에 존재하는 요소를 삭제한다. 삭제된 위치 다음 요소드를 모두 왼쪽으로 이동시킨다. @Override public T remove(int index) { T prev = get(index); for(int i = index + 1; i \u003c size; i++) { array[i - 1] = array[i]; } size--; return prev; } get(index) 메서드를 통해 인덱스에 위치한 요소를 삭제할 요소를 가져온다. 삭제하는 인덱스 다음 요소를 왼쪽으로 이동한다. 리스트의 size를 감소시킨다. 이전 요소를 리턴한다. ","date":"2022-02-26","objectID":"/archives/think-data-structures/think-data-structures-1/:1:7","tags":["data-structures","algorithm","java","interface"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/archives/think-data-structures/think-data-structures-1/"},{"categories":["TIL \u0026 Issue Note"],"content":"20220218 Note 도커 비공개 레포지토리를 자체 인증서를 발급 하여 세팅한다. 깃랩 러너를 구성하여 main 브랜치에 머지되었을 때 서버를 구성한다. docker-compose.yml version: '3.8' services: registry: image: registry:2 restart: always volumes: - /home/cherry/devops/docker_repository/images:/var/lib/registry - /home/cherry/devops/docker_repository/certs:/certs ports: - 5000:5000 environment: REGISTRY_HTTP_TLS_CERTIFICATE: /certs/domain.crt REGISTRY_HTTP_TLS_KEY: /certs/domain.key gitlab-runner: container_name: gitlab-runner image: 'gitlab/gitlab-runner:latest' restart: always volumes: - ./gitlab-runner/config:/etc/gitlab-runner - /var/run/docker.sock:/var/run/docker.sock ","date":"2022-02-18","objectID":"/archives/til/20220218/:1:0","tags":["TIL","ssl","docker"],"title":"[TIL \u0026 Issue Note] 20220218","uri":"/archives/til/20220218/"},{"categories":["TIL \u0026 Issue Note"],"content":"이슈 사내 사이드 프로젝트 배포를 위한 개인 도커 레포지토리를 구축 중이다. 도메인은 godaddy를 통해 구매하였고, repository.XXXXX.com 서브도메인을 구성하였다. 개인 도커 레포지토리를 외부에서 접근하려먼 HTTPS만 지원하기 때문에 openssl을 통해 자체 서명 인증서를 발급했다. openssl req -newkey rsa:4096 -nodes -sha256 -keyout ./domain.key -x509 -days 365 -out ./domain.crt 위와 같이 발행 후 원격장비에서 도커 레포지토리 장비로 이미지를 푸시하려는데 아래와 같은 메세지와 함께 푸시가 되지 않았다. The push refers to repository [repository.XXXXX.com:5000/my-nginx] Get “https://repository.XXXXX.com:5000/v2/\": x509: certificate relies on legacy Common Name field, use SANs or temporarily enable Common Name matching with GODEBUG=x509ignoreCN=0 ","date":"2022-02-17","objectID":"/archives/til/20220217/:1:0","tags":["TIL","ssl","docker"],"title":"[TIL \u0026 Issue Note] 20220217","uri":"/archives/til/20220217/"},{"categories":["TIL \u0026 Issue Note"],"content":"설명 docker registry는 버전 2는 GoLang으로 개발되었다. 자체 발급한 인증서가 GoLang 1.15에 도입된 변경 사항을 준수하지 않았기 때문에 에러가 발생했다. Go 버전 1.15부터는 X.509 인증서의 SAN(Subject Alternative Names) 항목이 없을 때 CommonName 필드를 Host 이름으로 대체하는게 deprecated 되었다고 한다. ","date":"2022-02-17","objectID":"/archives/til/20220217/:2:0","tags":["TIL","ssl","docker"],"title":"[TIL \u0026 Issue Note] 20220217","uri":"/archives/til/20220217/"},{"categories":["TIL \u0026 Issue Note"],"content":"해결한 방법 opensssl을 통하여 인증서를 발급할 때 -addext 옵션을 통해 Subject Alt Name 항목을 추가했다. 인증서를 사용할 서브 도메인을 모두 적어주어야 한다. openssl req -newkey rsa:4096 -addext \"subjectAltName = DNS:XXXXX.com,DNS:www.XXXXX.com,DNS:repository.XXXXX.com\" -nodes -sha256 -keyout ./domain.key -x509 -days 365 -out ./domain.crt 원격 개인 도커 허브 장비에서 SAN을 포함한 인증서를 다시 발급 생성한 domain.crt의 내용을 클라이언트(로컬 Mac)으로 복사 # Mac의 docker 인증서 파일 위치 vi ~/.docker/certs.d/repository.XXXXX.com:5000/domain.crt 로컬 장비의 도커 프로세스 재기동 # Mac에서 Docker 재기동 $ killall Docker \u0026\u0026 open /Applications/Docker.app 로컬 장비에서 원격 도커허브로 이미지 푸시 ","date":"2022-02-17","objectID":"/archives/til/20220217/:3:0","tags":["TIL","ssl","docker"],"title":"[TIL \u0026 Issue Note] 20220217","uri":"/archives/til/20220217/"},{"categories":["TIL \u0026 Issue Note"],"content":"더 알아보기 SSL - Wildcard 와 SAN 인증서 차이점 ","date":"2022-02-17","objectID":"/archives/til/20220217/:4:0","tags":["TIL","ssl","docker"],"title":"[TIL \u0026 Issue Note] 20220217","uri":"/archives/til/20220217/"},{"categories":["CI/CD 서버 구성하기"],"content":"개요 사내 개발 협업을 위한 CI/CD 서버를 구축한다. AWS EC2 인스턴스를 사용중이다. (Ubuntu LTS) docker, docker-compose가 설치되어 있다. Install Docker Engine on Ubuntu Install Docker Compose GitLab의 경우 추후 라이센스 구매를 위해 ce가 아닌 ee 버전으로 설치한다. ","date":"2022-02-14","objectID":"/archives/devops/ci-cd/install-jenkins-gitlab/:1:0","tags":["ci","cd","devops","docker-compose","jenkins","gitlab"],"title":"CI/CD 서버 구축하기 - 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/archives/devops/ci-cd/install-jenkins-gitlab/"},{"categories":["CI/CD 서버 구성하기"],"content":"설치를 위한 Docker Compose 설정 아래는 GitLab, Jenkins를 컨테이너를 띄우기 위한 docker-compose 설정이다. GitLab 이미지는 단일 컨테이너에서 서비스를 실행하기위한 Monolithic 이미지이며 최소 시스템 요구사항은 아래와 같다. GitLab installation minimum requirements ","date":"2022-02-14","objectID":"/archives/devops/ci-cd/install-jenkins-gitlab/:2:0","tags":["ci","cd","devops","docker-compose","jenkins","gitlab"],"title":"CI/CD 서버 구축하기 - 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/archives/devops/ci-cd/install-jenkins-gitlab/"},{"categories":["CI/CD 서버 구성하기"],"content":"docker-compose.yml 파일 준비 작업 디렉터리를 생성한다. cd ~/ mkdir devops cd devops docker-compose.yml 파일을 생성한다 touch docker-compose.yml vi docker-compose.yml docker-compose.yml에 아래 내용을 추가한다. version: '3.0' services: gitlab: container_name: gitlab image: gitlab/gitlab-ee:latest restart: always hostname: \"내IP:8289\" environment: TZ: 'Asia/Seoul' GITLAB_OMNIBUS_CONFIG: | external_url 'http://내IP:8289' nginx['redirect_http_to_https'] = false nginx['listen_https'] = false nginx['listen_port'] = 8289 gitlab_rails['gitlab_shell_ssh_port'] = 2202 ports: - \"2202:22\" - \"8289:8289\" volumes: - \"/home/ubuntu/devops/gitlab/config:/etc/gitlab\" - \"/home/ubuntu/devops/gitlab/logs:/var/log/gitlab\" - \"/home/ubuntu/devops/gitlab/data:/var/opt/gitlab\" networks: - votenet jenkins: container_name: jenkins user: root image: jenkins/jenkins:lts restart: always ports: - \"9080:8080\" environment: - GRADLE_HOME=/home/ubuntu/devops/jenkins/libs/gradle volumes: - \"/home/ubuntu/devops/jenkins/jenkins_home:/var/jenkins_home\" - \"/home/ubuntu/devops/jenkins/script:/app/jenkins/script\" - \"/home/ubuntu/devops/jenkins/source:/app/jenkins/source\" - \"/home/ubuntu/devops/jenkins/ssh_key:/app/jenkins/ssh_key\" - \"/home/ubuntu/devops/jenkins/libs:/app/jenkins/libs\" - \"/var/run/docker.sock:/var/run/docker.sock\" networks: - votenet networks: votenet: ","date":"2022-02-14","objectID":"/archives/devops/ci-cd/install-jenkins-gitlab/:2:1","tags":["ci","cd","devops","docker-compose","jenkins","gitlab"],"title":"CI/CD 서버 구축하기 - 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/archives/devops/ci-cd/install-jenkins-gitlab/"},{"categories":["CI/CD 서버 구성하기"],"content":"Docker Compose를 사용하여 구동 docker-compose.yml을 생성한 디렉터리에서 해당 명령어를 실행한다. $ sudo docker-compose up -d 아래 명령어로 구동한 도커 컨테이너를 확인할 수 있다. $ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 72dd26a6e3c4 jenkins/jenkins:lts \"/sbin/tini -- /usr/…\" 15 seconds ago Up 12 seconds 50000/tcp, 0.0.0.0:9080-\u003e8080/tcp, :::9080-\u003e8080/tcp jenkins 99e8736406b5 gitlab/gitlab-ee:latest \"/assets/wrapper\" 15 seconds ago Up 11 seconds (health: starting) 80/tcp, 443/tcp, 0.0.0.0:8289-\u003e9980/tcp, :::8289-\u003e9980/tcp, 0.0.0.0:2202-\u003e22/tcp, :::2202-\u003e22/tcp gitlab ","date":"2022-02-14","objectID":"/archives/devops/ci-cd/install-jenkins-gitlab/:3:0","tags":["ci","cd","devops","docker-compose","jenkins","gitlab"],"title":"CI/CD 서버 구축하기 - 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/archives/devops/ci-cd/install-jenkins-gitlab/"},{"categories":["CI/CD 서버 구성하기"],"content":"설치 확인 설치한 GitLab이 정상 동작하는지 Web으로 접속하여 확인한다. DNS 설정은 안했기 때문에 IP로 접속하게 끔 설정했다. 클라우드 서버를 사용하여 구동하기 때문에 외부에서 내가 지정한 포트로 접속이 가능하게 오픈하였다. ","date":"2022-02-14","objectID":"/archives/devops/ci-cd/install-jenkins-gitlab/:4:0","tags":["ci","cd","devops","docker-compose","jenkins","gitlab"],"title":"CI/CD 서버 구축하기 - 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/archives/devops/ci-cd/install-jenkins-gitlab/"},{"categories":["CI/CD 서버 구성하기"],"content":"GitLab 설치 확인 external_url로 설정한 URL로 접속한다. 처음 접속이라면 관리자 계정의 패스워드를 변경할 수 있는 화면이 뜬다. ","date":"2022-02-14","objectID":"/archives/devops/ci-cd/install-jenkins-gitlab/:4:1","tags":["ci","cd","devops","docker-compose","jenkins","gitlab"],"title":"CI/CD 서버 구축하기 - 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/archives/devops/ci-cd/install-jenkins-gitlab/"},{"categories":["CI/CD 서버 구성하기"],"content":"Jenkins 설치 확인 Jenkins 설치 후 처음 접속하게되면 Jenkins를 잠금 해제하는 화면이 뜨게 된다. 아래 명령어를 통해 초기 패스워드를 설정할 수 있다. 그 이후 프로세스를 쭉 따라 Jenkins 관리자 계정을 설정한다. $ sudo docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword ","date":"2022-02-14","objectID":"/archives/devops/ci-cd/install-jenkins-gitlab/:4:2","tags":["ci","cd","devops","docker-compose","jenkins","gitlab"],"title":"CI/CD 서버 구축하기 - 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/archives/devops/ci-cd/install-jenkins-gitlab/"},{"categories":["CI/CD 서버 구성하기"],"content":"참고 Jenkins vs GitLab CI: Battle of CI/CD Tools ","date":"2022-02-14","objectID":"/archives/devops/ci-cd/install-jenkins-gitlab/:5:0","tags":["ci","cd","devops","docker-compose","jenkins","gitlab"],"title":"CI/CD 서버 구축하기 - 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/archives/devops/ci-cd/install-jenkins-gitlab/"},{"categories":["CI/CD 서버 구성하기"],"content":"요약 CI/CD는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법이다. 아래 세 가지 단계로 구분 할 수 있다. 지속적인 통합 Continuous Integration 지속적인 서비스 제공 Continuous Delivery 지속적인 배포 Continuous Deployment [출처] https://www.redhat.com/ko/topics/devops/what-is-ci-cd 💡 “CD\"는 지속적인 서비스 제공(Continuous Delivery) 및/또는 지속적인 배포(Continuous Deployment)를 의미하며 이 두 용어는 상호 교환적으로 사용할 수 있다. ","date":"2022-02-10","objectID":"/archives/devops/ci-cd/ci-cd/:1:0","tags":["ci","cd","devops"],"title":"CI/CD 서버 구축하기 - 1. 개념","uri":"/archives/devops/ci-cd/ci-cd/"},{"categories":["CI/CD 서버 구성하기"],"content":"개념 ","date":"2022-02-10","objectID":"/archives/devops/ci-cd/ci-cd/:2:0","tags":["ci","cd","devops"],"title":"CI/CD 서버 구축하기 - 1. 개념","uri":"/archives/devops/ci-cd/ci-cd/"},{"categories":["CI/CD 서버 구성하기"],"content":"CI 다수의 개발자가 작성 및 수정한 코드가 지속적으로 통합/테스트(Continuous Integration) 되는 것을 의미한다. CI 작업 순서는 도구, 프로그래밍 언어, 프로젝트 등 기타 여러 요인에 따라 많이 다르지만 일반적으로는 다음과 같다. 코드를 레포지토리로 푸시한다. 정적 분석 배포 전 테스트 테스트 환경에 패키징 및 배포 배포 후 테스트 [출처] www.pepgotesting.com ","date":"2022-02-10","objectID":"/archives/devops/ci-cd/ci-cd/:2:1","tags":["ci","cd","devops"],"title":"CI/CD 서버 구축하기 - 1. 개념","uri":"/archives/devops/ci-cd/ci-cd/"},{"categories":["CI/CD 서버 구성하기"],"content":"CD CD는 지속적 제공 Continuous Delivery과 지속적 배포 Continuous Deployment를 두 가지를 모두 의미한다. 지속적 제공 Continuous Delivery : CI 수행 후 프로세스에 유효한 코드를 레포지토리에 올리는 것을 자동화 한다. 프로덕션 레벨로 배포가 가능한 상태까지 준비해되는 것이 목표. (코드의 변경 사항 병합, 테스트 자동화, 코드 릴리스 자동화 포함) 지속적 배포 Continuous Deployment : CI/CD 마지막 단계. 프로덕션 준비가 완료된 빌드를 코드 리포지토리에 자동으로 릴리즈 한다. ","date":"2022-02-10","objectID":"/archives/devops/ci-cd/ci-cd/:2:2","tags":["ci","cd","devops"],"title":"CI/CD 서버 구축하기 - 1. 개념","uri":"/archives/devops/ci-cd/ci-cd/"},{"categories":["CI/CD 서버 구성하기"],"content":"CI/CD 도구들 CI/CD를 위한 도구들은 굉장히 많다. 본인 팀에 맞는 형태의 도구를 고르면 된다. 🐹 나는 계속 스타트업에서 일했기 때문에 무료로 구성할 수 있는 Jenkins 와 GitLab을 가장 많이 사용했다. docker를 통해 쉽게 구성이 가능하다. Bamboo의 경우 Jira의 이슈 시스템과 연동하여 사용할 수 있어 프로젝트 관리 측면에서 매우 유용하다. (대신 프로젝트 인원이 많은 경우 가격이 사악…) GitHub Action/Travis CI 는 따로 CI 서버를 구성하지 않아도 되기 때문에 내 블로그는 GitHub Action을 통해 빌드 및 배포하고 있다. [출처] https://www.katalon.com/resources-center/blog/ci-cd-tools/ ","date":"2022-02-10","objectID":"/archives/devops/ci-cd/ci-cd/:3:0","tags":["ci","cd","devops"],"title":"CI/CD 서버 구축하기 - 1. 개념","uri":"/archives/devops/ci-cd/ci-cd/"},{"categories":["CI/CD 서버 구성하기"],"content":"참고링크 RedHat 토픽 - CI/CD(지속적 통합/지속적 제공): 개념, 방법, 장점, 구현 과정 Continuous Integration: A “Typical” Process ","date":"2022-02-10","objectID":"/archives/devops/ci-cd/ci-cd/:4:0","tags":["ci","cd","devops"],"title":"CI/CD 서버 구축하기 - 1. 개념","uri":"/archives/devops/ci-cd/ci-cd/"},{"categories":["javascript"],"content":" 회사에서 Javascript 용 서비스 SDK를 개발하면서 설정했던 webpack5 설정파일을 기록한다. 오래전에 잠깐 접해보았던게 webpack2 버전이었는데 어느새 5까지 나왔다. 알고 사용하는게 아니다보니 쓰면서 애를 먹었다…🥺🥺🥺 Webpack5 설정하기 (ESM 사용) 회사에서 개발한 SDK는 CJS(CommonJS)에서 ESM(ECMAScript Module) 모듈 방식을 사용하여 개발했다. ESM 모듈 로더 사용하기 위해 package.json에 아래 설정을 추가했다. package.json \"type\": \"module\" 아래 글에서는 CJS가 기본값이기 때문에 라이브러리의 경우 CJS로 개발하는 것을 추천하고 있다. Node Modules at War: Why CommonJS and ES Modules Can’t Get Along ","date":"2022-01-16","objectID":"/archives/javascript/webpack/:0:0","tags":["javascript","webpack","esm","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/archives/javascript/webpack/"},{"categories":["javascript"],"content":"설치 라이브러리 npm install --save-dev webpack webpack-cli webpack-merge webpack-stream webpack-merge 웹팩 설정을 하나로 병합해주는 라이브러리. 웹팩 설정을 개발용과 배포용으로 나누기 위해 적용했다. webpack-stream 태스크 러너는 gulp를 사용하고 있다. gulp에서 웹팩을 모듈링작업을 추가 하기 위해 설치했다. ","date":"2022-01-16","objectID":"/archives/javascript/webpack/:1:0","tags":["javascript","webpack","esm","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/archives/javascript/webpack/"},{"categories":["javascript"],"content":"webpack.config.js import webpack from \"webpack\"; const webpack5esmInteropRule = { test: /\\.m?js/, resolve: { fullySpecified: false } } const config = { target: ['web', 'es5'], entry: { main: \"./entries-webpack.js\", }, output: { filename: \"tychain.min.js\" }, resolve: { modules: ['node_modules'], fallback: { assert: false, buffer: await Promise.resolve('buffer'), console: false, constants: false, crypto: await Promise.resolve('crypto-browserify'), domain: false, events: false, fs: false, http: false, https: false, os: false, path: false, punycode: false, process: false, querystring: false, stream: await Promise.resolve('stream-browserify'), string_decoder: false, sys: false, timers: false, tty: false, url: false, util: false, vm: false, zlib: false, } }, module: { rules: [ webpack5esmInteropRule, { test: /\\.js$/, exclude: /node_modules/, use: { loader: \"babel-loader\", options: { presets: [\"@babel/preset-env\"], plugins: [\"@babel/plugin-proposal-class-properties\"] } } }, ] }, plugins: [ new webpack.ProvidePlugin({ Buffer: ['buffer', 'Buffer'], ndcrypto: ['crypto', 'ndcrypto'], }), ], optimization: { concatenateModules: true } } export default config; ","date":"2022-01-16","objectID":"/archives/javascript/webpack/:2:0","tags":["javascript","webpack","esm","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/archives/javascript/webpack/"},{"categories":["javascript"],"content":"target 웹팩은 여러 환경과 타켓으로 컴파일 할 수 있다. Targets|webpack ","date":"2022-01-16","objectID":"/archives/javascript/webpack/:2:1","tags":["javascript","webpack","esm","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/archives/javascript/webpack/"},{"categories":["javascript"],"content":"entry entry는 애플리케이션을 번들리할 때 프로세스를 시작할 지점이다. Entry and Context|webpack ","date":"2022-01-16","objectID":"/archives/javascript/webpack/:2:2","tags":["javascript","webpack","esm","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/archives/javascript/webpack/"},{"categories":["javascript"],"content":"output output은 컴파일 된 번들파일과 리소스를 어느 경로에 어떤 이름으로 생성할지 지정할 수 있다. entry는 여러 지점이 있을 수 있지만 output은 하나의 구성만 지정할 수 있다. Output|webpack ","date":"2022-01-16","objectID":"/archives/javascript/webpack/:2:3","tags":["javascript","webpack","esm","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/archives/javascript/webpack/"},{"categories":["javascript"],"content":"resolve resolve 옵션은 모듈을 해석하는 방식을 지정할 수 있다. resolve.modules 모듈을 해석할 때 검색할 디렉터리를 웹팩에 알려준다. 상대경로는 node가 현재 디렉터리와 상위 디렉터리를 통해 node_modeuls를 검색하는 방법과 유사하게 검색되며, 절대경로는 오직 주어진 디렉터리에서만 검색한다. webpack.config.js module.exports = { //... resolve: { modules: ['node_modules'], }, }; webpack.config.js const path = require('path'); module.exports = { //... resolve: { modules: [path.resolve(__dirname, 'src'), 'node_modules'], }, }; resolve.fallback webpack5에서는 Node.js 코어 모듈에 대해 자동 polyfill을 제공하지 않는다. 그러므로 브라우저에서 실행되는 코드에서 사용하는 경우 npm 모듈을 직접 설치하고 포함해야 한다. 다음은 webpack 5 이전에 webpack이 사용한 polyfill 목록이다. 회사에서는 모든 설정파일도 ESM 방식으로 webpack.conf.js 파일 또한 ESM으로 작성되었다. ESM의 경우 아래와 같이 설정한다. crypto: await Promise.resolve('crypto-browserify'), resolve: { fallback: { assert: require.resolve('assert'), buffer: require.resolve('buffer'), console: require.resolve('console-browserify'), constants: require.resolve('constants-browserify'), crypto: require.resolve('crypto-browserify'), domain: require.resolve('domain-browser'), events: require.resolve('events'), http: require.resolve('stream-http'), https: require.resolve('https-browserify'), os: require.resolve('os-browserify/browser'), path: require.resolve('path-browserify'), punycode: require.resolve('punycode'), process: require.resolve('process/browser'), querystring: require.resolve('querystring-es3'), stream: require.resolve('stream-browserify'), string_decoder: require.resolve('string_decoder'), sys: require.resolve('util'), timers: require.resolve('timers-browserify'), tty: require.resolve('tty-browserify'), url: require.resolve('url'), util: require.resolve('util'), vm: require.resolve('vm-browserify'), zlib: require.resolve('browserify-zlib'), }, }, ","date":"2022-01-16","objectID":"/archives/javascript/webpack/:2:4","tags":["javascript","webpack","esm","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/archives/javascript/webpack/"},{"categories":["javascript"],"content":"To Do CJS, ESM ","date":"2022-01-16","objectID":"/archives/javascript/webpack/:3:0","tags":["javascript","webpack","esm","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/archives/javascript/webpack/"},{"categories":["javascript"],"content":"Reference ","date":"2022-01-16","objectID":"/archives/javascript/webpack/:4:0","tags":["javascript","webpack","esm","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/archives/javascript/webpack/"},{"categories":["etc"],"content":" 고가의 ipad 키보드를 샀으니 이제 ipad로 짜세있게 개발을 해봐야겠다.ㅎㅎㅎ code-server를 이용하여 ipad에서 vscode 개발하기 VS code-server를 이용하면 외부에서 접속이 가능한 개발환경을 만들 수 있다. ","date":"2022-01-11","objectID":"/archives/etc/code-server/:0:0","tags":["ipad","code-server","vscode"],"title":"code-server를 이용하여 ipad에서 vscode로 개발하기","uri":"/archives/etc/code-server/"},{"categories":["etc"],"content":"1. 가상 인스턴스 서버 생성 code-server를 사용하려면 원격 서버가 필요하다. 나는 퍼니오(https://www.fun25.co.kr/)라는 가상서버 호스팅 서비스를 이용하고 있다. 클라우드 무료로 사용할 수 있는건 모두 다 사용해본 관계로… 퍼니오에서 저렴하게 구매해서 사용하고 있다. 인스턴스 요구 사항은 다음과 같다. 웹소켓이 가능한 linux 머신, 1 GB RAN, 2 CPUs ","date":"2022-01-11","objectID":"/archives/etc/code-server/:1:0","tags":["ipad","code-server","vscode"],"title":"code-server를 이용하여 ipad에서 vscode로 개발하기","uri":"/archives/etc/code-server/"},{"categories":["javascript"],"content":"Web worker Web Worker 는 메인 스레드와 분리된 별도의 백그라운드 스레드에서 스크립트를 실행할 수 있는 기술이다. UI 스레드와는 별개의 스레드를 실행시켜 사용자 인터페이스를 방해하지않고 작업을 수행할 수 있다. ","date":"2021-09-21","objectID":"/archives/javascript/webworker/:0:0","tags":["javascript","web"],"title":"Multi Thread","uri":"/archives/javascript/webworker/"},{"categories":["javascript"],"content":"Web worker scope Web worker는 메인 스레드와 별도의 worker 스레드를 갖는다. 메인 스레드에서 window 객체는 GlobalScope 이지만 worker 스레드에서는 별도의 스코프 범위를 갖는다. Worker 종류에 따른 Scope worker 스레드는 메인 스레드 window 객체에 액세스할 수 있는 권한이 없기 때문에 window의 메서드나 DOM을 직접적으로 제어할 수 없다. window 의 DOM에 접근하기 위해서는 postMessage() 메서드를 이용하여 메세지를 보내고 onmessage 이벤트 핸들러를 통해 제어할 수 있다. ","date":"2021-09-21","objectID":"/archives/javascript/webworker/:1:0","tags":["javascript","web"],"title":"Multi Thread","uri":"/archives/javascript/webworker/"},{"categories":["javascript"],"content":"Worker 종류 Dedicated workers : 단일 스크립트 환경을 이용하는 worker. 처음 worker를 생성한 context 영역에서만 사용이 가능하다. Shared workers : worker가 같은 도메인 내에 존재하는 모든 Thread에서 사용이 가능하다. 다른 컨텍스트 (iframe, 다른 탭 등)에서도 접근이 가능하다. script에서 worker와 port 를 통해서 통신한다. Service workers : 브라우저가 백그라운드 영역에서 실행하는 스크립트로 Service worker의 생명주기는 웹페이지와는 별개로 작동한다. 웹페이지 또는 사용자 인터랙션이 필요하지 않는 기능을 제공하고 있다. 오프라인 환경, 푸시 알림, 백그라운드 동기화 등의 기능을 지원한다. ","date":"2021-09-21","objectID":"/archives/javascript/webworker/:2:0","tags":["javascript","web"],"title":"Multi Thread","uri":"/archives/javascript/webworker/"},{"categories":["javascript"],"content":"Service Worker Web worker의 한 종류이다. 웹 페이지의 라이프 사이클과는 별개로 동작하기 때문에 웹페이지가 닫혀도 자동으로 비활성화 되지 않는다. 웹 애플리케이션, 브라우저 및 네트워크 사이에 proxy 서버 역할을 한다. 주로 오프라인, 푸시 알림 및 백그라운드 동기화 API를 위해 사용한다. 보안상의 이유로 localhost 이외에는 HTTPS 통신을 해야한다. multi-threading 의 기능을 사용하기 위해 설계된 것이 아니므로 몇가지 기능들이 제한되어 있다. EventSource 나WebSocket 기능도 제한되어 있다. ","date":"2021-09-21","objectID":"/archives/javascript/webworker/:3:0","tags":["javascript","web"],"title":"Multi Thread","uri":"/archives/javascript/webworker/"},{"categories":["golang"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 정리하였습니다. ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:0:0","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"1. 인터페이스 정의 ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:1:0","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"인터페이스 선언 인터페이스 선언은 type을 쓴 뒤 인터페이스 명을 쓰고 interface 키워드를 쓴다. 그런 뒤 {} 블록 안에 인터페이스에 포함된 메서드 집합을 써준다. type DuckInterface interface { Fly() Walk(distance int) int } 유의사항 메서드는 반드시 메서드명이 있어야한다. 매개변수와 반환이 다르더라도 이름이 같은 메서드는 있을 수 없다. 인터페이스에서는 메서드 구현을 포함하지 않는다. 인터페이스 선언 예제 package main import \"fmt\" type Stringer interface { String() string } type Student struct { Name string Age int } func (s Student) String() string { return fmt.Sprintf(\"안녕! 나는 %d살 %s라고 해.\", s.Age, s.Name) } func main() { student := Student{\"쳘수\", 5} var stringer Stringer stringer = student fmt.Printf(\"%s\\n\", stringer.String()) } ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:1:1","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"2. 인터페이스를 사용하는 이유 인터페이스는 객체 지향 프로그래밍에서 아주 중요한 역할을 한다. 인터페이스를 이용하면 구체화된 객체가 아닌 인터페이스만 가지고 메서드를 호출할 수 있기 때문에 큰 코드 수정 없이 필요에 따라 구체화 된 객체로 바꿔 사용할 수 있다. ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:2:0","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"추상화 계층 추상화(abstraction) : 내부 동작을 감춰서 서비스를 제공하는 쪽과 사용하는 쪽 모두에게 자유를 주는 방식. 인터페이스는 추상화를 제공하는 추상화 계층(abstraction layer) 이다. 인터페이스를 사용하여 서로 결합하고 의존성을 줄이는 것을 디커플링(decoupling) 이라고 한다. 구체화된 타입으로 상호작용하는게 아니라 추상화된 관계로 상호작용함으로써 결합도를 낮추고 의존관계를 줄이므로써 이후 유지 보수를 용이하 하고 유연성을 확보할 수 있다. ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:2:1","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"3. 덕 타이핑 Go 언어에서는 어떤 타입이 인터페이스를 포함하고 있는지 여부를 결정할 때 덕 타이핑(duck typing) 방식을 사용한다. 덕 타이핑 방식은 타입 선언 시 인터페이스 구현 여부를 명시적으로 나타낼 필요 없이 인터페이스에 정의한 메서드 포함 여부로만 결정하는 방식이다. Stringer 인터페이스를 정의 type Stringer interface { String() string } Stringer 인터페이스 포함 여부를 명시적으로 나타내지 않아도 String() 메서드를 포함하는 것 만으로 Stringer 인터페이스를 사용할 수 있다. type Student struct { ... } func (s *Student) String() string { ... } 만약 Go 언어가 덕 타이핑을 지원하지 않았더라면, implements 와 같은 키워드를 써서 명시적으로 Stringer 구현 여부를 표시해야 했을 것이다. type Student struct implements Stringer { ... } ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:3:0","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"덕 타이핑의 장점 서비스 사용자 중심의 코딩을 할 수 있다. 덕 타이핑은 인터페이스 구현 여부를 타입 선언에서 하는게 아니라 사용될 때 해당 타입이 인터페이스에 정의된 메서드를 포함했는지 여부로 결정한다. 따라서 서비스 제공자가 인터페이스를 정의 할 필요 없이 구체화된 객체만 제공하고 서비스 이용자가 필요에 따라 그때그때 인터페이스를 정의해서 사용할 수 있다. ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:3:1","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"4. 인터페이스 기능 더 알기 포함된 인터페이스 빈 인터페이스 인터페이스 기본값 ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:4:0","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"인터페이스를 포함하는 인터페이스 구조체에서 다른 구조체를 포함된 필드로 가질 수 있듯이 인터페이스도 다른 인터페이스를 포함할 수 있다. 이를 포함된 인터페이스라고 부른다. // 1) Read()와 Close() 메서드를 포함한 Reader 인터페이스 type Reader interface { Read() (n int, err error) Close() error } // 2) Write() 메서드와 Close() 메서드를 포함한 Writer 인터페이스 type Writer interface { Write() (n int, err error) Close() error } // 3) Reader, Writer 인터페이스의 메서드 집합을 모두 포함한 ReadWriter 인터페이스 type ReadWriter interface { Reader // Reader의 메서드 집합을 포함 Writer // Writer의 메서드 집합을 포함 } ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:4:1","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"빈 인터페이스 interface{}는 메서드를 가지고 있지 않은 빈 인터페이이다. 가지고 있어야 할 메서드가 하나도 없기 때문에 모든 타입이 빈 인터페이스로 쓰일 수 있다. 빈 인터페이스는 어떤 값이든 받을 수 있는 함수, 메서드, 변수값을 만들 때 사용한다. package main import \"fmt\" func PrintVal(v interface{}) { switch t := v.(type) { case int: fmt.Printf(\"v is int %d\\n\", int(t)) case float64: fmt.Printf(\"v is float64 %f\\n\", t) case string: fmt.Printf(\"v is string %s\\n\", string(t)) default: fmt.Printf(\"Not supported Type : %T: %v\", t, t) } } type Student struct { Age int } func main() { PrintVal(10) PrintVal(3.14) PrintVal(\"Hello\") PrintVal(Student{15}) } ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:4:2","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"인터페이스 기본값 nil 인터페이스 변수의 기본값은 nil이다. package main type Attacker interface { Attack() } func main() { var att Attacker att.Attack() // Error! att의 초기값이 없기 때문에 기본값인 nil } invalid memory address로 비정상적인 메모리 주소에 접근해서 프로그램 실행중에 런타임 에러가(runtime error) 발생한다. ","date":"2021-08-23","objectID":"/archives/golang/go-interface/:4:3","tags":["go","golang"],"title":"Go 인터페이스","uri":"/archives/golang/go-interface/"},{"categories":["golang"],"content":"설치할 것들 Go Git Visual Studio Code ","date":"2021-08-20","objectID":"/archives/golang/tucker-go-section1/:1:0","tags":["go","golang"],"title":"[Tucker]Go 개발 환경 설정 - 윈도우즈","uri":"/archives/golang/tucker-go-section1/"},{"categories":["golang"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 정리하였습니다. ","date":"2021-08-20","objectID":"/archives/golang/go-string/:0:0","tags":["go","golang"],"title":"Go 문자열 구조","uri":"/archives/golang/go-string/"},{"categories":["golang"],"content":"string 구조 string 타입은 Go 언어에서 제공하는 내장 타입으로 그 내부구현은 감추어져 있다. 하지만 reflect 패키지 안의 StringHeader 구조체를 통해 내부구조를 엿볼 수 있다. // StringHeader is the runtime representation of a string. // It cannot be used safely or portably and its representation may // change in a later release. // Moreover, the Data field is not sufficient to guarantee the data // it references will not be garbage collected, so programs must keep // a separate, correctly typed pointer to the underlying data. type StringHeader struct { Data uintptr Len int } string은 필드가 2개인 구조체이다. Data 필드는 unitptr 타입으로 문자열 데이터가 있는 메모리 주소를 나타내는 일종의 포인터이다. Len 필드는 문자열의 길이를 나타낸다. ","date":"2021-08-20","objectID":"/archives/golang/go-string/:1:0","tags":["go","golang"],"title":"Go 문자열 구조","uri":"/archives/golang/go-string/"},{"categories":["golang"],"content":"string 끼리 대입하기 package main import ( \"fmt\" \"reflect\" \"unsafe\" ) func main() { str1 := \"Hello World!\" str2 := str1 stringHeader1 := (*reflect.StringHeader)(unsafe.Pointer(\u0026str1)) stringHeader2 := (*reflect.StringHeader)(unsafe.Pointer(\u0026str2)) fmt.Println(stringHeader1) fmt.Println(stringHeader2) } Result \u0026{17598669 12} \u0026{17598669 12} str1과 str2의 주소값은 동일하다. str1 변수값을 str2로 복사했을때 str1의 값이 str2로 복사되어 같은 메모리 데이터를 가르키게 된다. ","date":"2021-08-20","objectID":"/archives/golang/go-string/:2:0","tags":["go","golang"],"title":"Go 문자열 구조","uri":"/archives/golang/go-string/"},{"categories":["golang"],"content":"문자열은 불변이다 문자열은 불변(immutable)이다. string 타입이 가리키는 문자열의 일부만 변경할 수 없다. var str string = \"Hello World\" str = \"How are you?\" str[2] = 'a' // Error! “How are you?” 문자열이 담긴 메모리주소로 str의 Data 포인터 값이 변경된다. Len 값 또한 문자열 길이에 맞게 변경된다. 문자열은 불변이라는 특성을 갖기 때문에 문자열 일부는 변경이 불가능하다. ","date":"2021-08-20","objectID":"/archives/golang/go-string/:3:0","tags":["go","golang"],"title":"Go 문자열 구조","uri":"/archives/golang/go-string/"},{"categories":["golang"],"content":"문자열 합산 Go 언어에서 string 타입 간 합 연산을 지원한다. 합 연산을 하면 두 문자열이 하나로 합쳐진다. package main import ( \"fmt\" \"reflect\" \"unsafe\" ) func main() { var str string = \"Hello\" stringHeader := (*reflect.StringHeader)(unsafe.Pointer(\u0026str)) addr1 := stringHeader.Data str += \" World\" addr2 := stringHeader.Data str += \" Welcome!\" addr3 := stringHeader.Data fmt.Println(str) fmt.Printf(\"addr1:\\t%x\\n\", addr1) fmt.Printf(\"addr2:\\t%x\\n\", addr2) fmt.Printf(\"addr3:\\t%x\\n\", addr3) } Result Hello World Welcome! addr1: 10c9543 addr2: c000118000 addr3: c00011a000 모든 주소값이 다 다르게 출력되었다. Go 언어는 기존 문자열 메모리를 건드리지 않고, 새로운 메모리 공간을 만들어 두 문자열을 합치기 때문에 string 합 연산 이후 주소값이 변경된다. string의 합 연산을 빈번하게 사용하면 메모리가 낭비되므로 strings 패키지의 Builder를 이용하는 것이 좋다. ","date":"2021-08-20","objectID":"/archives/golang/go-string/:4:0","tags":["go","golang"],"title":"Go 문자열 구조","uri":"/archives/golang/go-string/"},{"categories":["golang"],"content":"strings 패키지의 Builder를 이용한 문자열 합 연산 package main import ( \"fmt\" \"strings\" ) func ToUpper1(str string) string { var rst string for _, c := range str { if c \u003e= 'a' \u0026\u0026 c \u003c= 'z' { rst += string('A' + (c - 'a')) } else { rst += string(c) } } return rst } func ToUpper2(str string) string { var builder strings.Builder for _, c := range str { if c \u003e= 'a' \u0026\u0026 c \u003c= 'z' { builder.WriteRune('A' + (c - 'a')) } else { builder.WriteRune(c) } } return builder.String() } func main() { var str string = \"Hello World\" fmt.Println(ToUpper1(str)) fmt.Println(ToUpper2(str)) } ","date":"2021-08-20","objectID":"/archives/golang/go-string/:4:1","tags":["go","golang"],"title":"Go 문자열 구조","uri":"/archives/golang/go-string/"},{"categories":["golang"],"content":"왜 문자열은 불변 원칙을 지키려 할까? 빈번한 합 연산시 메모리가 낭비되는 데도 문자열 불변 원칙을 지키려할까? 가장 큰 이유는 예기치 못한 버그를 방지하기 위해서다. string 타입이 복사 될때 문자열 데이터가 복사되는 것이 아니라 Data(주소값), Len 필드값만 복사된다. 만약 문자열 불변 원칙이 없어서 문자열 값이 일부가 변경된다면 참조하고 있는 다른 곳에서 모두 변경된 문자열을 가리키게 되버린다. string 변수값이 코드 전반에 걸쳐 여러 곳으로 복사되었다면 언제 어디서 문자열이 변경되었는지 알 수없다. ","date":"2021-08-20","objectID":"/archives/golang/go-string/:5:0","tags":["go","golang"],"title":"Go 문자열 구조","uri":"/archives/golang/go-string/"},{"categories":["golang"],"content":" 음.. 완벽하게 이해하지는 못했다 😇😇😇 ","date":"2021-08-19","objectID":"/archives/golang/go-escape-analysis/:0:0","tags":["go","golang"],"title":"Go 스택 메모리와 힙 메모리","uri":"/archives/golang/go-escape-analysis/"},{"categories":["golang"],"content":"스택 메모리와 힙 메모리 대부분의 프로그래밍 언어는 메모리를 할당할 때 스택 메모리 영역 또는 힙 메모리 영역을 사용한다. 함수 내부에서만 사용되는 값은 스택 메모리에 할당된다. 함수 외부로 공개되는 메모리 공간은 힙 메모리 영역에 할당된다. C/C++ 언어에서는 malloc() 함수를 직접 호출해서 힙 메모리 공간을 할당한다. 자바의 경우 클래스 타입을 힙에, 기본 타입을 스택에 할당한다. Go 언어는 이스케이프 분석(escape analysis) 을 해서 어느 메모리에 할당할지 결정한다. ","date":"2021-08-19","objectID":"/archives/golang/go-escape-analysis/:1:0","tags":["go","golang"],"title":"Go 스택 메모리와 힙 메모리","uri":"/archives/golang/go-escape-analysis/"},{"categories":["golang"],"content":"이스케이프 분석(escape analysis) GC 컴파일러는 함수와 패키지를 넘어 전역적으로 탈출 검사를 수행한다. 빌드 시 아래 옵션을 사용하면 이스케이프 분석 정보를 확인할 수 있다. go build -gcflags=\"-m\" package main import \"fmt\" type User struct { Name string Age int } func stayOnStack() User { u := User{ Name : \"chunsik\", Age : 5, } return u } func escapeToHeap() *User { u := User{ Name : \"chunsik\", Age : 5, } // 탈출 분석으로 u 메모리가 사라지지 않음. return \u0026u } func main() { fmt.Println(stayOnStack()) fmt.Println(escapeToHeap()) } stayOnStack()의 변수 u는 객체의 사본이 리턴되었다. 컴파일 할 때 구조체 u의 크기를 알 수 있기에 컴파일러는 u를 스택에 저장한다. escapeToHeap()는 값을 리턴하는 것이 아니라 값의 포인터(주소)를 리턴한다. u변수의 인스턴스가 함수 외부로 공개되는 것을 분석해내에 u를 스택 메모리가 아닌 힙 메모리에 할당한다. ","date":"2021-08-19","objectID":"/archives/golang/go-escape-analysis/:1:1","tags":["go","golang"],"title":"Go 스택 메모리와 힙 메모리","uri":"/archives/golang/go-escape-analysis/"},{"categories":["golang"],"content":"참고 Tucker의 Go 언어 프로그래밍 The Ultimate Go Study Guide ","date":"2021-08-19","objectID":"/archives/golang/go-escape-analysis/:2:0","tags":["go","golang"],"title":"Go 스택 메모리와 힙 메모리","uri":"/archives/golang/go-escape-analysis/"},{"categories":["golang"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 정리하였습니다. ","date":"2021-08-19","objectID":"/archives/golang/go-constant-literal/:0:0","tags":["go","golang"],"title":"Go 상수와 리터럴","uri":"/archives/golang/go-constant-literal/"},{"categories":["golang"],"content":"상수와 리터럴 ","date":"2021-08-19","objectID":"/archives/golang/go-constant-literal/:1:0","tags":["go","golang"],"title":"Go 상수와 리터럴","uri":"/archives/golang/go-constant-literal/"},{"categories":["golang"],"content":"상수 (Constant) 상수는 변하지 않는 값을 의미한다. 한번 초기화 하면 값을 바꿀 수 없다. 정수, 실수, 문자열 등 기본 타입값들로만 상수로 선언될 수 있다. 구조체, 배열 등 기본 타입이 아닌 타입에는 상수를 사용할 수 없다. 상수로 사용될 수 있는 타입 불리언 룬 정수 실수 복소수 문자열 상수는 값으로만 동작한다. 변수가 값, 이름, 타입, 메모리 주소 4가지 속성을 가지는 반면 상수는 값, 이름, 타입 3가지 속성만 가진다. const C int = 10 fmt.Println(\u0026C) // 에러 상수는 값으로만 동작. 주소값에 접근할 수 없다. ","date":"2021-08-19","objectID":"/archives/golang/go-constant-literal/:1:1","tags":["go","golang"],"title":"Go 상수와 리터럴","uri":"/archives/golang/go-constant-literal/"},{"categories":["golang"],"content":"리터럴 (Literal) 리터럴은 고정된 값, 데이터 그 자체를 의미한다. var str string = \"Hello World\" var i int = 0 i = 30 “Hello World”, 0, 30 처럼 고정된 값 자체로 쓰인 데이터가 바로 리터럴이다. ","date":"2021-08-19","objectID":"/archives/golang/go-constant-literal/:1:2","tags":["go","golang"],"title":"Go 상수와 리터럴","uri":"/archives/golang/go-constant-literal/"},{"categories":["golang"],"content":"Go에서 상수와 리터럴 Go 언어에서는 상수는 리터럴과 같이 취급한다. 그래서 컴파일 될 때 상수는 리터럴로 변환되어 실행 파일에 쓰인다. 상수 표현식 역시 컴파일 타임에 실제 결과값 리터럴로 변하기 때문에 상수 표현식 계산에 CPU 자원을 사용하지 않는다. const PI = 3.14 var a int = PI * 100 위의 구문은 컴파일 타임에 아래와 같이 변환된다. var a int = 314 상수의 메모리 주소값에 접근할 수 없는 이유 역시 컴파일 타임에 리터럴로 전환되어서 실행 파일에 값 형태로 쓰이기 때문이다. 그래서 동적 할당 메모리 영역을 사용하지 않는다. ","date":"2021-08-19","objectID":"/archives/golang/go-constant-literal/:1:3","tags":["go","golang"],"title":"Go 상수와 리터럴","uri":"/archives/golang/go-constant-literal/"},{"categories":["golang"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 참고 및 정리해서 작성하였습니다. 실수 끼리의 비교연산에서 예기치 않은 결과가 나올 때가 있다. 0.1 + 0.2 = 0.3의 결과를 예상하였지만 실제 출력값은 0.30000000000000004가 출력되었다. package main import \"fmt\" func main() { var a float64 = 0.1 var b float64 = 0.2 var c float64 = 0.3 fmt.Printf(\"%f + %f == %f : %v\\n\", a, b, c, a+b == c) fmt.Println(a+b) } Result 0.100000 + 0.200000 == 0.300000 : false 0.30000000000000004 ","date":"2021-08-18","objectID":"/archives/golang/go-comparison-operator/:0:0","tags":["go","golang"],"title":"실수 오차","uri":"/archives/golang/go-comparison-operator/"},{"categories":["golang"],"content":"실수 오차 컴퓨터에서는 실수값을 표현할 때 지수부와 소수부로 나누어서 표현한다. 컴퓨터는 지수부와 소수부가 10진수 기준이 아니라 2진수 기준으로 되어 있다. 그렇기 때문에 10진수를 정확히 표현하기 어려운 문제가 있다. 예를들어 0.375는 0.3 + 0.07 + 0.005로 나타낼 수 있고, 십진수로 표현하면 다음과 같다. $3 * 10^{-1} + 7 * 10^{-2} + 5 * 10^{-3} $ 컴퓨터의 경우 2진수 숫자 체계를 다루므로, $1 * 2^{-2} + 1 * 2^{-3}$ 로 나타낼 수 있다. ($2^{-1} = 0.5, 2^{-2} = 0.25, 2^{-3} = 0.125$) 대부분의 소수점 이하 숫자들은 2의 음의 승수료 표현하기가 어렵다. 그래서 0.376값은 float32 타입으로 최대한 가까운 근사값인 0.375999987125396728515625로 표현이 된다. 이렇게 실수를 근사값으로 표현하면서 발생되는 문제를 부동 소수점 반올림 오차(rounding error) 라고도 한다. 두 실수끼리 같은지 다른지 비교하기 위해서는 어떻게 할 수 있을까? ","date":"2021-08-18","objectID":"/archives/golang/go-comparison-operator/:1:0","tags":["go","golang"],"title":"실수 오차","uri":"/archives/golang/go-comparison-operator/"},{"categories":["golang"],"content":"1. 작은 오차 무시하기 아주 작은 오차는 무시하는 방법으로 비교해보자. 무시할 오차 한계를 정의하여 그 값을 무시하고 비교한다. package main import \"fmt\" const epsilon = 0.00001 // 매우 작은 상수값을 선언. 무시할 오차 한계를 정의 // 두 값의 차이가 epsilon 비교해서 작을 경우 두 값이 같다고 간주한다. func equal(a, b float64) bool { if a \u003e b { if a - b \u003c= epsilon { return true } else { return false } } else { if b - a \u003c= epsilon { return true } else { return false } } } func main() { var a float64 = 0.1 var b float64 = 0.2 var c float64 = 0.3 fmt.Printf(\"%0.18f + %0.18f = %0.18f\\n\", a, b, a + b) fmt.Printf(\"%0.18f == %0.18f : %v\\n\", c, a + b, equal((a + b), c)) a = 0.0000000000004 b = 0.0000000000002 c = 0.0000000000007 fmt.Printf(\"%g == %g : %v\\n\", c, a+b, equal((a+b), c)) } Result 0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044 0.299999999999999989 == 0.300000000000000044 : true 7e-13 == 6.000000000000001e-13 : true 문제점 오차의 기준을 명확히 정할 수 없다. float64의 경우 $10^{-308}$ ~ $10^{308}$ 까지 매우 큰 값의 범위를 갖는데, 앞서 사용한 상수 epsilon의 경우 0.0000234에 비하면 무시할 만큼 크게 작지 않은 값이다. a,b,c의 값을 매우 작은 값으로 바꾸게 되면 7e-13 == 6.000000000000001e-13 : true 결과처럼 서로 같다는 문제가 발생한다. ","date":"2021-08-18","objectID":"/archives/golang/go-comparison-operator/:1:1","tags":["go","golang"],"title":"실수 오차","uri":"/archives/golang/go-comparison-operator/"},{"categories":["golang"],"content":"2. 최소 비트 차이 비교 package main import ( \"fmt\" \"strings\" ) func main() { var a float64 = 0.1 var b float64 = 0.2 var c float64 = 0.3 fmt.Printf(\"float64 a : %0.60f\\n\", a) fmt.Printf(\"float64 b : %0.60f\\n\", b) fmt.Println(strings.Repeat(\"-\", 100)) fmt.Printf(\"float64 a+b : %0.60f\\n\", a+b) fmt.Printf(\"float64 0.3 : %0.60f\\n\", c) } Result float64 a : 0.100000000000000005551115123125782702118158340454101562500000 float64 b : 0.200000000000000011102230246251565404236316680908203125000000 —————————————————————————————————- float64 a+b : 0.300000000000000044408920985006261616945266723632812500000000 float64 0.3 : 0.299999999999999988897769753748434595763683319091796875000000 실수 0.1의 근사값(float64) 0.1000000000000000055511151231257827021181583404541015625과 실수 0.2의 근사값(float64) 0.200000000000000011102230246251565404236316680908203125이 덧셈 계산이 발생하여 0.3000000000000000444089209850062616169452667236328125 이라는 결과가 출력되었다. 실수 0.3의 근사값(float64) 0.299999999999999988897769753748434595763683319091796875으로 출력되었다. 두 값 모두 0.3과 정확히 같지는 않지만 0.3보다 아주 작고 혹은 0.3 보다 아주 크다. 두 값은 2진수로 표현했을 때 마지막 1 비트 차이밖에 나지 않는다. 즉 0.3을 표현할 수 있는 실수 타입 범위에서 가장 작은 차이다. 만약 어떤 값이 이 두값의 사이라면 0.3과 같다고 간주할 수 있다. Go lang에서는 math 패키지에 Nextafter() 함수를 통해 x에서 y를 향한 1비트만 조정한 값을 반환한다. func Nextafter(x, y float64) (r float64) x\u003ey : x보다 1비트 감소시킨 값을 반환 x\u003cy : x보다 1비트 증가시킨 값을 반환 x=y : x 즉 가장 작은 오차만큼을 y를 향해서 1비트를 조정하여 실수값의 대소를 비교할 수 있다. Nextafter 함수를 이용한 실수값 대소비교 package main import ( \"fmt\" \"math\" ) func equal(a, b float64) bool { return math.Nextafter(a, b) == b } func main() { var a float64 = 0.1 var b float64 = 0.2 var c float64 = 0.3 fmt.Printf(\"%0.18f + %0.18f = %0.18f\\n\", a, b, a + b) fmt.Printf(\"%0.18f == %0.18f : %v\\n\", c, a+b, equal(a+b, c)) a = 0.0000000000004 b = 0.0000000000002 c = 0.0000000000007 fmt.Printf(\"%g == %g : %v\\n\", c, a+b, equal(a+b, c)) } Result 0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044 0.299999999999999989 == 0.300000000000000044 : true 7e-13 == 6.000000000000001e-13 : false ","date":"2021-08-18","objectID":"/archives/golang/go-comparison-operator/:1:2","tags":["go","golang"],"title":"실수 오차","uri":"/archives/golang/go-comparison-operator/"},{"categories":["golang"],"content":"3. math/big 패키지의 Float 객체 이용 제작하는 프로그램이 금융 프로그램이라면 math/big 패키지에서 제공하는 Float 객체를 사용해야 한다. 정밀도를 직접 조절 할 수 있기 때문에 정밀도를 높여 더 정확한 수치 계산이 가능하다. math/big 패키지의 Float를 이용하여 실수 비교 예제 package main import ( \"fmt\" \"math/big\" ) func main() { a, _ := new(big.Float).SetString(\"0.1\") b, _ := new(big.Float).SetString(\"0.2\") c, _ := new(big.Float).SetString(\"0.3\") d := new(big.Float).Add(a, b) fmt.Println(a, b, c, d) fmt.Println(c.Cmp(d)) } Result 0.1 0.2 0.3 0.3 0 ","date":"2021-08-18","objectID":"/archives/golang/go-comparison-operator/:1:3","tags":["go","golang"],"title":"실수 오차","uri":"/archives/golang/go-comparison-operator/"},{"categories":["etc"],"content":" 할때마다 까먹는다. ","date":"2021-08-13","objectID":"/archives/etc/telegrambot/:0:0","tags":["telegram"],"title":"텔레그램 봇","uri":"/archives/etc/telegrambot/"},{"categories":["etc"],"content":"텔레그램 봇 만들기 1. 봇아빠 채팅방에 접속 https://t.me/BotFather 혹은 @BotFather 검색하여 채팅방 접속 2. BotFather 채팅방에서 봇 생성 명령어를 입력한다. 채팅창에 /newbot을 입력한다. 3. 텔레그램 봇 이름을 입력한다. 이름은 _bot으로 끝나야 한다. 4. 다시 입력 한번 더 bot 이름을 입력하면 봇 주소와 API 토큰 값을 얻을 수 있다. 5. 봇 채팅방 접속 후 시작 버튼 클릭 6. 봇 채팅방 chat id 얻기 봇 채팅방에서 아무 메세지나 입력한다. 브라우저에서 https://api.telegram.org/bot`봇토큰`/getUpdates 으로 접속하면 JSON 데이터에서 chat 아이디를 확인할 수 있다. chat 객체에 id 값 9자리가 봇챗방 아이디 이다. { \"ok\": true, \"result\": [ { \"update_id\": 556815269, \"message\": { \"message_id\": 3, \"from\": { \"id\": 1719000000, ... }, \"chat\": { \"id\": 1719000000, ... }, \"date\": 1628829234, \"text\": \"/start\", \"entities\": [ { \"offset\": 0, \"length\": 6, \"type\": \"bot_command\" } ] } } ] } ","date":"2021-08-13","objectID":"/archives/etc/telegrambot/:1:0","tags":["telegram"],"title":"텔레그램 봇","uri":"/archives/etc/telegrambot/"},{"categories":["etc"],"content":"2. Private 채팅방 텔레그램 채널 ID 알아내기 새로운 private 채널을 생성한다. 채널의 초대링크를 복사한다. @username_to_id_bot 채팅방에 접속하여 내 초대 링크를 채팅창에 입력한다. IDBot계정이 나의 private 채팅방의 챗방 ID를 리턴한다. 메세지 보내기 API 테스트! https://api.telegram.org/bot\u003c봇토큰\u003e/sendmessage?chat_id=-1001183952507\u0026text=에쑤빠는나야두리될수없숴 성공쓰 ","date":"2021-08-13","objectID":"/archives/etc/telegrambot/:2:0","tags":["telegram"],"title":"텔레그램 봇","uri":"/archives/etc/telegrambot/"},{"categories":["etc"],"content":"참고링크 How to obtain the chat_id of a private Telegram channel? ","date":"2021-08-13","objectID":"/archives/etc/telegrambot/:3:0","tags":["telegram"],"title":"텔레그램 봇","uri":"/archives/etc/telegrambot/"},{"categories":["docker/kubernetes"],"content":" 기록쓰 기록쓰 👻👻👻👻 ","date":"2021-08-12","objectID":"/archives/docker-kubernetes/docker-oracle/:0:0","tags":["docker","oracle"],"title":"docker를 사용하여 oracle 12c 세팅하기","uri":"/archives/docker-kubernetes/docker-oracle/"},{"categories":["docker/kubernetes"],"content":"Oracle 12c 공식 이미지 다운로드 https://hub.docker.com/_/oracle-database-enterprise-edition?tab=resources 공식 이미지를 다운로드 후 Preceed to Checkout 버튼을 클릭하여 동의 정보를 입력한다. 대충 입력쓰… ","date":"2021-08-12","objectID":"/archives/docker-kubernetes/docker-oracle/:0:1","tags":["docker","oracle"],"title":"docker를 사용하여 oracle 12c 세팅하기","uri":"/archives/docker-kubernetes/docker-oracle/"},{"categories":["docker/kubernetes"],"content":"도커 이미지 다운로드 후 실행 8080은 많이 사용하니까 각각 8282, 1522로 매핑하였다. # docker image pull docker pull store/oracle/database-enterprise:12.2.0.1 # docker run docker run -d -p 8282:8080 -p 1522:1521 --name oracle12c store/oracle/database-enterprise:12.2.0.1 ","date":"2021-08-12","objectID":"/archives/docker-kubernetes/docker-oracle/:0:2","tags":["docker","oracle"],"title":"docker를 사용하여 oracle 12c 세팅하기","uri":"/archives/docker-kubernetes/docker-oracle/"},{"categories":["docker/kubernetes"],"content":"유저 생성 및 권한 부여 sysdba로 sqlplus 접속 docker exec -it oracle12c bash -c \"source /home/oracle/.bashrc; sqlplus sys/Oradoc_db1@ORCLCDB as sysdba\" 사용할 유저 생성 bluetape이라는 유저 생성후 “afternoon” 지정 CREATE USER bluetape IDENTIFIED BY afternoon; ORA-65096: invalid common user or role name Oracle 12c에서는 사용자 생성 방식이 조금 변경되었다. 이전 생성 스크립트로 생성시 ORA-65096: invalid common user or role name 가 발생한다. 해결방안 1 : 계정앞에 C##키워드를 붙여 준다. CREATE USER c##bluetape IDENTIFIED BY afternoon; 해결방안 2 : 현재 세션에 설정 변경 ALTER SESSION SET \"_ORACLE_SCRIPT\" = TRUE; ","date":"2021-08-12","objectID":"/archives/docker-kubernetes/docker-oracle/:0:3","tags":["docker","oracle"],"title":"docker를 사용하여 oracle 12c 세팅하기","uri":"/archives/docker-kubernetes/docker-oracle/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section12/:0:0","tags":["go","golang"],"title":"Section 12 : 패키지 고급","uri":"/archives/golang/easy-golang-section12/"},{"categories":["Easy Go"],"content":"12.1 사용자 패키지 제작 및 문서화 ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section12/:1:0","tags":["go","golang"],"title":"Section 12 : 패키지 고급","uri":"/archives/golang/easy-golang-section12/"},{"categories":["Easy Go"],"content":"12.1.1 사용자 패키지 작성 및 문서화 go 에서 패키지는 폴더명(디렉토리명)으로 접근한다. → 그러므로 명확하게 지정해야 한다. 사용자 패키지를 문서화 할 때 main 패키지를 제외하고 package 문서에 등록된다. 기본적으로 GOROOT 의 패키지에서 검색 → 없으면 GOPATH 패키지를 검색한다. go install 명령어 : GOPATH/pkg 에 패키지 등록 godoc -http:=6060 으로 본인 패키지 메소드 및 주석을 확인 할 수 있다. // 사용자 패키지 작성 및 문서화 예제 package main import ( \"fmt\" oper \"section12/arithmetic\" // alias 사용 (패키지 중복 또는 약자로 사용) ) func main() { // 패키지 사용 예제(사칙연산) nums := oper.Numbers{ X : 100, Y : 10} fmt.Println(\"Package Used(1) : \", nums.Plus()) fmt.Println(\"Package Used(2) : \", nums.Minus()) fmt.Println(\"Package Used(3) : \", nums.Mulit()) fmt.Println(\"Package Used(4) : \", nums.Divide()) fmt.Println(\"Package Used(5) : \", nums.SquarePlus()) fmt.Println(\"Package Used(6) : \", nums.SquareMinus()) } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section12/:1:1","tags":["go","golang"],"title":"Section 12 : 패키지 고급","uri":"/archives/golang/easy-golang-section12/"},{"categories":["Easy Go"],"content":"12.2 외부 저장소 패키지 설치 및 사용 ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section12/:2:0","tags":["go","golang"],"title":"Section 12 : 패키지 고급","uri":"/archives/golang/easy-golang-section12/"},{"categories":["Easy Go"],"content":"12.2.1 사용자 패키지 설치 및 활용 외부 저장소에 저장된 패키지를 설치하여 사용할 수 있다. import 선언 후 폴더로 이동하여 go get 명령어로 설치한다. go get 패키지 주소 로 설치한다. package main import ( \"github.com/tealeg/xlsx\" ) func main() { xfile := \"section12/sample.xlsx\" xlFile, err := xlsx.OpenFile(xfile) if err != nil { panic(\"Excel Loads Error!\") } for _, sheet := range xlFile.Sheets { for _, row := range sheet.Cols { for _, cell := range row.Cells { text := cell.st } } } } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section12/:2:1","tags":["go","golang"],"title":"Section 12 : 패키지 고급","uri":"/archives/golang/easy-golang-section12/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section11/:0:0","tags":["go","golang"],"title":"Section 11 : Go 파일 입출력","uri":"/archives/golang/easy-golang-section11/"},{"categories":["Easy Go"],"content":"11.1 파일 입출력 ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section11/:1:0","tags":["go","golang"],"title":"Section 11 : Go 파일 입출력","uri":"/archives/golang/easy-golang-section11/"},{"categories":["Easy Go"],"content":"11.1.1 os 패키지 - 파일 읽기, 쓰기 Go에서 파일을 읽고 쓰기 위해 Go 표준 패키지인 os 패키지를 사용할 수 있다. os.Open() : 기존 파일 열기 os.Create() : 새 파일을 생성 os.Close() : 파일 리소스 닫기 파일 읽기 및 탐색 예제 package main import ( \"fmt\" \"os\" ) // 에러 체크 방식 1 func errCheck1(e error) { if e != nil { panic(e) } } // 에러 체크 방식 2 func errCheck2(e error) { if e != nil { fmt.Println(e) return } } func main() { // 파일 열기 file, err := os.Open(\"section11/sample.txt\") errCheck1(err) // 읽기 예제 1 fileInfo, err := file.Stat() // 파일 사이즈 확인 위해 정보 획득 errCheck2(err) fd1 := make([]byte, fileInfo.Size()) // 슬라이스에 읽은 내용 담는다. ct1, err := file.Read(fd1) fmt.Println(\"파일 정보 출력 1 =\u003e \", fileInfo, \"\\n\") fmt.Println(\"파일 이름 1 =\u003e \", fileInfo.Name(), \"\\n\") fmt.Println(\"파일 크기 1 =\u003e \", fileInfo.Size(), \"\\n\") fmt.Println(\"파일 수정 시간 1 =\u003e\", fileInfo.ModTime(), \"\\n\") fmt.Printf(\"읽기 작업 완료 1 =\u003e (%d bytes) \\n\\n\", ct1) fmt.Println(string(fd1)) // 읽기 예제 2 (탐색 : Seek(offset)) o1, err := file.Seek(20, 0) // 0 : 처음위치, 1: 현재위치 2: 마지막위치 errCheck2(err) fd2 := make([]byte, 20) ct2, err := file.Read(fd2) errCheck2(err) fmt.Printf(\"읽기 작업 완료 2 =\u003e (%d bytes) (%d ret)\\n\\n\", ct2, o1) fmt.Println(string(fd2)) // 읽기 예제 3 o2, err := file.Seek(0, 0) errCheck2(err) fd3 := make([]byte, 50) ct3, err := file.ReadAt(fd3, 8) // offset errCheck1(err) fmt.Printf(\"읽기 작업 완료 2 =\u003e (%d bytes) (%d ret)\\n\\n\", ct3, o2) fmt.Println(string(fd3)) defer file.Close() } 파일 쓰기 예제 package main import ( \"fmt\" \"os\" ) // 에러 체크 방식 1 func errCheck1(e error) { if e != nil { panic(e) } } // 에러 체크 방식 2 func errCheck2(e error) { if e != nil { fmt.Println(e) return } } // 파일 쓰기 1 func main() { // 파일 쓰기 예제 file, err := os.Create(\"test_write.txt\") errCheck1(err) // 리소스 해제 defer file.Close() // 쓰기 예제 s1 := []byte{115, 111, 109, 101, 111} n1, err := file.Write([]byte(s1)) // 문자열 -\u003e byte 슬라이스 형으로 변환 후 쓰기 errCheck2(err) fmt.Printf(\"File Write Result : (%d bytes)\\n\", n1) file.Sync() // Write Commit (Stable)! // 쓰기 예제 2 s2 := \"Hello GoLang! \\n File Write Test - 1 \\n\" n2, err := file.WriteString(s2) errCheck2(err) fmt.Printf(\"File Write Result(2) : (%d bytes)\\n\", n2) file.Sync() // 쓰기 예제 3 s3 := \"Test WriteAt ! - 2 \\n\" n3, err := file.WriteAt([]byte(s3), 70) // len(offset) 조절하면서 테스트 errCheck1(err) fmt.Printf(\"File Write Result(3) : (%d bytes)\\n\", n3) file.Sync() // 쓰기 예제 4 n4, err := file.WriteString(\"Hello GoLang! \\n File Write Test! - 3\\n\") errCheck2(err) fmt.Printf(\"File Write Result(4) : (%d bytes)\\n\", n4) } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section11/:1:1","tags":["go","golang"],"title":"Section 11 : Go 파일 입출력","uri":"/archives/golang/easy-golang-section11/"},{"categories":["Easy Go"],"content":"11.1.2 CSV 파일 읽기 패키지 저장소를 통해 Excel 등 다양한 파일 형식 쓰기, 읽기가 가능하다. bufio : 파일이 용량이 클 경우 버퍼 사용을 권장한다. 사용패키지 : tealeg/xlsx csv 파일 읽기 package main import ( \"bufio\" \"encoding/csv\" \"fmt\" \"os\" ) func errCheck(e error) { if e != nil { panic(e) } } func main() { // 파일 생성 file, err := os.Open(\"section11/sample.csv\") errCheck(err) // 리소스 해제 defer file.Close() // CSV Reader 생성 //rr := csv.NewReader(file) rr := csv.NewReader(bufio.NewReader(file)) // 권장 // CSV 내용 읽기 row, err := rr.Read() // 1개의 Row 단위로 읽기 errCheck(err) row2, err2 := rr.Read() // 1개의 Row 단위로 읽기 errCheck(err2) fmt.Println(\"CSV Read Example\") fmt.Println(row[0], row[1], row[2]) fmt.Println(row2[0], row2[1], row2[2]) fmt.Println(row[0:5]) fmt.Println(\"=================================\") rows, err := rr.ReadAll() // 전체 Row Read errCheck(err) fmt.Println(\"CSV Read All Example\") fmt.Println(rows) fmt.Println(rows[5][1]) // Row 단위로 CSV 파일 읽기 for i, row := range rows { // fmt.Println(i, row) for j := range row { fmt.Printf(\"%s \", rows[i][j]) } fmt.Println() } } csv 파일 쓰기 package main import ( \"encoding/csv\" \"fmt\" \"os\" _ \"bufio\" ) // 에러 체크 방식 1 func errCheck1(e error) { if e != nil { panic(e) } } // 에러 체크 방식 2 func errCheck2(e error) { if e != nil { fmt.Println(e) return } } func main() { // 파일 생성 file, err := os.Create(\"test_write.csv\") errCheck1(err) // 리소스 해제 defer file.Close() // CSV Writer 생성 wr := csv.NewWriter(file) // wr := csv.NewWriter(bufio.NewWriter(file)) // csv 내용 쓰기 wr.Write([]string{\"KIM\", \"4.8\"}) wr.Write([]string{\"LEE\", \"4.2\"}) wr.Write([]string{\"PARK\", \"4.1\"}) wr.Write([]string{\"CHO\", \"4.0\"}) wr.Write([]string{\"HONG\", \"4.2\"}) wr.Flush() // 버퍼 -\u003e 파일로 쓰기 fi, err := file.Stat() errCheck1(err) fmt.Printf(\"CSV 쓰기 작업 후 파일 크기 (%d bytes)\\n\", fi.Size()) fmt.Println(\"CSV 파일명 : \", fi.Name()) fmt.Println(\"운영 체제 파일 권한 : \", fi.Mode()) } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section11/:1:2","tags":["go","golang"],"title":"Section 11 : Go 파일 입출력","uri":"/archives/golang/easy-golang-section11/"},{"categories":["Easy Go"],"content":"11.1.3 ioutil 패키지를 활용 ioutil 패키지를 활용하면 더욱 편리하고 직관적인 파일을 읽고 쓰기가 가능. WriteFile(), ReadFile() , ReadAll() 등을 사용한다. ioutil - The Go Programming Language 파일 퍼미션 읽기(4), 쓰기(2), 실행(1) 소유자, 그룹, 기타사용자 순서 os - The Go Programming Language ioutil 활용 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func errCheck(e error) { if e != nil { panic(e) } } func main() { s := \"Hello Golang!\\n File Write Test!\\n\" // 파일 쓰기 err := ioutil.WriteFile(\"test_write1.txt\", []byte(s), os.FileMode(0644)) errCheck(err) // 파일 읽기 data, err := ioutil.ReadFile(\"section11/sample.txt\") errCheck(err) fmt.Println(\"=============================================\") fmt.Println(string(data)) fmt.Println(\"=============================================\") } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section11/:1:3","tags":["go","golang"],"title":"Section 11 : Go 파일 입출력","uri":"/archives/golang/easy-golang-section11/"},{"categories":["Easy Go"],"content":"11.1.5 파일 버퍼사용 bufio 패키지를 활용하여 파일 읽고 쓰기시 버퍼를 사용할 수 있다. ioutil, bufio 등은 io.Reader, io.Writer 인터페이스를 구현 한다. bufio - The Go Programming Language type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } 버퍼의 사용 상태 a ------\u003e a b ------\u003e ab c ------\u003e abc d ------\u003e abcd // 버퍼가 꽉찰경우 버퍼를 비우고 파일을 쓴다. e ------\u003e e -------\u003e abcd f ------\u003e ef -------\u003e abcd g ------\u003e efg -------\u003e abcd h ------\u003e efgh --------\u003e abcd i ------\u003e i -------\u003e abcdefg package main import ( \"bufio\" \"fmt\" \"os\" ) func errCheck(e error) { if e != nil { panic(e) } } func main() { file, err := os.OpenFile(\"test_write2.txt\", os.O_CREATE|os.O_RDWR, os.FileMode(0777)) // bufio 파일 쓰기 예제 wt := bufio.NewWriter(file) // Writer 반환한다. - 버퍼사용 wt.WriteString(\"Hello Golang!\\nFile Write Test!\\n\") wt.Write([]byte(\"Hello Golang!\\nFile Write Test222!\\n\")) // Error Check errCheck(err) // 버퍼 정보 출력 fmt.Printf(\"사용한 Buffer Size : (%d Bytes)\\n\", wt.Buffered()) fmt.Printf(\"남은 Buffer Size : (%d Bytes)\\n\", wt.Available()) fmt.Printf(\"전체 Buffer Size : (%d Bytes)\\n\", wt.Size()) wt.Flush() // 버퍼 비우고 디스크 반영 (버퍼의 내용을 디스크에 기록한다.) fmt.Println(\"쓰기 작업 완료 \\n\") fmt.Println(\"=================================================\") rt := bufio.NewReader(file) // Reader 반환 fi, err := file.Stat() errCheck(err) b := make([]byte, fi.Size()) fmt.Println(\"파일 정보 출력 : \", fi) fmt.Println(\"파일 이름: \", fi.Name()) fmt.Println(\"파일 크기 : \", fi.Size()) fmt.Println(\"파일 수정시간 : \", fi.ModTime()) fmt.Println(\"=================================================\") fmt.Println() file.Seek(0, os.SEEK_SET) data, _ := rt.Read(b) // 읽기(ReadLine, ReadByte, ReadBytes 등) // rt.Read(b) fmt.Printf(\"전체 Buffer Szie : (%d Bytes)\\n\", rt.Size()) fmt.Printf(\"읽기 작업 완료 (%d Bytes) \\n\", data) fmt.Println(\"=================================================\") fmt.Println(string(b)) fmt.Println(\"=================================================\") defer file.Close() } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section11/:1:4","tags":["go","golang"],"title":"Section 11 : Go 파일 입출력","uri":"/archives/golang/easy-golang-section11/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section10/:0:0","tags":["go","golang"],"title":"Section 10 : 에러 처리","uri":"/archives/golang/easy-golang-section10/"},{"categories":["Easy Go"],"content":"10.1 에러처리 ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section10/:1:0","tags":["go","golang"],"title":"Section 10 : 에러 처리","uri":"/archives/golang/easy-golang-section10/"},{"categories":["Easy Go"],"content":"10.1.1 Go 에러 소프트웨어의 품질 향상에 가장 중요한 것 → 유형코드 및 에러 정보 등을 남기는 것 Go 에서는 기본적으로 error 라는 인터페이스 타입을 갖고 있다. 개발자는 이 인터페이스를 구현하는 커스텀 에러 타입을 만들 수 있다. type error interface { Error() string } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section10/:1:1","tags":["go","golang"],"title":"Section 10 : 에러 처리","uri":"/archives/golang/easy-golang-section10/"},{"categories":["Easy Go"],"content":"10.1.2 Go 에러처리 Go 함수의 경우 기본적으로 리턴 타입을 두개 갖고 있다. (리턴값, 에러) 주로 에러 타입을 리턴 하거나 Fatal(프로그램 종료) 메소드를 통해 에러를 출력한다. os.Open() 함수는 첫번째는 File 포인터를 두번째는 error 인터페이스를 리턴한다. func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) } 기본적인 메서드 에러 처리 예제 package main import ( \"fmt\" \"log\" \"os\" ) func main() { // 기본적인 메서드 에러 처리 예제 f, err := os.Open(\"unnamedfile\") // 예외 발생 if err != nil { log.Fatal(err.Error()) // 프로그램 종료 //log.Fatal(err) } fmt.Println(\"=======================\") fmt.Println(\"Example 1 : \", f.Name()) } errors 패키지의 New 메소드를 활용한 에러 생성 package main import ( \"errors\" \"fmt\" ) func main() { var err1 error = errors.New(\"Error occurred - 1\") err2 := errors.New(\"error occurred - 2\") fmt.Println(\"error1 : \", err1) fmt.Println(\"error1 : \", err1.Error()) fmt.Println(\"error2 : \", err2) fmt.Println(\"error2 : \", err2.Error()) } 구조체를 사용하여 사용자 정의 예외처리 예제 package main import ( \"fmt\" \"log\" \"math\" \"time\" ) // 에러(예외) 처리 구조체 type PowError struct { time time.Time // 에러 발생 시간 value float64 // 파라미터 message string // 에러 메세지 // value interface{} } func(e *PowError) Error() string { return fmt.Sprintf(\"[%v]Error - Input Value(value: %g) - %s\", e.time, e.value, e.message) } func Power2(f, i float64) (float64, error) { if f == 0 { return 0, \u0026PowError{time : time.Now(), value: f, message: \"0은 사용할 수 없습니다.\"} } if math.IsNaN(f) { return 0, \u0026PowError{time: time.Now(), value: f, message: \"숫자가 아닙니다.\"} } if math.IsNaN(i) { return 0, \u0026PowError{time: time.Now(), value: i, message: \"숫자가 아닙니다.\"} } return math.Pow(f, i), nil } // Go 에러 처리 고급 - 3 func main() { // Example 1 v, err := Power2(10, 3) // 정상 if err != nil { log.Fatal(err) } fmt.Println(\"Example 1 : \", v) // Example 2 t, err := Power2(0, 3) // Error if err != nil { log.Fatal(err) fmt.Println(err.(*PowError).message) } fmt.Println(\"Example 1 : \", t) } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section10/:1:2","tags":["go","golang"],"title":"Section 10 : 에러 처리","uri":"/archives/golang/easy-golang-section10/"},{"categories":["Easy Go"],"content":"10.2 recover, panic ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section10/:2:0","tags":["go","golang"],"title":"Section 10 : 에러 처리","uri":"/archives/golang/easy-golang-section10/"},{"categories":["Easy Go"],"content":"10.2.1 panic 함수 Go 내장 함수인 panic() 함수는 현재 함수를 즉시 중지시키고 defer 함수를 호출하고 자기 자신을 호출한 곳으로 즉시 리턴한다. 이러한 panic 모드 실행 방식은 다시 상위함수에도 똑같이 적용되고, 계속 콜스택을 타고 올라가며 적용된다. → 런타임 이외에 사용자가 코드 흐름에 따라 에러를 발생 시킬때 중요하다 panic 사용방법 package main import ( \"fmt\" ) func main() { fmt.Println(\"Start Main\") panic(\"Error occurred : user Stopped!\") // 방법1 //log.Panic(\"Error occurred : user Stopped!\") // 방법2 fmt.Println(\"End Main\") // 실행 불가 } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section10/:2:1","tags":["go","golang"],"title":"Section 10 : 에러 처리","uri":"/archives/golang/easy-golang-section10/"},{"categories":["Easy Go"],"content":"10.2.2 recover 함수 Go 내장 함수인 recover() 함수는 패닉상태를 다시 정상상태로 되돌리는 함수이다. panic에서 설정한 메세지를 받아 올 수 있다. package main import ( \"fmt\" \"os\" ) func fileOpen(filename string) { // defer 함수 - panic이 호출 되면 실행 defer func() { if r := recover(); r != nil { fmt.Println(\"File Open Error! -\u003e \", r) } }() f, err := os.Open(filename) if err != nil { panic(err) } else { fmt.Println(\"Filename : \", f.Name()) } defer f.Close() } func main() { fileOpen(\"undefined.txt\") fmt.Println(\"End Main.\") } ","date":"2021-04-23","objectID":"/archives/golang/easy-golang-section10/:2:2","tags":["go","golang"],"title":"Section 10 : 에러 처리","uri":"/archives/golang/easy-golang-section10/"},{"categories":["database"],"content":"Oracle Scheduler - DBMS_SCHEDULER 오라클에서 정해진 시간에 반복된 작업을 수행하기 위해 DBMS_JOB 패키지를 활용하였지만 Oracle 10g 부터는 좀 더 확장된 기능을 가진 DBMS_SCHEDULER 패키지를 제공하고 있다. DBMS_JOB과의 가장 큰 차이점은 DBMS_JOB에서는 불가능하던 외부스크립트 (프로시저나, 함수 이외에도 OS에서 생성된 각종 유틸, 프로그램 까지) 실행이 가능하다. ","date":"2021-04-22","objectID":"/archives/dbms/oracle-scheduler/:0:0","tags":["oracle","database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/archives/dbms/oracle-scheduler/"},{"categories":["database"],"content":"Class 생성 클래스를 지정하지 않게 되면 DEFAULT_JOB_CLASS 에 포함되는데 이 경우 기본 로깅 정책을 따른다. 기본로깅 정책은 DBMS_SCHEDULER.LOGGING_RUNS 이며 로깅레벨을 별도로 설정하거나 다른 스케쥴잡과 그룹화하여 관리하고 싶을 경우 Class를 생성한다. /** * CLASS 생성 예제 * 로그정책 : DBMS_SCHEDULER.LOGGING_FAILED_RUNS * 30일만 로그 보관 * */ BEGIN DBMS_SCHEDULER.CREATE_JOB_CLASS ( job_class_name =\u003e 'EXAMPLE_JOB_CLASS', resource_consumer_group =\u003e 'DEFAULT_CONSUMER_GROUP', logging_level =\u003e DBMS_SCHEDULER.LOGGING_FAILED_RUNS, log_history =\u003e 30, comments =\u003e 'JOB CLASS 설명 입니다.' ); END; ","date":"2021-04-22","objectID":"/archives/dbms/oracle-scheduler/:0:1","tags":["oracle","database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/archives/dbms/oracle-scheduler/"},{"categories":["database"],"content":"Scheduler Job 생성하고 활성화 하기 로그정책 : DBMS_SCHEDULER.LOGGING_FAILED_RUNS. 30일만 로그를 보관한다. 실행 주기는 30초 마다로 설정 -- Job 생성 BEGIN DBMS_SCHEDULER.CREATE_JOB( JOB_NAME =\u003e 'test_job', JOB_TYPE =\u003e 'STORED_PROCEDURE', JOB_ACTION =\u003e 'test_procedure', START_DATE =\u003e SYSDATE, REPEAT_INTERVAL =\u003e 'FREQ=SECONDLY;INTERVAL=30', COMMENTS =\u003e '테스트 잡' ); END; -- Job 활성화 BEGIN DBMS_SCHEDULER.ENABLE('JBT_SEARCH_TRUCK_FLTER'); END; ","date":"2021-04-22","objectID":"/archives/dbms/oracle-scheduler/:0:2","tags":["oracle","database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/archives/dbms/oracle-scheduler/"},{"categories":["database"],"content":"Oracle Scheduler Job에 로그 레벨 세팅하기 Logging Level Description DBMS_SCHEDULER.LOGGING_OFF No logging is performed. DBMS_SCHEDULER.LOGGING_FAILED_RUNS A log entry is made only if the job fails. DBMS_SCHEDULER.LOGGING_RUNS A log entry is made each time the job is run. DBMS_SCHEDULER.LOGGING_FULL A log entry is made every time the job runs and for every operation performed on a job, including create, enable/disable, update (with SET_ATTRIBUTE), stop, and drop. BEGIN DBMS_SCHEDULER.set_attribute ( name =\u003e 'test_log_job', attribute =\u003e 'logging_level', value =\u003e DBMS_SCHEDULER.logging_off); END; -- 스케쥴 잡 로그 테이블 SELECT * FROM USER_SCHEDULER_JOB_LOG; ","date":"2021-04-22","objectID":"/archives/dbms/oracle-scheduler/:0:3","tags":["oracle","database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/archives/dbms/oracle-scheduler/"},{"categories":["database"],"content":"기타 설정 메서드 -- Job 활성화 BEGIN DBMS_SCHEDULER.ENABLE('JBT_SEARCH_TRUCK_FLTER'); END; -- Job 비활성화 BEGIN DBMS_SCHEDULER.DISABLE('JBT_SEARCH_TRUCK_FLTER'); END; -- Job 지우기 BEGIN DBMS_SCHEDULER.DROP_JOB (job_name =\u003e 'JBT_SEARCH_TRUCK_FLTER'); END; ","date":"2021-04-22","objectID":"/archives/dbms/oracle-scheduler/:0:4","tags":["oracle","database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/archives/dbms/oracle-scheduler/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:0:0","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.1 고루틴 ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:1:0","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.1.1 GoRoutine goroutine은 go 런타임이 관리하는 lightweight 논리적(가장적) Thread이다. 생성 방법이 매우 간단하고 리소스를 매우 적게 사용한다. → 수 많은 고루틴을 동시에 생성 및 실행이 가능 Java나 Python의 스레드는 MB단위인 반면에 GO KB 단위이다. 비동기적 asynchronously 함수 루틴을 실행 한다. 채널을 통해 루틴간 통신이 가능하다. 공유 메모리를 사용시에 정확한 동기화 코딩이 필요하다. 싱글 루틴에 비해 항상 빠르지는 않다. 멀티 스레드의 장점과 단점 장점 응답성이 향상 자원공유를 효율적으로 활용 가능 작업이 분리되어 코드 간결 단점 구현하기 어려움. 테스트 및 디버깅이 어렵다 전체 프로세스의 사이드 이펙트가 발생 성능 저하 동기화 코딩을 반드시 숙지 데드락(교착상태) 고루틴 기초사용 예제 메인 루틴이 종료되면 서브루틴(exe2, exe3) 도 종료되기 때문에 메인루틴의 실행시간을 줌 package main import ( \"fmt\" \"time\" ) func exe1() { fmt.Println(\"exe1 func start\", time.Now()) time.Sleep(1 * time.Second) // 1초 fmt.Println(\"exe1 func end\", time.Now()) } func exe2() { fmt.Println(\"exe2 func start\", time.Now()) time.Sleep(1 * time.Second) // 1초 fmt.Println(\"exe2 func end\", time.Now()) } func exe3() { fmt.Println(\"exe3 func start\", time.Now()) time.Sleep(1 * time.Second) // 1초 fmt.Println(\"exe3 func end\", time.Now()) } // 고루틴(Goroutine) 기초 func main() { exe1() // 가장 먼저 실행 (일반적인 실행 흐름) // exe2() // exe3() fmt.Println(\"Main Routine Start\", time.Now()) // 별도의 실행 흐름을 생성 go exe2() go exe3() time.Sleep(4 * time.Second) fmt.Println(\"Main Routine End\", time.Now()) } Result exe1 func start 2021-04-13 11:40:12.15236 +0900 KST m=+0.000091278 exe1 func end 2021-04-13 11:40:13.157639 +0900 KST m=+1.005357230 Main Routine Start 2021-04-13 11:40:13.157766 +0900 KST m=+1.005484383 exe3 func start 2021-04-13 11:40:13.157812 +0900 KST m=+1.005529633 exe2 func start 2021-04-13 11:40:13.157855 +0900 KST m=+1.005573044 exe2 func end 2021-04-13 11:40:14.162966 +0900 KST m=+2.010670709 exe3 func end 2021-04-13 11:40:14.163006 +0900 KST m=+2.010710760 Main Routine End 2021-04-13 11:40:17.158061 +0900 KST m=+5.005725592 // exe2, exe3은 별도의 실행흐름에 따라 실행된다. goroutine 반복문 예제 package main import ( \"fmt\" \"time\" ) func exe(name string) { fmt.Println(name, \"Start : \", time.Now()) for i := 0; i \u003c 1000; i++ { fmt.Println(name, \"\u003e\u003e\u003e\u003e\u003e\", i) } fmt.Println(name, \"End : \", time.Now()) } func main() { // 고루틴 (Goroutine) exe(\"t1\") fmt.Println(\"Main Routine Start : \", time.Now()) go exe(\"t2\") go exe(\"t3\") time.Sleep(4 * time.Second) // time.Second, Minute, Hour, Millisecond ... fmt.Println(\"Main Routine End : \", time.Now()) } ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:1:1","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.1.2 멀티 코어 (다중 CPU) 활용하기 Go는 디폴트로 1개의 CPU를 사용한다. → 여러개의 Go 루틴을 만들더라도 1 개의 CPU에서 작업을 시분할하여 처리한다 ⇒ 동시성(concurrent) 처리 만약 머신이 복수개의 CPU를 가진경우, Go 프로그램을 다중 CPU에서 병렬처리(parallel) 하게 할 수 있다. 병렬처리를 위해서는 runtime.GOMAXPROCS(CPU수) 함수를 호출해야 한다. package main import ( \"fmt\" \"time\" \"math/rand\" \"runtime\" ) func exe(name int) { r := rand.Intn(100) fmt.Println(name, \"Start : \", time.Now()) for i := 0; i \u003c 100; i++ { fmt.Println(name, \"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\", r, i) } fmt.Println(name, \"End : \", time.Now()) } func main() { runtime.GOMAXPROCS(runtime.NumCPU()) // 현 시스템 cpu 코어 개수 반환 후 설정 fmt.Println(\"Current System CPU : \", runtime.GOMAXPROCS(0)) // 설정 값 출력 // Example 1 fmt.Println(\"Main Routine Start : \", time.Now()) for i := 0; i \u003c 100; i++ { go exe(i) // GO ROUTINE 100개 생성 } time.Sleep(5 * time.Second) fmt.Println(\"Main Routine End : \", time.Now()) } ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:1:2","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.1.3 클로저를 고루틴으로 실행할 때 주의할 점 반복문 내에 고루틴을 삽입하여 클로저를 통해 바깥 변수를 참조할 때 유의하여 사용해야 한다. for i := 0; i \u003c 1000; i++ { go func() { fmt.Println(\"Closure Test =\u003e \", i) }() } 이렇게 사용하는 경우 출력이 i가 0부터 999 까지 출력 될 것이라 예상하지만 결과는 다르다. 실행 결과 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 … 일반적으로 반복문 클로저는 즉시 실행되지만, 고루틴으로 클로저를 사용할 때 반복문이 종료된 뒤 가장 나중에 실행된다. 그러므로 i 가 반복문을 다 돌고난 1000의 값이 나오게 된다. 고루틴 클로저를 사용할때 반복문에 의해 변경되는 값은 파라미터로 넘겨주어야만 올바른 결과를 얻을 수 있다. 개선소스 package main import ( \"fmt\" \"runtime\" \"time\" ) func main() { runtime.GOMAXPROCS(1) s := \"Go Routine Closure : \" for i := 0; i \u003c 1000; i++ { go func(n int) { fmt.Println(s, n, \" - \", time.Now()) }(i) } time.Sleep(5 * time.Second) } ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:1:3","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.2 채널 ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:2:0","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.2.1 채널 Go 채널은 고루틴간의 데이터를 주고 받는 통로라고 할 수 있다. 고루틴 끼리 데이터를 주고 받는데 사용되며, 상태편이 준비될 때까지 채널에서 대기함으로서 별도의 Lock 을 걸지않고 데이터를 동기화하는데 사용된다. 채널은 make() 함수를 통해 미리 생성되어야 하며(=참조타입임) 동기방식으로 동작한다. 지정한 데이터 타입만 주고 받을 수 있다. → interface{} 를 통해 자료형 상관없이 전송 및 수신 가능 멀티프로세싱 처리에서 교착상태(경쟁상태)에 주의해야 한다. \u003c-, -\u003e 을 통해 데이터를 주고 받는다. 채널 ← 데이터 : 송신 변수 ← 채널 : 수신 package main import \"fmt\" func rangeSum(rg int, c chan int) { sum := 0 for i := 1; i \u003c= rg; i++ { sum += i } c \u003c- sum } func main() { // 채널(Channel) c := make(chan int) go rangeSum(1000, c) go rangeSum(7000, c) go rangeSum(5000, c) result1 := \u003c- c result2 := \u003c- c result3 := \u003c- c fmt.Println(\"Example 1 : \", result1) fmt.Println(\"Example 2 : \", result2) fmt.Println(\"Example 3 : \", result3) } Result Example 1 : 12502500 Example 2 : 500500 Example 3 : 24503500 ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:2:1","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.2.2 Go 채널 버퍼링 Unbuffered Channel ,Buffered Channel 두가지의 채널이 있다. Unbuffered Channel 수신자가 데이터를 받을 때 까지 송신자가 데이터를 보내느 채널에 묶여 있게 된다. package main import ( \"fmt\" \"time\" ) func main() { // Channel // 동기 : 버퍼 미사용 ch := make(chan bool) cnt := 6 go func() { for i := 0; i \u003c cnt; i++ { ch \u003c- true fmt.Println(\"Go =\u003e \", i) time.Sleep(1 * time.Second) } }() for i := 0; i \u003c cnt; i++ { \u003c- ch fmt.Println(\"Main : \", i) } } Result Buffered Channel 수신자가 받을 준비가 되어 있지 않을 지라도 지정된 버퍼만큼 데이터를 보내고 계속 다른 일을 수행할 수 있다. make(chan type, N) 함수를 통해 생성할 수 있으며 N 에 사용할 버퍼의 개수를 넣는다. 발신 : 가득차면 대기, 비어있으면 동작 수신 : 비어있으면 대기, 가득차면 작동 package main import ( \"fmt\" \"runtime\" ) func main() { runtime.GOMAXPROCS(1) ch := make(chan bool, 2) cnt := 12 go func() { for i := 0; i \u003c cnt; i++ { ch \u003c- true fmt.Println(\"Go =\u003e \", i) } }() for i := 0; i \u003c cnt; i++ { \u003c- ch fmt.Println(\"Main : \", i) } } Result 버퍼 채널의 경우 수신자가 당장 없더라도 최대버퍼 수까지 데이터를 보낼 수 있다. 버퍼채널을 이용하지 않는 경우 fatal error: all goroutines are asleep - deadlock! 에러발생 package main import \"fmt\" func main() { ch := make(chan int, 1) //수신자가 없더라도 보낼 수 있다. ch \u003c- 101 fmt.Println(\u003c-ch) } ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:2:2","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.2.3 채널 닫기 채널을 오픈하고 데이터를 송신한 뒤 close() 함수를 통해 채널을 닫을 수 있다. 닫힌 채널에서 값을 전송할 경우 panic 예외가 발생한다. 채널 Range 채널에서 송신자가 송신을 한 후, 채널을 닫을 수 있다. 그리고 수신자는 임의의 갯수의 데이터를 채널이 닫힐 때까지 계속 수신할 수 있다. range로 순회하면서 채널이 닫힐 때까지 값을 꺼내올 수 있다. package main import \"fmt\" func main() { ch := make(chan bool) go func() { for i := 0; i \u003c 5; i++ { ch \u003c- true } close(ch) // 5회 채널에 값 전송 후 채널 닫기 }() for i := range ch { // 채널에서 값을 꺼내 온다 fmt.Println(\"Example 1 : \", i) } } 채널이 닫힌것을 파라미터를 통해 받아 올 수 있다. ch := make(chan int) go func() { for i := 0; i \u003c 3; i++ { ch \u003c- 7777 } }() if val1, ok := \u003c- ch; ok { // ... } ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:2:3","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.2.4 채널 파라미터 채널을 함수 파라미터를 전달할 때, 일반적으로 송수신을 모두 하는 채널을 전달하지만 특별히 해당 채널로 송신 및 수신 전용 채널을 지정할 수 있다. 수발신 전용 채널 설정 후 방향이 다를 경우 예외가 발생한다. 발신 전용 : channel ← 데이터형 수신 전용 : ← channel 채널 또한 함수의 반환 값으로 사용할 수 있다. 발신 전용, 수신 전용 채널 생성 package main import ( \"fmt\" \"time\" ) // 발신 전용 func sendOnly(c chan\u003c- int, cnt int) { for i := 0; i \u003c cnt; i++ { c \u003c- i } c \u003c- 777 // fmt.Println(\u003c-c) // 수신 전용채널에서 발신 처리 시 예외 발생 } // 수신 전용 func receiveOnly(c \u003c-chan int) { for i := range c { fmt.Println(\"Received i : \", i) } fmt.Println(\u003c-c) } func main() { c := make(chan int) go sendOnly(c, 10) // 발신 전용 go receiveOnly(c) // 수신 전용 time.Sleep(1 * time.Second) } 채널을 함수의 반환 값으로 사용 package main import \"fmt\" // 수신 전용 채널을 리턴값으로 리턴 func sum(cnt int) \u003c-chan int { sum := 0 tot := make(chan int) go func() { for i := 1; i \u003c= cnt; i++ { sum += i } tot \u003c- sum }() return tot } func main() { c := sum(100) fmt.Println(\"Example 1 \", \u003c-c ) } 반환 된 채널을 전달받아 다시 채널로 반환 package main import \"fmt\" func receiveOnly(cnt int) \u003c-chan int { sum := 0 tot := make(chan int) go func() { for i := 1; i \u003c= cnt; i++ { sum += i } tot \u003c- sum tot \u003c- 777 tot \u003c- 777 close(tot) }() return tot } func total(c \u003c-chan int) \u003c-chan int { tot := make(chan int) go func() { a := 0 for i := range c { a = a + i } tot \u003c- a close(tot) }() return tot } func main() { // Channel // Example1 c := receiveOnly(100) // 채널 반환 output := total(c) // 채널 전달 후 반환 fmt.Println(\"Example 1 : \", \u003c-output) } ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:2:4","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.2.5 채널 Select 구문 select문은 여러 개의 case문에서 각기 다른 채널을 기다리다가 데이터가 수신되면 준비된 채널 case를 실행하게 된다. 일회성 구문이므로 for (반복문) 안에서 수행되어야 한다. 복수 채널에 신호가 오면 Go 런타임에서 랜덤하게 한개를 선택한다. select문에 defaut 문이 있으면 case문 채널이 준비되지 않더라도 계속 대기하지 않고 바로 default 문을 실행하므로 주의해야 한다. package main import ( \"fmt\" \"time\" ) func main() { ch1 := make(chan int) ch2 := make(chan string) go func() { for { ch1 \u003c- 77 time.Sleep(250 * time.Millisecond) } }() go func() { for { ch2 \u003c- \"Golang Hi!\" time.Sleep(500 * time.Millisecond) } }() go func() { for { select { case num := \u003c- ch1: fmt.Println(\"Channel 1 =\u003e \", num) case str := \u003c- ch2: fmt.Println(\"Channel 2 =\u003e \", str) // default: // fmt.Println(\"Default Test !\") } } }() time.Sleep(7 * time.Second) } ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:2:5","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.3 동기화 ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:3:0","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.3.1 고루틴 동기화 다중 코어에서 어떤 작업을 분할하여 작업시 해당 작업과 다른 작업이 같은 메모리 영역을 건드릴 경우 예기치 않은 동작이나 치명적이 에러를 유발할 수 있다. OS 내부적으로 원자적 연산을 보장하기 위해 다양한 기법을 사용하지만 응용 프로그래머 입장에서도 멀티코어를 잘 처리하기 위해 코드안에서 동기화 처리가 매우 중요하다. 동기화를 사용하지 않은 경우 package main import ( \"fmt\" \"runtime\" ) // 구조체 선언 - 여러 Go Routine 에서 접근하는 공유 데이터 type count struct { num int } func (c *count) increment() { c.num += 1 } func (c *count) result() { fmt.Println(c.num) } func main() { // 동기화 사용하지 않은 경우 예제 // 시스템 전체 CPU 사용 runtime.GOMAXPROCS(runtime.NumCPU()) c := count{num: 0} done := make(chan bool) for i := 1; i \u003c= 10000; i++ { go func() { c.increment() done \u003c- true runtime.Gosched() // 다른 CPU 에게 양보 }() } for i := 1; i \u003c= 10000; i++ { \u003c- done } c.result() } Result 실행할 때마다 다른 값을 반환 ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:3:1","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.3.2 Mutex 상호 배제 → 고루틴들이 서로 running time에 영향을 주지 않게 한다. → 단독으로 실행되게 하는 기술 여러 고루틴에서 작업하는 공유 데이터를 보호한다. sync.Mutex 선언 후 Lock, Unlock 을 사용한다. 동기화를 사용한 예제 package main import ( \"fmt\" \"runtime\" \"sync\" ) // 구조체 선언 - 여러 Go Routine 에서 접근하는 공유 데이터 type count struct { num int mutex sync.Mutex // 구조체 내부에 있기때문에 } // 공유 데이터가 변경이 되는 부분 func (c *count) increment() { // 공유 데이터 수정 전 뮤텍스로 보호 c.mutex.Lock() c.num += 1 // 공유 데이터 수정 후 보호 해제 c.mutex.Unlock() } func (c *count) result() { fmt.Println(c.num) } func main() { // 동기화 사용한 예제 // 시스템 전체 CPU 사용 runtime.GOMAXPROCS(runtime.NumCPU()) // runtime.GOMAXPROCS(1) c := count{num: 0} done := make(chan bool) for i := 1; i \u003c= 10000; i++ { go func() { c.increment() done \u003c- true runtime.Gosched() // 다른 CPU 에게 양보 }() } for i := 1; i \u003c= 10000; i++ { \u003c- done } c.result() } Result ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:3:2","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.3.3 쓰기, 읽기 전용 Mutex RWMutex : 쓰기 Lock → 쓰기 시도 중에는 다른 곳에서 이전 값을 읽지 못함. 읽기 락, 쓰기 락 전부 방어(방지) RMutex : 읽기 Lock → 읽기 시도 중에 값 변경 방지. 즉 쓰기 락만 방어(방지) 동기화 사용하지 않은 경우 예제 쓰기, 읽기 동작 순서가 일정하지 않아 잘못된 오류를 반환 할 가능성 증가 package main import ( \"fmt\" \"runtime\" \"time\" ) func main() { runtime.GOMAXPROCS(runtime.NumCPU()) data := 0 go func() { for i := 1; i \u003c= 10; i++ { data += 1 fmt.Println(\"Write : \", data) time.Sleep(200 * time.Millisecond) } }() go func() { for i := 1; i \u003c= 10; i++ { fmt.Println(\"Read 1 : \", data) time.Sleep(1 * time.Second) } }() go func() { for i := 1; i \u003c= 10; i++ { fmt.Println(\"Read 2 : \", data) time.Sleep(1 * time.Second) } }() time.Sleep(5 * time.Second) } 동기화 사용 예제 package main import ( \"fmt\" \"runtime\" \"sync\" \"time\" ) func main() { // 시스템 전체 cpu 사용 runtime.GOMAXPROCS(runtime.NumCPU()) data := 0 mutex := new(sync.RWMutex) // var mutex = new (sync.RWMutex) go func() { for i := 1; i \u003c= 10; i++ { // 쓰기 뮤텍스 잠금 mutex.Lock() data += 1 fmt.Println(\"Write : \", data) time.Sleep(200 * time.Millisecond) // 쓰기 뮤텍스 잠금 해제 mutex.Unlock() } }() go func() { for i := 1; i \u003c= 10; i++ { // 읽기 뮤텍스 잠금 mutex.RLock() fmt.Println(\"Read 1 : \", data) time.Sleep(1 * time.Second) mutex.RUnlock() // 읽기 뮤텍스 해제 } }() go func() { for i := 1; i \u003c= 10; i++ { // 읽기 뮤텍스 잠금 mutex.RLock() fmt.Println(\"Read 2 : \", data) time.Sleep(1 * time.Second) mutex.RUnlock() // 읽기 뮤텍스 해제 } }() time.Sleep(10 * time.Second) } ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:3:3","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.3.4 동기화 상태 메소드 동기화 상태(조건) 메소드 wait, signal , Broadcast 사용 package main import ( \"fmt\" \"runtime\" \"sync\" \"time\" ) func main() { // 시스템 전체 CPU 사용 runtime.GOMAXPROCS(runtime.NumCPU()) var mutex = new(sync.Mutex) var condition = sync.NewCond(mutex) ch := make(chan int, 5) // 비동기 버퍼 채널 for i := 0; i \u003c 5; i++ { go func(n int) { mutex.Lock() ch \u003c- 777 fmt.Println(\"GoRoutine Wait -\u003e \", n) condition.Wait() // 고 루틴 멈춤(대기) fmt.Println(\"Waiting End\", n) mutex.Unlock() }(i) } for i := 0; i \u003c 5; i++ { // \u003c- ch fmt.Println(\"Received : \", \u003c-ch ) } /*for i := 0; i \u003c 5; i++ { mutex.Lock() fmt.Println(\"Wake GoRoutine(Signal)\", i) condition.Signal() // 모든 고 루틴 생성 후 한개 씩 깨우기 mutex.Unlock() }*/ mutex.Lock() fmt.Println(\"Wake Goroutine(Broadcast)\") condition.Broadcast() mutex.Unlock() time.Sleep(2 * time.Second) } ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:3:4","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.3.5 sync.Once 특정 함수를 한 번만 수행해야 할 때 sync.Once 를 사용한다. sync.Once 구조체는 다음과 같은 메서드를 제공한다. func (o *Once) Do(f func()) 한 번만 수행해야 하는 함수를 Do() 메서드의 매개변수로 전달하여 실행하면 여러 고루틴에서 실행한다 해도 해당 함수는 한 번만 수행된다. 주로 초기화에 사용된다. package main import ( \"fmt\" \"runtime\" \"sync\" \"time\" ) func onceTest() { // 이 부분에 한 번 실행 할 코드 작성 // 초기화 작업 등 fmt.Println(\"Once Test Execute!\") } func main() { runtime.GOMAXPROCS(runtime.NumCPU()) once := new(sync.Once) // Once 객체 생성 for i := 0; i \u003c 5; i++ { go func(n int) { fmt.Println(\"Go Routine -\u003e \", n) once.Do(onceTest) }(i) } time.Sleep(2 * time.Second) } Result ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:3:5","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.3.6 sync.WaitGroup sync.WaitGroup 는 모든 고루틴이 종료될 때까지 대기해야 할 때 사용한다. sync.WaitGroup 이 제공하는 메서드 func (wg *WaitGroup) Add(delta int) : WaitGroup에 대기중인 고루틴 개수 추가 func (wg *WaitGroup) Done() : 대기 중인 고루틴의 수행이 종료되는 것을 알려줌 func (wg *WaitGroup) Wait() : 모든 고루틴이 종료 될 때까지 대기 package main import ( \"fmt\" \"sync\" ) // 고루틴 동기화 고급 - 2 func main() { wg := new(sync.WaitGroup) for i := 0; i \u003c 100; i++ { wg.Add(1) go func(n int) { fmt.Println(\"WaitGroup =\u003e \", n) wg.Done() }(i) } // Add 와 Done 횟수가 같아야한다. wg.Wait() // 대기 그룹이 끝날떄까지 기다린다. fmt.Println(\"WaitGroup End!\") } Result ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:3:6","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":"9.3.7 원자성을 보장하는 연산 원자성 atomic : 기능적으로 분할 가능한 완전 보증된 일련의 조작. 모두 성공하거나 모두 실패해야 한다. 모든 조작이 완료 될 때까지 다른 프로세스 개입이 불가하다. sync.atomic 에서 원자적 연산자를 제공한다. 주로 공용 변수에 관한 계산에 사용한다. atomic - The Go Programming Language sync/atomic 패키지가 제공하는 함수 함수 설명 AddT 특정 포인터 변수에 값을 더함 CompareAndSwapT 특정 포인터 변수의 값을 주어진 값과 비교하여 같으면 새로운 값으로 대체함 LoadT 특정 포인터 변수의 값을 가져옴 StoreT 특정 포인터 변수에 값을 저장함 SwapT 특정 포인터 변수에 새로운 값을 저장하고 이전 값을 가져옴 원자성을 사용하지 않은 경우 package main import ( \"fmt\" \"runtime\" \"sync\" ) func main() { // 원자성을 사용하지 않은 경우 예제 runtime.GOMAXPROCS(runtime.NumCPU()) var cnt int64 = 0 wg := new(sync.WaitGroup) for i := 0; i \u003c 5000; i++ { wg.Add(1) go func(n int) { cnt += 1 wg.Done() }(i) } for i := 0; i \u003c 2000; i++ { wg.Add(1) go func(n int) { cnt -= 1 wg.Done() }(i) } wg.Wait() // 대기 그룹이 끝날떄까지 기다린다. fmt.Println(\"WaitGroup End! cnt : \", cnt) } Result 공용변수 cnt에 대해 올바르지 못한 결과값이 나옴. 원자성 연산자를 사용한 경우 예제 package main import ( \"fmt\" \"runtime\" \"sync\" \"sync/atomic\" ) // 고루틴 동기화 고급 - 3 func main() { runtime.GOMAXPROCS(runtime.NumCPU()) var cnt int64 = 0 wg := new(sync.WaitGroup) for i := 0; i \u003c 5000; i++ { wg.Add(1) go func(n int) { //cnt += 1 atomic.AddInt64(\u0026cnt, 1) wg.Done() }(i) } for i := 0; i \u003c 2000; i++ { wg.Add(1) go func(n int) { //cnt -= 1 atomic.AddInt64(\u0026cnt, -1) wg.Done() }(i) } wg.Wait() // 대기 그룹이 끝날떄까지 기다린다. finalCnt := atomic.LoadInt64(\u0026cnt) fmt.Println(\"WaitGroup End! cnt : \", cnt) fmt.Println(\"WaitGroup End! cnt : \", finalCnt) } Result ","date":"2021-04-15","objectID":"/archives/golang/easy-golang-section9/:3:7","tags":["go","golang"],"title":"Section 9 : Go 병행처리","uri":"/archives/golang/easy-golang-section9/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-13","objectID":"/archives/golang/easy-golang-section8/:0:0","tags":["go","golang"],"title":"Section 8 : Go 객체지향","uri":"/archives/golang/easy-golang-section8/"},{"categories":["Easy Go"],"content":"8.1 인터페이스 ","date":"2021-04-13","objectID":"/archives/golang/easy-golang-section8/:1:0","tags":["go","golang"],"title":"Section 8 : Go 객체지향","uri":"/archives/golang/easy-golang-section8/"},{"categories":["Easy Go"],"content":"8.1.1 인터페이스란 구조체가 필드들의 집합체라면 interface는 메서드들의 집합이다. 인터페이스는 타입이 구현해야 하는 메서드 원형 prototype 을 정의한다. → 추상화를 제공 디자인패턴 측면에서 client의 입장 → 인터페이스에 정의된 메소드의 동작을 보장하므로 정확한 class의 구현방법을 몰라도 된다. 클래스간의 결합도 감소 → 유지보수성 향상, 기능 추가 용이성, 독립적인 프로그래밍 가능 인터페이스를 구현하기 위해서는 해당 타입이 그 인터페이스 메서드들이 모두 구현되어야 한다. 인터페이스 선언 type 인터페이스명 interface { 메소드1() 반환 값(타입 형) 메소드2() // 반환 값이 없을 경우 } ","date":"2021-04-13","objectID":"/archives/golang/easy-golang-section8/:1:1","tags":["go","golang"],"title":"Section 8 : Go 객체지향","uri":"/archives/golang/easy-golang-section8/"},{"categories":["Easy Go"],"content":"8.1.2 Empty Interface 메서드를 전혀 갖지 않는 빈 인터페이스 go에서 모든 Type을 나타내기 위해 빈 인터페이스를 사용한다. → 빈 인터페이스는 어떠한 타입도 담을 수 있는 컨테이너다. type test interface {} // 빈 인터페이스 ... var t test fmt.Println(\"Example 1\", t) // 빈(Empty) 인터페이스일 경우 Nil을 리턴한다. package main import \"fmt\" type Dog struct { name string weight int } type Cat struct { name string weight int } func printValue(s interface{}) { fmt.Println(\"Example 1 : \", s) } func main() { dog := Dog{\"poll\", 10} cat := Cat{\"bob\", 5} printValue(dog) printValue(cat) printValue(15) printValue(\"Animals\") printValue(25.5) printValue([]Dog{}) printValue([5]Dog{}) } ","date":"2021-04-13","objectID":"/archives/golang/easy-golang-section8/:1:2","tags":["go","golang"],"title":"Section 8 : Go 객체지향","uri":"/archives/golang/easy-golang-section8/"},{"categories":["Easy Go"],"content":"8.1.3 인터페이스 사용 인터페이스 구현 예제 package main import \"fmt\" type Dog struct { name string weight int } // bite 메소드를 구현 func (d Dog) bite() { fmt.Println(d.name, \" bites!\") } // 동물의 행동 인터페이스 선언 type Behavior interface { bite() } func main() { dog1 := Dog{\"poll\", 10} var interface1 Behavior interface1 = dog1 interface1.bite() // Example 2 dog2 := Dog{\"marry\", 12} interface2 := Behavior(dog2) interface2.bite() // Example 3 interface3 := []Behavior{dog1, dog2} // 인덱스 형태로 실행 for idx, _ := range interface3 { interface3[idx].bite() } // 값 형태로 실행(인터페이스) for _, val := range interface3 { val.bite() } } ","date":"2021-04-13","objectID":"/archives/golang/easy-golang-section8/:1:3","tags":["go","golang"],"title":"Section 8 : Go 객체지향","uri":"/archives/golang/easy-golang-section8/"},{"categories":["Easy Go"],"content":"8.1.3 덕타이핑 구조체 및 변수의 값이나 타입은 상관하지 않고 오로지 구현된 메소드로만 판단하는 방식 Go의 덕타이핑의 중요한 특징 오리처럼 걷고, 소리내고, 헤엄 등 행동이 같으면 오리라고 볼 수 있다. 🦆 인터페이스의 정의된 메소드 사용을 유도한다. 코드의 가독성 및 유지보수 package main import \"fmt\" type Dog struct { name string weight int } type Cat struct { name string weight int } // 구조체 Dog 메소드 구현 func (d Dog) bite() { fmt.Println(d.name, \"Dog bites!\") } func (d Dog) sounds() { fmt.Println(d.name, \"Dog barks!\") } func (d Dog) run() { fmt.Println(d.name, \"Dog is running!\") } // 구조체 Cat 메소드 구현 func (c Cat) bite() { fmt.Println(c.name, \"Cat 할퀴다!\") } func (c Cat) sounds() { fmt.Println(c.name, \"Cat cries!\") } func (c Cat) run() { fmt.Println(c.name, \"Cat is running!\") } // 동물의 행동 인터페이스 선언 type Behavior interface { bite() sounds() run() } // 인터페이스를 파라미터로 받는다. func act(animal Behavior) { animal.bite() animal.sounds() animal.run() } func main() { // Example 1 dog := Dog{\"poll\", 10} cat := Dog{\"bob\", 5} act(dog) act(cat) } ","date":"2021-04-13","objectID":"/archives/golang/easy-golang-section8/:1:4","tags":["go","golang"],"title":"Section 8 : Go 객체지향","uri":"/archives/golang/easy-golang-section8/"},{"categories":["Easy Go"],"content":"8.1.4 익명 인터페이스 사용 package main import \"fmt\" type Dog struct { name string weight int } type Cat struct { name string weight int } // 구조체 Dog 메소드 구현 func (d Dog) run() { fmt.Println(d.name, \"Dog is running!\") } // 구조체 Cat 메소드 구현 func (c Cat) run() { fmt.Println(c.name, \"Cat is running!\") } // 익명 인터페이스 (타입 정의 X) func act(animal interface{run()}) { animal.run() } func main() { // Example 1 dog := Dog{\"poll\", 10} cat := Dog{\"bob\", 5} act(dog) act(cat) } ","date":"2021-04-13","objectID":"/archives/golang/easy-golang-section8/:1:5","tags":["go","golang"],"title":"Section 8 : Go 객체지향","uri":"/archives/golang/easy-golang-section8/"},{"categories":["Easy Go"],"content":"8.1.5 Type Assertion 실행(런타임) 시에 인터페이스에 할당한 변수는 실제 타입으로 변환 후 사용해야 하는 경우 인터페이스.(타입) package main import ( \"fmt\" \"reflect\" ) func main() { var a interface{} = 15 b := a c := a.(int) // 실행시에 에러가 발생한다. // d := a.(float64) // panic: interface conversion: interface {} is int, not float64 fmt.Println(\"Example 1 : \", a) fmt.Println(\"Example 1 : \", reflect.TypeOf(a)) fmt.Println(\"Example 1 : \", b) fmt.Println(\"Example 1 : \", reflect.TypeOf(b)) fmt.Println(\"Example 1 : \", c) fmt.Println(\"Example 1 : \", reflect.TypeOf(c)) // fmt.Println(\"Example 1 : \", d) // Example 2 - 저장된 실제 타입 검사 if v, ok := a.(int); ok { fmt.Println(\"Example 2 : \", v, ok) } } switch 문을 활용하여 형변환 package main import \"fmt\" func checkType(arg interface{}) { // arg.(type) 을 통해서 현재 데이터형 반환 switch arg.(type) { case bool: fmt.Println(\"This is a bool\", arg) case int, int8, int16, int32, int64: fmt.Println(\"This is a int\", arg) case float32, float64: fmt.Println(\"This is a int\", arg) case string: fmt.Println(\"This is a string\", arg) case nil: fmt.Println(\"This is a nil\", arg) default: fmt.Println(\"What is this type?\", arg) } } func main() { // 실제 타입 검사 switch 사용 // 빈 인터페이스는 어떠한 자료형도 전달 받을 수 있으므로, 타입 체크를 통해 형 변환 후 사용 가능 // Example 1 checkType(true) checkType(1) checkType(22.542) checkType(nil) checkType(\"Hello Golang!\") } ","date":"2021-04-13","objectID":"/archives/golang/easy-golang-section8/:1:6","tags":["go","golang"],"title":"Section 8 : Go 객체지향","uri":"/archives/golang/easy-golang-section8/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:0:0","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.1 함수 기초 ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:1:0","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.1.1 함수 여러 문장을 묶어서 실행하는 코드 블럭 단위 func 키워드를 사용하여 정의한다. 타 언어와 달리 변환 값 return value 다수 가능 func 함수명(매개변수) (반환타입 or 반환 값 변수명) : 반환 값 존재 func 함수명() (반환타입 or 반환 값 변수명) : 매개변수 없음, 반환 값 존재 func 함수명(매개변수) : 매개변수 존재, 반환 값 없음 func 함수명() : 매개변수 없음, 반환값 없음 함수 사용 예제 package main import ( \"fmt\" \"strconv\" ) // 함수 선언 위치는 어느 곳이 든 가능 func helloGoLang() { // 매개변수 X, 반환값 x fmt.Println(\"Example 1 : Hello, GoLang\") } func say_one(m string) { fmt.Println(\"Example 2 : \", m) } func sum(x int, y int) int { return x + y } // 함수 기초 func main() { // Example 1 helloGoLang() // Example 2 say_one(\"Hello World!\") // Example 3 result := sum(5, 5) fmt.Println(\"Example 3 : \", result) fmt.Println(\"Example 3 : \", sum(5, 5)) fmt.Println(\"Example 3 : \", strconv.Itoa(sum(5,5))) } Result Example 1 : Hello, GoLang Example 2 : Hello World! Example 3 : 10 Example 3 : 10 Example 3 : 10 ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:1:1","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.1.2 매개변수 전달 Go에서 파라미터를 전달하는 방식 함수(콜백)전달 값 전달call by value 참조 전달call by reference 로 나뉜다. package main import \"fmt\" // 함수(콜백)전달 func sum(i int, f func(int, int)) { f(i, 10) } func add(a, b int) { fmt.Println(\"Example 1 : \", a + b) } // 값 전달call by value func multi_value(i int) { i = i * 10 } // 참조 전달call by reference func multi_reference(i *int) { *i *= 10 // *i = *i * 10 } func main() { sum(100, add) // 매개변수로 함수를 전달 // Example 2 a := 100 multi_value(a) fmt.Println(\"Example 2 : \", a) // Example 3 b := 100 multi_reference(\u0026b) fmt.Println(\"Example 3 :\", b) } Result Example 1 : 110 Example 2 : 100 Example 3 : 1000 ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:1:2","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.1.3 함수의 리턴 값 Go에서는 리턴값은 복수 개도 지원한다. Multi Return Value 예제 package main import \"fmt\" func multiply(x, y int) (int, int) { return x * 10, y * 10 } func arrayMultiply(a, b, c, d, e int) (int, int, int, int, int) { return a * 1, b * 2, c * 3, d * 4, e * 5 } func main() { // 다중 값 반환 a, b := multiply(10, 5) // c := multiply(10 , 5) c, _ := multiply(10, 5) _, d := multiply(10, 5) fmt.Println(\"Example 1 :\", a, b) fmt.Println(\"Example 1 :\", c) fmt.Println(\"Example 1 :\", d) // Example 2 x1, x2, x3, x4, x5 := arrayMultiply(1, 2, 3, 4, 5) y1, _, y3, _, y5 := arrayMultiply(1, 2, 3, 4, 5) fmt.Println(\"Example 2 : \", x1, x2, x3, x4, x5) fmt.Println(\"Example 2 : \", y1, y3, y5) } Go에서는 리턴되는 값들을 (함수에 정의된) 리턴 파라미터들에 할당할 수 있다. Named Return Parameter 예제 package main import \"fmt\" func multiply(x, y int) (r1, r2 int) { r1 = x * 10 r2 = y * 20 return r1, r2 } func multiply2(x, y int) (int, int) { return x * 10, y * 20 } func main() { // 리턴 값 변수 사용 a, b := multiply(10, 5) fmt.Println(\"Example 1 : \", a, b) // Example 2 c, d := multiply2(10, 5) fmt.Println(\"Example 2 : \", c, d) } ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:1:3","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.1.4 가변 인자 함수 Variadic Function 함수에 고정된 수의 파라미터를 전달하지 않고 다양한 숫자의 파라미터를 전달하고자 할때 사용 … 예약어를 사용한다. package main import \"fmt\" func multiply(n ...int) int { tot := 1 for _, value := range n { tot *= value } return tot } func sum(n ...int) int { tot := 0 for _, value := range n { tot += value } return tot } func prtWord(msg ...string) { for _, value := range msg { fmt.Println(\"Print Word -\u003e \", value) } } func main() { // 함수 고급 // 가변 인자 실습 : 매개 변수 개수가 동적으로 변할 때 - 정해져 있지 않음. // Example 1 x := multiply(5, 6, 7, 8, 9, 10) y := sum(1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13) fmt.Println(\"x -\u003e \", x) fmt.Println(\"y -\u003e \", y) fmt.Println() // Example 2 prtWord(\"A\", \"F\", \"test\", \"golang\", \"seoul\") // Example 3 a := []int{5, 6, 7, 8, 9, 10} m := multiply(a...) n := sum(a...) fmt.Println() fmt.Println(\"Slice Parameter -\u003e \", m) fmt.Println(\"Slice Parameter -\u003e\", n) } Result x -\u003e 151200 y -\u003e 91 Print Word -\u003e A Print Word -\u003e F Print Word -\u003e test Print Word -\u003e golang Print Word -\u003e seoul Slice Parameter -\u003e 151200 Slice Parameter -\u003e 45 함수를 변수에 할당 package main import \"fmt\" func multiply(x, y int) (r int) { r = x * y return r } func sum(x, y int) (r int) { r = x + y return r } func main() { // Example 1 - 슬라이스에 할당 f := []func(int, int) int {multiply, sum} a := f[0](10, 10) b := f[1](10, 10) fmt.Println(\"슬라이스에 함수 할당 -\u003e\", a, f[0](10,10)) fmt.Println(\"슬라이스에 함수 할당 -\u003e\", b, f[1](10,10)) fmt.Println() // Example 2 - 변수에 할당 var f1 func(int, int) int = multiply f2 := sum fmt.Println(\"변수에 함수 할당 -\u003e\", f1(10, 10)) fmt.Println(\"변수에 함수 할당 -\u003e\", f2(10, 10)) fmt.Println() // Example 3 - 맵에 할당 m := map[string] func(int, int) int{ \"mul_func\" : multiply, \"sum_func\" : sum, } fmt.Println(\"Map에 함수 할당\", m[\"mul_func\"](10, 10)) fmt.Println(\"Map에 함수 할당\", m[\"sum_func\"](10, 10)) } Result 슬라이스에 함수 할당 -\u003e 100 100 슬라이스에 함수 할당 -\u003e 20 20 변수에 함수 할당 -\u003e 100 변수에 함수 할당 -\u003e 20 Map에 함수 할당 100 Map에 함수 할당 20 ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:1:4","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.1.5 재귀 함수 Recursion 장점 : 프로그램이 보기 쉽고, 코드가 간결, 오류 수정이 용이하다. 단점 : 코드를 이해하기 어렵고, 기억공간을 많이 사용, 무한루프 가능성이 있다. 팩토리얼 재귀함수 예제 package main import \"fmt\" func fact(n int) int { if n == 0 { return 1 } return n * fact(n - 1) } func prtHello(n int) { if n == 0 { return } fmt.Println(\"Example 2 : (\", n, \")\", \" hi!\") prtHello(n - 1) } func main() { x := fact(7) fmt.Println(\"Example 1 : \", x) // Example 2 prtHello(10) } Result Example 1 : 5040 Example 2 : ( 10 ) hi! Example 2 : ( 9 ) hi! Example 2 : ( 8 ) hi! Example 2 : ( 7 ) hi! Example 2 : ( 6 ) hi! Example 2 : ( 5 ) hi! Example 2 : ( 4 ) hi! Example 2 : ( 3 ) hi! Example 2 : ( 2 ) hi! Example 2 : ( 1 ) hi! ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:1:5","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.1.6 익명함수 Anonymous Functions 선언과 동시에 즉시 실행 package main import \"fmt\" func main() { // Example 1 func() { fmt.Println(\"Example 1 : Anonymous Function !\") }() // Example 2 msg := \"Hello GoLang!\" func(m string) { fmt.Println(\"Example 2 : \", m) }(msg) // Example 3 func(x, y int) { fmt.Println(\"Example 3 :\", x + y) }(10, 20) // Example 4 r := func(x, y int) int { return x * y }(10, 100) fmt.Println(\"Example 4 : \", r) } Result Example 1 : Anonymous Function ! Example 2 : Hello GoLang! Example 3 : 30 Example 4 : 1000 ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:1:6","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.2 defer ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:2:0","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.2.1 지연실행 defer defer 키워드는 특정 문장 혹은 함수를 나중에 (defer를 호출하는 함수가 리턴하기 직전) 실행한다. 일반적으로 C#, java 같은 언어에서의 finally 블럭처럼 마지막에 clean-up 작업을 위해 사용된다. 리소스 반환, 열린 파일 닫기, Mutex 잠금 해제 등 사용 package main import \"fmt\" func ex_f2() { fmt.Println(\"f2 : called!\") } func ex_f1() { fmt.Println(\"f1 : start!\") defer ex_f2() // 마지막에 호출 된다. fmt.Println(\"f1 : end!\") } func main() { ex_f1() } Result f1 : start! f1 : end! f2 : called! 익명함수 defer 예제 package main import \"fmt\" func sayHello(msg string) { defer func() { fmt.Println(msg) }() func() { fmt.Println(\"Hi !\") }() } func main() { // Example 1 sayHello(\"GoLang\") } Result Hi ! GoLang ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:2:1","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.2.2 스택 defer 키워드를 사용하면 함수가 역순으로 실행되는 것을 볼 수 있다. 자료구조의 stack 과 동일하며, 제일 나중에 지연 호출한 함수가 제일 먼저 힐행된다. 후입선출 package main import \"fmt\" func stack() { for i := 1; i \u003c= 10; i++ { defer fmt.Println(\"Example 1 : \", i) } } func main() { // Example 1. stack() } Result Example 1 : 10 Example 1 : 9 Example 1 : 8 Example 1 : 7 Example 1 : 6 Example 1 : 5 Example 1 : 4 Example 1 : 3 Example 1 : 2 Example 1 : 1 중첩 함수에 defer 키워드를 사용할 경우 주의 사항 package main import \"fmt\" func start(t string) string { fmt.Println(\"start : \", t) return t } func end(t string) { fmt.Println(\"end : \", t) } func a() { defer end(start(\"b\")) // defer 문에 있는 end()만 적용됨. 중첩 함수 주의 ! -\u003e 웬만하면 사용하지 말것. fmt.Println(\"in a\") } func main() { // Example 1 a() } Result start : b in a end : b ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:2:2","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.3 Closure ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:3:0","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":"7.3 Closure란 익명함수는 함수를 변수에 할당할 수 있다. 함수 안에서 함수를 선언 및 정의 가능하며 이 때 외부 함수에 선언된 변수에 접근 가능하다. 함수가 선언되는 순간에 함수가 실행 될 때 실체의 외부 변수에 접근하기 위한 스냅샷(객체)이다. 함수를 호출 할 때 이전에 존재했던 값을 유지하기 위해 사용한다 비동기, 누적카운트, 무분별한 전역변수 남발을 피하기 위해 사용 전역변수 남발로 인해 메모리 부족, 오버플로우 현상, 리소스 남용을 방지 클로저를 정확하게 이해하고 사용하는 것이 중요 package main import \"fmt\" func main() { // Example 1 multiply := func(x, y int) int { // 익명함 return x * y } r1 := multiply(5, 10) fmt.Println(\"익명 함수 변수에 할당 -\u003e\", r1) // Example 2 m, n := 5, 10 // 지역변수 - 변수가 캡쳐 sum := func(c int) int { // 익명함수 변수 할당 return m + n + c // 지역 변수 소멸되지 않는다. (함수 호출 시 마다 사용 가능) } r2 := sum(10) fmt.Println(\"Closure 예제 -\u003e\", r2) } Result 익명 함수 변수에 할당 -\u003e 50 Closure 예제 -\u003e 25 카운팅 예제 package main import \"fmt\" func main() { // Example 1 cnt := increaseCnt() fmt.Println(\"Count -\u003e\", cnt()) fmt.Println(\"Count -\u003e\", cnt()) fmt.Println(\"Count -\u003e\", cnt()) fmt.Println(\"Count -\u003e\", cnt()) fmt.Println(\"Count -\u003e\", cnt()) anotherCnt := increaseCnt() fmt.Println(\"함수를 새로운 변수에 할당 시 초기화\") fmt.Println(\"Another Count -\u003e\", anotherCnt()) fmt.Println(\"Another Count -\u003e\", anotherCnt()) fmt.Println(\"Another Count -\u003e\", anotherCnt()) } func increaseCnt() func() int { n := 0 // 지역변수(캡쳐됨) return func() int { n += 1 return n } } Result Count -\u003e 1 Count -\u003e 2 Count -\u003e 3 Count -\u003e 4 Count -\u003e 5 함수를 새로운 변수에 할당 시 초기화 Another Count -\u003e 1 Another Count -\u003e 2 Another Count -\u003e 3 ","date":"2021-04-08","objectID":"/archives/golang/easy-golang-section7/:3:1","tags":["go","golang"],"title":"Section 7 : Go 함수","uri":"/archives/golang/easy-golang-section7/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:0:0","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.1 배열 ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:1:0","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.1 배열 배열은 용량, 길이가 항상 같다. cap() : 배열, 슬라이스 용량 len() : 배열, 슬라이스 길이 대부분은 슬라이스를 많이 사용한다. 배열과 슬라이스 차이점 배열 슬라이스 길이 고정여부 길이가 고정 되어 있다. 길이가 가변이다. 타입 여부 값 타입 참조 타입 전달 방식 값을 복사 전달 참조 값 전달 기타 전체 비교연산자 가능 전체 비교 연산자 사용 불가 배열 선언 예제 - 1 var arr1 [5]int var arr2 [5]int = [5]int{1, 2, 3, 4, 5} var arr3 = [5]int{1, 2, 3, 4, 5} arr4 := [5]int{1, 2, 3, 4, 5} arr5 := [5]int{1, 2, 3} arr6 := [...]int{1, 2, 3, 4, 5} // 배열 길이를 확신 할 수 없을 때. 잘 사용하지 않음. arr7 := [5][5]int{ {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, } arr1[2] = 5 fmt.Printf(\"%-5T %d %v\\n\", arr1, len(arr1), arr1) // %-5T 원 자료형 fmt.Printf(\"%-5T %d %v\\n\", arr2, len(arr2), arr2) fmt.Printf(\"%-5T %d %v\\n\", arr3, len(arr3), arr3) fmt.Printf(\"%-5T %d %v\\n\", arr4, len(arr4), arr4) fmt.Printf(\"%-5T %d %v\\n\", arr5, len(arr5), arr5) fmt.Printf(\"%-5T %d %v\\n\", arr6, len(arr6), arr6) fmt.Printf(\"%-5T %d %v\\n\", arr7, len(arr7), arr7) Result [5]int 5 [0 0 5 0 0] [5]int 5 [1 2 3 4 5] [5]int 5 [1 2 3 4 5] [5]int 5 [1 2 3 4 5] [5]int 5 [1 2 3 0 0] [5]int 5 [1 2 3 4 5] [5][5]int 5 [[1 2 3 4 5] [6 7 8 9 10] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]] 배열 선언 예제 - 2 arr8 := [5]int{1, 2, 3, 4, 5} arr9 := [5]int{ 1, 2, 3, 4, 5, } arr10 := [...]string{\"kim\", \"lee\", \"park\"} fmt.Printf(\"%-5T %d %v\\n\", arr8, len(arr8), arr8) fmt.Printf(\"%-5T %d %v\\n\", arr9, len(arr9), arr9) fmt.Printf(\"%-5T %d %v\\n\", arr10, len(arr10), arr10) Result [5]int 5 [1 2 3 4 5] [5]int 5 [1 2 3 4 5] [3]string 3 [kim lee park] ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:1:1","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.2 배열 순회 func main() { // 배열 순회 arr1 := [5]int{1, 10, 100, 1000, 10000} // len 길이 반복 for i := 0; i \u003c len(arr1); i++ { fmt.Println(\"Example 1 : \", arr1[i]) } arr2 := [5]int{7, 77, 777, 7777, 77777} // range for i, v := range arr2 { fmt.Println(\"Example 2 : \", i, v) } for _, v := range arr2 { fmt.Println(\"Example 3 : \", v) } for v := range arr2 { fmt.Println(\"Example 4 : \", v) // 인덱스가 출력 된다. } } Result Example 1 : 1 Example 1 : 10 Example 1 : 100 Example 1 : 1000 Example 1 : 10000 Example 2 : 0 7 Example 2 : 1 77 Example 2 : 2 777 Example 2 : 3 7777 Example 2 : 4 77777 Example 3 : 7 Example 3 : 77 Example 3 : 777 Example 3 : 7777 Example 3 : 77777 Example 4 : 0 Example 4 : 1 Example 4 : 2 Example 4 : 3 ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:1:2","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.3 배열 복사 값이 복사된다. 배열은 복사하여도 서로 다른 주소값을 갖게 된다. func main() { // 배열 복사 arr1 := [5]int{1, 10, 100, 1000, 10000} arr2 := arr1 fmt.Println(\"Example 1 : \", arr1, \u0026arr1) fmt.Println(\"Example 1 : \", arr2, \u0026arr2) fmt.Printf(\"Example 1 : %p %v\\n\", \u0026arr1, arr1) fmt.Printf(\"Example 1 : %p %v\\n\", \u0026arr2, arr2) } Result Example 1 : [1 10 100 1000 10000] \u0026[1 10 100 1000 10000] Example 1 : [1 10 100 1000 10000] \u0026[1 10 100 1000 10000] Example 1 : 0xc00010c030 [1 10 100 1000 10000] Example 1 : 0xc00010c060 [1 10 100 1000 10000] ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:1:3","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2 슬라이스 ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:2:0","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.1 슬라이스 길이가 가변이다. → 동적으로 크키가 늘어난다. 레퍼런스(참조 값) 타입 이다. 슬라이스(길이, 용량) 크기가 동적으로 할당이 가능하다. 부분 배열을 발췌할 수 있다. 선언 방법 배열처럼 선언한다. make 함수를 사용하여 선언한다. make 함수를 이용하면 슬라이스의 길이(length)와 용량(capacity)을 임의로 지정할 수 있다. make(자료형, 길이, 용량:생략시 길이) 슬라이스 선언 예제 - 1 // 배열 처럼 선언 var slice1 []int slice2 := []int{} slice3 := []int{1, 2, 3, 4, 5} // 슬라이스에 리터럴 값을 지정 slice4 := [][]int{ {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, } // slice2[0] = 1 // 길이가 가변형이기 때문에 초기화를 별도로 해야한다. slice3[4] = 10 // 값 수정 가능 fmt.Printf(\"%-5T %d %d %v\\n\", slice1, len(slice1), cap(slice1), slice1) fmt.Printf(\"%-5T %d %d %v\\n\", slice2, len(slice2), cap(slice2), slice2) fmt.Printf(\"%-5T %d %d %v\\n\", slice3, len(slice3), cap(slice3), slice3) fmt.Printf(\"%-5T %d %d %v\\n\", slice4, len(slice4), cap(slice4), slice4) Result []int 0 0 [] []int 0 0 [] []int 5 5 [1 2 3 4 10] [][]int 2 2 [[1 2 3 4 5] [6 7 8 9 10]] 슬라이스 선언 예제 - 2 var slice5 []int = make([]int, 5, 10) // 길이가 5이고 용량이 10인 슬라이스. 용량이 늘어날 경우에 var slice6 = make([]int, 5, 100) slice7 := make([]int, 5, 100) slice8 := make([]int, 5, 100) slice6[2] = 7 // make로 생성시 default 값으로 초기화된다. fmt.Printf(\"%-5T %d %d %v\\n\", slice5, len(slice5), cap(slice5), slice5) fmt.Printf(\"%-5T %d %d %v\\n\", slice6, len(slice6), cap(slice6), slice6) fmt.Printf(\"%-5T %d %d %v\\n\", slice7, len(slice7), cap(slice7), slice7) fmt.Printf(\"%-5T %d %d %v\\n\", slice8, len(slice8), cap(slice8), slice8) Result []int 5 10 [0 0 0 0 0] []int 5 100 [0 0 7 0 0] []int 5 100 [0 0 0 0 0] []int 5 100 [0 0 0 0 0] ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:2:1","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.2 Nil Slice 슬라이스에 별도의 길이와 용량을 지정하지 않으면 길이와 용량이 0인 슬라이스를 만든다. Nil Slice라고도 하며 nil과 비교하면 참을 리턴한다. var slice9 []int // int 슬라이스(길이와 용량이 0) if nil == slice9 { fmt.Println(\"This is Nil Slice!\") } Result This is Nil Slice! ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:2:2","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.3 슬라이스와 배열 슬라이스의 경우 참조 타입이므로 값 변경시 원본 값도 같이 변경된다. // 배열 arr1 := [3]int{1, 2, 3} var arr2 [3]int arr2 = arr1 arr2[0] = 7 fmt.Println(\"Array Example 1 : \", arr1) fmt.Println(\"Array Example 1 : \", arr2) // 슬라이스 slice1 := []int{1, 2, 3} var slice2 []int slice2 = slice1 slice2[0] = 7 fmt.Println(\"Slice Example 2 : \", slice1) fmt.Println(\"Slice Example 2 : \", slice2) Result Array Example 1 : [1 2 3] Array Example 1 : [7 2 3] // 슬라이스는 참조 타입이므로 값 변경시 원본 값도 같이 변경된다. Slice Example 2 : [7 2 3] Slice Example 2 : [7 2 3] ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:2:3","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.4 슬라이스 예외 make 함수로 슬라이스 초기화 시 길이 만큼 초기화 된다. slice3 := make([]int, 50, 100) fmt.Println(\"Example 3 : \", slice3[4]) // fmt.Println(\"Example 3 : \", slice3[50]) // Error ! 길이 만큼 초기화 된다. ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:2:4","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.5 부분 슬라이스(Sub-slice) 슬라이스에서 일부를 발췌하여 부분 슬라이스를 만들 수 있다. 슬라이스[처음인덱스:마지막인덱스] : 처음인덱스는 inclusive 마지막인덱스는 exclusive slice[i:j] i -\u003e j-1 까지 추출 slice[i:] i -\u003e 마지막 까지 추출 slice[:j] 처음부터 -\u003e j-1 까지 추출 slice[:] 처음부터 -\u003e 마지막 까지 추출 slice1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} fmt.Println(\"Example 1 :\", slice1[:]) fmt.Println(\"Example 1 :\", slice1[0:]) fmt.Println(\"Example 1 :\", slice1[:5]) fmt.Println(\"Example 1 :\", slice1[0:len(slice1)]) fmt.Println(\"Example 1 :\", slice1[3:]) fmt.Println(\"Example 1 :\", slice1[1:3]) Result Example 1 : [1 2 3 4 5 6 7 8 9 10] Example 1 : [1 2 3 4 5 6 7 8 9 10] Example 1 : [1 2 3 4 5] Example 1 : [1 2 3 4 5 6 7 8 9 10] Example 1 : [4 5 6 7 8 9 10] Example 1 : [2 3] ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:2:5","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.6 슬라이스 추가 append 배열은 고정된 크기로 그 크기 이상의 임의의 데이터를 추가할 수 없지만 슬라이스는 자유롭게 추가할 수 있다. 용량에 따라 용량(capacity)이 아직 남아 있는 경우 : 용량 내에서 슬라이스 길이(length)를 변경하여 데이터를 추가한다. 용량(capacity)을 초과하는 경우 : 현재 용량의 두 배에 해당하는 새로운 Underlying array을 생성하고 기존 배열 값들을 모두 새 배열에 복제한 후 다시 새로운 슬라이스를 할당한다. 슬라이스 끼리 병합할때 두번째 슬라이스 뒤에는 …(ellipsis) 을 붙인다. ellipsis는 해당 슬라이스의 컬렉션을 표현하는 것으로 두번째 슬라이스의 모든 요소들의 집합을 나타낸다. s1 := []int{1, 2, 3, 4, 5} s2 := []int{8, 9, 10, 11, 12} s3 := []int{13, 14, 15, 16, 17} fmt.Printf(\"[Example 1] s1 =\u003e %d\", cap(s1)) s1 = append(s1, 6, 7) s2 = append(s1, s2...) // 슬라이스 뒤에 슬라이스 삽입할 경우 ... 사용 s3 = append(s2, s3[0:3]...) // 추출 후 병합 fmt.Printf(\"[Example 1] s1 =\u003e %d\", cap(s1)) fmt.Println(\"[Example 1] s1 =\u003e\", s1) fmt.Println(\"[Example 1] s2 =\u003e\", s2) fmt.Println(\"[Example 1] s3 =\u003e\", s3) Result [Example 1] s1 =\u003e 5 [Example 1] s1 =\u003e [1 2 3 4 5 6 7] [Example 1] s2 =\u003e [1 2 3 4 5 6 7 8 9 10 11 12] [Example 1] s3 =\u003e [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] s4 := make([]int, 0, 5) for i := 0; i \u003c 15; i++ { s4 = append(s4, i) fmt.Printf(\"Example 2 -\u003e len : %d, cap: %d, value : %v\\n\", len(s4), cap(s4), s4) // 길이 및 용량 자동 증가 } Result Example 2 -\u003e len : 1, cap: 5, value : [0] Example 2 -\u003e len : 2, cap: 5, value : [0 1] Example 2 -\u003e len : 3, cap: 5, value : [0 1 2] Example 2 -\u003e len : 4, cap: 5, value : [0 1 2 3] Example 2 -\u003e len : 5, cap: 5, value : [0 1 2 3 4] Example 2 -\u003e len : 6, cap: 10, value : [0 1 2 3 4 5] Example 2 -\u003e len : 7, cap: 10, value : [0 1 2 3 4 5 6] Example 2 -\u003e len : 8, cap: 10, value : [0 1 2 3 4 5 6 7] Example 2 -\u003e len : 9, cap: 10, value : [0 1 2 3 4 5 6 7 8] Example 2 -\u003e len : 10, cap: 10, value : [0 1 2 3 4 5 6 7 8 9] Example 2 -\u003e len : 11, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10] Example 2 -\u003e len : 12, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10 11] Example 2 -\u003e len : 13, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10 11 12] Example 2 -\u003e len : 14, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10 11 12 13] Example 2 -\u003e len : 15, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14] ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:2:6","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.7 슬라이스 copy() copy(복사 대상, 원본) 반드시 초기화를 하여 공간을 할당한 후 복사 해야 한다. 복사 된 슬라이스 값을 변경해도 원본에는 영향이 없다. 부분적으로 슬라이스 추출은 참조 타입 func main() { // Example 1 slice1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} slice2 := make([]int, 5) slice3 := []int{} copy(slice2, slice1) // slice2 가 용량이 5이므로 5만 복사 copy(slice3, slice2) // 복사안됨 fmt.Println(\"Example 1 :\", slice2) fmt.Println(\"Example 1 :\", slice3) // Example 2 a := []int{1, 2, 3, 4, 5} b := make([]int, 5) copy(b, a) // 가변길이로 배열처럼 사용할 수 있다. b[0] = 7 b[4] = 10 fmt.Println(\"Example 2 : \", a) // 원본 값이 변경되지 않는다. fmt.Println(\"Example 2 : \", b) // Example 3 // 주의! 부분적으로 슬라이스 추출은 참조 -\u003e 원본 값이 변경된다. c := [5]int{1, 2, 3, 4, 5} d := c[0:3] d[1] = 7 fmt.Println() fmt.Println(\"Example 3 :\", c) fmt.Println(\"Example 3 :\", d) // Example 4 e := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} f := e[0:5:7] // 용량 지정 f[0] = 99 fmt.Println(\"Example 4 :\", e) fmt.Println(\"Example 4 :\", len(f), cap(f)) fmt.Println(\"Example 4 :\", f) } Result Example 1 : [1 2 3 4 5] Example 1 : [] Example 2 : [1 2 3 4 5] Example 2 : [7 2 3 4 10] Example 3 : [1 7 3 4 5] Example 3 : [1 7 3] Example 4 : [99 2 3 4 5 6 7 8 9 10] Example 4 : 5 7 Example 4 : [99 2 3 4 5] ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:2:7","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.2.8 슬라이스 정렬 sort 패키지 → https://golang.org/pkg/sort package main import ( \"fmt\" \"sort\" ) func main() { slice2 := []int{3, 6, 10, 9, 1, 4, 5, 8, 2, 7} slice3 := []string{\"b\", \"d\", \"f\", \"a\", \"c\", \"e\"} fmt.Println(\"Example 2 : \", sort.IntsAreSorted(slice2)) // 정렬 확인 sort.Ints(slice2) // 정렬 fmt.Println(\"Example 2 :\", slice2) fmt.Println() fmt.Println(\"Example 2 : \", sort.StringsAreSorted(slice3)) sort.Strings(slice3) fmt.Println(\"Example 2 : \", sort.StringsAreSorted(slice3)) } Result Example 2 : false Example 2 : true ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:2:8","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.3 맵 Map ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:3:0","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.3.1 Map 키에 대응하는 값 value으로 자료를 저장하는 해시테이블을 구현한 자료구조 hashtable, dictionary-python reference 타입으로 참조값을 전달한다. 참조타입은 키로 사용 불가능하고 값으로 모든 타입을 사용 가능하다. make 함수와 축약(리터럴)로 초기화가 가능하다. var map1 map[string]int = make(map[string]int) // 정석 var map2 = make(map[string]int) // 자료형 생략 map3 := make(map[string]int) map4 := map[string]int{} // JSON 형태 // 리터럴을 사용한 초기화 map5 := map[string]int{ \"apple\" : 15, \"banana\" : 40, \"orange\" : 23, } 맵 선언 예제 package main import \"fmt\" func main() { // Example 1 var map1 map[string]int = make(map[string]int) // 정석 var map2 = make(map[string]int) // 자료형 생략 map3 := make(map[string]int) fmt.Println(\"Example 1 :\", map1) fmt.Println(\"Example 1 :\", map2) fmt.Println(\"Example 1 :\", map3) fmt.Println() // Example 2 map4 := map[string]int{} // JSON 형태 map4[\"apple\"] = 25 map4[\"banana\"] = 40 map4[\"orange\"] = 33 map5 := map[string]int{ \"apple\" : 15, \"banana\" : 40, \"orange\" : 23, } map6 := make(map[string]int, 10) map6[\"apple\"] = 25 map6[\"banana\"] = 40 map6[\"orange\"] = 23 fmt.Println(\"Example 2 : \", map4) fmt.Println(\"Example 2 : \", map5) fmt.Println(\"Example 2 : \", map6) fmt.Println(\"Example 2 : \", map6[\"apple\"]) fmt.Println(\"Example 2 : \", map4[\"banana\"]) } Result Example 1 : map[] Example 1 : map[] Example 1 : map[] \\ Example 2 : map[apple:25 banana:40 orange:33] Example 2 : map[apple:15 banana:40 orange:23] Example 2 : map[apple:25 banana:40 orange:23] \\ Example 2 : 25 Example 2 : 40 ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:3:1","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.3.2 맵 조회 및 순회 (Iterator) Map이 가지고 있는 모든 요소를 출력하기 위해 for-range 루프를 사용할 수 있다. func main() { map1 := map[string]string { \"daum\" : \"https://www.daum.net\", \"naver\" : \"https://www.naver.com\", \"google\" : \"https://www.google.com\", } fmt.Println(\"Example 1 : \", map1[\"google\"]) fmt.Println(\"Example 1 : \", map1[\"daum\"]) fmt.Println() // Example 2 for k, v := range map1 { fmt.Println(\"Example 2 : \", k, v) } fmt.Println() for _, v := range map1 { fmt.Println(\"Example 2 : \", v) } } Result Example 1 : https://www.google.com Example 1 : https://www.daum.net Example 2 : google https://www.google.com Example 2 : daum https://www.daum.net Example 2 : naver https://www.naver.com Example 2 : https://www.daum.net Example 2 : https://www.naver.com Example 2 : https://www.google.com ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:3:2","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.3.3 맵 사용 맵변수명[키] = 값 과 같이 해당 키에 값을 할당 할 수 있다. map안에 찾는 키가 존재하지 않는다면 참조 타입의 경우 nil 을 값 타입인 경우 0을 리턴한다. delete(삭제할 값의 키) 로 데이터를 삭제할 수 있다. package main import \"fmt\" func main() { map1 := map[string]string { \"daum\" : \"https://www.daum.net\", \"naver\" : \"https://www.naver.com\", \"google\" : \"https://www.google.com\", \"home1\" : \"http://127.0.0.1\", } fmt.Println(\"Example 1 : \", map1) map1[\"home2\"] = \"http://localhost\" // 추가 fmt.Println(\"Example 1 : \", map1) map1[\"home2\"] = \"http://127.0.0.1\" // 수정 fmt.Println(\"Example 1 :\", map1) // Example 2 - delete delete(map1, \"home2\") fmt.Println(\"Example 1 :\", map1) } ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:3:3","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.3.4 맵 키 체크 Go에서는 map변수[키] 읽기를 수행할 때 두개의 리턴 값을 리턴한다. 첫번째는 키에 상응하는 값이고 두번째는 키가 존재하는지 아닌지를 나타내는 bool 값이다. package main import \"fmt\" func main() { // Example 1 map1 := map[string]int { \"apple\" : 25, \"banana\" : 115, \"orange\" : 1115, \"lemon\" : 0, } value1 := map1[\"lemon\"] value2, ok2 := map1[\"banana\"] value3, ok := map1[\"kiwi\"] fmt.Println(value1) fmt.Println(value2, \",\", ok2) fmt.Println(value3, \",\", ok) // 두 번째 리턴 값으로 키 존재 유무 확인 // Example 2 if value, ok := map1[\"kiwi\"]; ok { fmt.Println(\"Example 2 : \", value) } else { fmt.Println(\"Example 2 : kiwi is not exists\") } // 키가 존재하는지만 if _, ok := map1[\"kiwi\"]; !ok { fmt.Println(\"kiwi is not exists\") } } ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:3:4","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.4 포인터 ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:4:0","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.4.1 포인터 Go 언어는 포인터를 지원한다. 변수 지역성, 연속된 메모리 참조, 힙, 스택 … 주소의 값은 직접 변경이 불가능하다 → 잘못된 코딩으로 인한 버그 방지 *(asterisk) 로 사용한다. var a *int // pinter nil var b *int = new(int) 포인터 예제 - 1 package main import \"fmt\" // 자료형 포인터 1 func main() { var a *int // 방법1 var b *int = new(int) // 방법2 fmt.Println(a) // nil fmt.Println(b) i := 7 fmt.Println(\"Example 1 : \", i, \u0026i) a = \u0026i // 주소값을 전달 b = \u0026i // 주소값을 전달 fmt.Println(\"Example 1 : \", a, \u0026i) // i의 주소값, i의 주소값 fmt.Println(\"Example 1 : \", \u0026a) // i의 주소값이 저장되어있는 a의 주소값 fmt.Println(\"Example 1 : \", *a) // 역참조 fmt.Println() fmt.Println(\"Example 1 : \", b, \u0026i) fmt.Println(\"Example 1 : \", \u0026b) // i의 주소값이 저장되어있는 b의 주소값 fmt.Println(\"Example 1 : \", *b) // 역참조 var c = \u0026i d := \u0026i *d = 10 // 참조하고있는 값을 변경. fmt.Println() fmt.Println(\"Example 1 : \", c, \u0026i) fmt.Println(\"Example 1 : \", \u0026c) // i의 주소값이 저장되어있는 b의 주소값 fmt.Println(\"Example 1 : \", *c) // 역참조 fmt.Println() fmt.Println(\"Example 1 : \", d, \u0026i) fmt.Println(\"Example 1 : \", \u0026d) // i의 주소값이 저장되어있는 b의 주소값 fmt.Println(\"Example 1 : \", *d) // 역참조 } 포인터 예제 2 package main import \"fmt\" func main() { i := 7 p := \u0026i fmt.Println(\"Example 1 :\", i, *p, \u0026i, p) *p++ // 1증가 fmt.Println(\"Example 1 :\", i, *p, \u0026i, p) *p = 7777 // 포인터 변수 역 참조 값 변경 fmt.Println(\"Example 1 :\", i, *p, \u0026i, p) i = 77 fmt.Println(\"Example 1 :\", i, *p, \u0026i, p) } Result Example 1 : 7 7 0xc0000140e8 0xc0000140e8 Example 1 : 8 8 0xc0000140e8 0xc0000140e8 Example 1 : 7777 7777 0xc0000140e8 0xc0000140e8 Example 1 : 77 77 0xc0000140e8 0xc0000140e8 ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:4:1","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":"6.4.2 포인터 값 전달 함수, 메서드 호출시에 매개변수 값을 복사 전달 → 함수, 메서드 내에서는 원본 값 변경이 불가능하다. 원본 값 변경을 위해 포인터로 전달 크기가 큰 배열의 경우 복사시 시스템에 큰 부담 → 포인터로 전달 해결(슬라이스, 맵이 참조전달이기 때문) → 배열도 포인터 전달로 참조전달 할 수 있다. package main import \"fmt\" func rptc(n *int) { *n = 77 } func vptc(n int) { n = 77 } func main() { // Example var a int = 10 var b int = 10 fmt.Println(\"Example 1 : \", a) // 10 fmt.Println(\"Example 1 : \", b) // 10 fmt.Println() rptc(\u0026a) vptc(b) fmt.Println(\"Example 2 : \", a) // 77 fmt.Println(\"Example 2 : \", b) // 10 } ","date":"2021-04-06","objectID":"/archives/golang/easy-golang-section6/:4:2","tags":["go","golang"],"title":"Section 6 : 배열, 슬라이스, 맵","uri":"/archives/golang/easy-golang-section6/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:0:0","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.1 Bool boolean 타입 : 참, 거짓 조건부 논리 연산자와 주로 함께 사용한다. !, ||(or) \u0026\u0026(and) 암묵적인 형 변환은 불가능하다. 0, Nil → false 변환 불가능 예제 1 var b1 bool = true var b2 bool = false b3 := true // b4 := 1 // Error! fmt.Println(\"############ Example 1 ############\") fmt.Println(\"b1 : \", b1) // true fmt.Println(\"b2 : \", b2) // false fmt.Println(\"b3 : \", b3) // true fmt.Println(\"b3 == b3 :\", b3 == b3) // true fmt.Println(\"b1 \u0026\u0026 b3 :\", b1 \u0026\u0026 b3) // true fmt.Println(\"b1 || b2 :\", b1 || b2) // true fmt.Println(\"!b1 :\", !b1) // false // 암묵적인 형 변환은 일어나지 않는다. /*if b4 { fmt.Println(\"Example \", b4) }*/ 예제 2 // 논리연산자 fmt.Println(\"############ Example 1 ############\") fmt.Println(true \u0026\u0026 true) // true fmt.Println(true \u0026\u0026 false) // false fmt.Println(false \u0026\u0026 false) // false fmt.Println(true || true) // true fmt.Println(true || false) // true fmt.Println(false || false) // false fmt.Println(!true) // false fmt.Println(!false) // true // Example 2 비교연산자 num1 := 15 num2 := 37 fmt.Println(\"############ Example 2 ############\") fmt.Println(num1 \u003c num2) // true fmt.Println(num1 \u003e num2) // flase fmt.Println(num1 \u003e= num2) // false fmt.Println(num1 \u003c= num2) // true fmt.Println(num1 == num2) // false fmt.Println(num1 != num2) // true ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:1:0","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.2 numeric type ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:2:0","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.2.1 numeric 기초 정수, 실수, 복소수 32bit, 64bit, unsigned 정수 : 8진수 0 , 16진수 0x, 10진수 Example 1 var num1 int = 17 var num2 int = -68 var num3 int = 0631 var num4 int = 0x32fa2c75 fmt.Println(\"ex1 : \", num1) // 17 fmt.Println(\"ex1 : \", num2) // -68 fmt.Println(\"ex1 : \", num3) // 409 fmt.Println(\"ex1 : \", num4) // 855256181 Example 2 : 정수형 문자 출력 fmt.Printf : 포맷 출력 %c : 문자 %d : decimal %o : 8진수 %x : 16진 ASCII 영문 var char1 byte = 72 // byte (=uint8) var char2 byte = 0110 var char3 byte = 0x48 fmt.Printf(\"%c %c %c\\n\", char1, char2, char3) // H H H fmt.Printf(\"%d %d %d\\n\", char1, char2, char3) // 72 72 72 fmt.Printf(\"%d %o %x\\n\", char1, char2, char3) // 72 110 48 Unicode 한글 var char4 rune = 50556 // 유니코드 var char5 rune = 0142574 // 44032(8진수) var char6 rune = 0xC57C // 44032(16진수) fmt.Printf(\"%c %c %c\\n\", char4, char5, char6) // 야 야 야 fmt.Printf(\"%d %d %d\\n\", char4, char5, char6) // 50556 50556 50556 fmt.Printf(\"%d %o %x\\n\", char4, char5, char6) // 50556 142574 c57c ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:2:1","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.2.2 실수 - 부동소수점 float32 : 7자리 float64 : 15자리 var num1 float32 = 0.14 var num2 float32 = .75647 var num3 float32 = 442.0378373 var num4 float32 = 10.0 // 지수 표기법 var num5 float32 = 14e6 var num6 float64 = .156875E+3 var num7 float64 = 5.32521e-10 fmt.Println(\"Example 1 : \", num1) // 0.14 fmt.Println(\"Example 1 : \", num2) // 0.75647 fmt.Println(\"Example 1 : \", num3) // 442.03784 fmt.Println(\"Example 1 : \", num4) // 10 fmt.Println(\"Example 1 : \", num4 - 0.1) // 9.9 fmt.Println(\"Example 1 : \", float32(num4 - 0.1)) // 9.9 fmt.Println(\"Example 1 : \", float64(num4 - 0.1)) // 9.899999618530273 주의! fmt.Println(\"Example 1 : \", num5) // 1.4e+07 fmt.Println(\"Example 1 : \", num6) // 156.875 fmt.Println(\"Example 1 : \", num7) // 5.32521e-10 ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:2:2","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.2.3 복소수 복소수 형 (complex number) complex64 : 32bit 실수 + 허수 complex128 : 64bit 실수 + 허수 Example 1 var num1 complex64 = 5 + 7i num2 := 8 + 1i num3 := complex(3, 2) //complex128 var num4 complex128 = 9 + 3i num5 := complex64(2 + 3i) fmt.Println(\"ex1 : \", num1) // (5+7i) fmt.Println(\"ex1 : \", num2) // (8+1i) fmt.Println(\"ex1 : \", num3) // (3+2i) fmt.Println(\"ex1 : \", num4) // (9+3i) fmt.Println(\"ex1 : \", num5) // (2+3i) Example 2 real() : 실수부 출력 imag() : 허수부 출력 fmt.Println(\"ex2 : \", num1, real(num1), imag(num1)) // (5+7i) 5 7 fmt.Println(\"ex2 : \", num2, real(num2), imag(num2)) // (8+1i) 8 1 fmt.Println(\"ex2 : \", num3, real(num3), imag(num3)) // (3+2i) 3 2 fmt.Println(\"ex2 : \", num4, real(num4), imag(num4)) // (9+3i) 9 3 fmt.Println(\"ex2 : \", num5, real(num5), imag(num5)) // (2+3i) 2 3 ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:2:3","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.2.4 숫자 연산 숫자 연산에는 산술연산, 비교연산이 있다. 타입이 같아야 연산이 가능하다 → 다른 타입끼리는 반드시 형 변환하여 형을 맞춘 후 연산을 해야 한다. 형 변환이 없을 경우는 예외가 발생한다. 연산자 : +, -, *, /, %, \u003c\u003c, \u003e\u003e, \u0026, ^ Example 1 package main import ( \"fmt\" \"math\" ) func main() { // Example 1 var n1 uint8 = math.MaxUint8 var n2 uint16 = math.MaxUint16 var n3 uint32 = math.MaxUint32 var n4 uint64 = math.MaxUint64 fmt.Println(\"Example 1 \", n1) // 255 fmt.Println(\"Example 1 \", n2) // 65535 fmt.Println(\"Example 1 \", n3) // 4294967295 fmt.Println(\"Example 1 \", n4) // 18446744073709551615 fmt.Println(\"Example 1 \", math.MaxInt8) // 127 fmt.Println(\"Example 1 \", math.MaxInt16) // 32767 fmt.Println(\"Example 1 \", math.MaxInt32) // 2147483647 fmt.Println(\"Example 1 \", math.MaxInt64) // 9223372036854775807 fmt.Println(\"Example 1 \", math.MaxFloat32) // 3.4028234663852886e+38 fmt.Println(\"Example 1 \", math.MaxFloat64) // 1.7976931348623157e+308 } Example 2 n5 := 100000 // int n6 := int16(10000) // int16으로 형변환이 일어남 n7 := uint8(100) //n7 := uint8(300) // 예외발생 // fmt.Println(\"Example 2: \", n5 + n6) // ./numeric4.go:40:32: invalid operation: n5 + n6 (mismatched types int and int16) fmt.Println(\"Example 2 : \", n5 + int(n6)) // 110000 // fmt.Println(\"Example 2 : \", n6 + n7) fmt.Println(\"Example 2 : \", n6 + int16(n7)) // 10100 fmt.Println(\"Example 2 : \", n6 \u003e int16(n7)) // true 비교 연산자도 타입이 같아야 한다. fmt.Println(\"Example 2 : \", n6 - int16(n7) \u003e 5000) // true ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:2:4","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.2.5 산술연산 import( \"fmt\" \"math\" ) func main() { var n1 uint8 = 125 var n2 uint8 = 90 fmt.Println(\"Example 1 :\", n1 + n2) //215 fmt.Println(\"Example 1 :\", n1 - n2) // 35 fmt.Println(\"Example 1 :\", n1 * n2) // 242 fmt.Println(\"Example 1 :\", n1 / n2) // 1 fmt.Println(\"Example 1 :\", n1 % n2) // 35 fmt.Println(\"Example 1 :\", n1 \u003c\u003c 2) // 244 fmt.Println(\"Example 1 :\", n1 \u003e\u003e 2) // 31 fmt.Println(\"Example 1 :\", ^n1) // 130 } Example 2 package main import( \"fmt\" \"math\" ) func main() { var n3 int = 12 var n4 float32 = 8.2 var n5 uint16 = 1024 var n6 uint32 = 120000 //정수형과 실수형 연산시 실수형에 맞추어 계산하는 것이 더 안전하다. // fmt.Println(\"Example 2 : \", n3 + n4 ) fmt.Println(\"Example 2 : \", float32(n3) + n4 ) // 20.2 fmt.Println(\"Example 2 : \", n3 + int(n4) ) // 20 fmt.Println(\"Example 2 : \", n5 + uint16(n6)) // 55488 } 산술 연산 - Error Case func main() { // Example 1 (overflows Error : 범위 초과) var n1 uint8 = math.MaxUint8 + 1 var n2 uint16 = math.MaxUint16 + 1 var n3 uint32 = math.MaxUint32 + 1 var n4 uint64 = math.MaxUint64 + 1 // Example 2 (overflows Error : 범위 초과) var n5 uint8 = -1 var n6 uint16 = -1 var n7 uint32 = -1 var n8 uint64 = -1 } ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:2:5","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.3 문자열 ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:3:0","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.3.1 문자열 큰 따옴표 \"\", 백스쿼트 ``` char 타입은 존재 하지 않는다 → **rune(int32)**로 문자 코드 값으로 표현한다. ’’ 로 작성 가능하다 자주 사용하는 escape : \\\\, \\', \\\", \\a(콘솔벨), \\b(백스페이스), \\f(쪽바꿈), \\n(줄바꿈),\\r(복귀),\\t(탭) - 역슬래시 이후에 등장하는 문자를 그대로 출력할 때 src/section5/string1.go package main import ( \"fmt\" \"unicode/utf8\" ) func main() { var str1 string = \"c:\\\\go_study\\\\src\\\\\" // c:\\go_study\\src\\ str2 := `c:\\go_study\\src\\` // escape 를 사용하지 않아도 된다. fmt.Println(\"##################################\") fmt.Println(\"Example 1 : \", str1) fmt.Println(\"Example 1 : \", str2) var str3 string = \"Hello, world!\" var str4 string = \"안녕하세요!\" var str5 string = \"\\ud55c\\uae00\" fmt.Println(\"############################\") fmt.Println(\"Example 2 : \", str3) fmt.Println(\"Example 2 : \", str4) fmt.Println(\"Example 2 : \", str5) // 길이(Byte 수), fmt.Println(\"############################\") fmt.Println(\"Example 3 : \", len(str3)) // 13 byte fmt.Println(\"Example 3 : \", len(str4)) // 16 byte // 길이(실제 길이) fmt.Println(\"############################\") fmt.Println(\"Example 4 : \", utf8.RuneCountInString(str3)) fmt.Println(\"Example 4 : \", utf8.RuneCountInString(str4)) fmt.Println(\"Example 4 : \", len([]rune(str4))) // utf8 패키지를 사용하지 않고도 문자열 길이를 구할 수 있다. } // result ############################# Example 1 : c:\\go_study\\src Example 1 : c:\\go_study\\src ############################ Example 2 : Hello, world! Example 2 : 안녕하세요! Example 2 : 한글 ############################ Example 3 : 13 Example 3 : 16 ############################ Example 4 : 13 Example 4 : 6 Example 4 : 6\\ ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:3:1","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.3.2 문자열 표현 golang에서 문자열은 UTF-8 인코딩(유니코드 문자 집합)이며 한글 바이트는 3byte이다. src/section5/string2.go package main import \"fmt\" func main() { var str1 string = \"Golang\" var str2 string = \"World\" var str3 string = \"고프로그래밍\" fmt.Println(\"Example 1 : \", str1[0], str1[1], str1[2], str1[3], str1[4], str1[5]) fmt.Println(\"Example 1 : \", str2[0], str2[1], str2[2], str2[3], str2[4]) fmt.Println(\"Example 1 : \", str3[0], str3[1], str3[2], str3[3], str3[4], str3[5]) // Example 2 fmt.Println(\"########################################\") fmt.Printf(\"Example 2 : %c %c %c %c %c %c\\n\", str1[0], str1[1], str1[2], str1[3], str1[4], str1[5]) fmt.Printf(\"Example 2 : %c %c %c %c %c\\n\", str2[0], str2[1], str2[2], str2[3], str2[4]) fmt.Printf(\"Example 2 : %c %c %c %c %c %c\\n\", str3[0], str3[1], str3[2], str3[3], str3[4], str3[5]) // 한글깨짐 conStr := []rune(str3) fmt.Printf(\"Example 2 : %c %c %c %c %c %c\\n\", conStr[0], conStr[1], conStr[2], conStr[3], conStr[4], conStr[5]) // 한글 정상 출력 // Example 3 fmt.Println(\"########################################\") for i, char := range str1 { fmt.Printf(\"Example 3 : %c(%d)\\t\", char, i) } fmt.Println() fmt.Println(\"########################################\") for i, char := range str2 { fmt.Printf(\"Example 4 : %c(%d)\\t\", char, i) } } Example 1 : 71 111 108 97 110 103 Example 1 : 87 111 114 108 100 Example 1 : 234 179 160 237 148 132 ######################################## Example 2 : G o l a n g Example 2 : W o r l d Example 2 : ê ³ í\\ Example 2 : 고 프 로 그 래 밍 ######################################## Example 3 : G(0) Example 3 : o(1) Example 3 : l(2) Example 3 : a(3) Example 3 : n(4) Example 3 : g(5)\\ ######################################## Example 4 : W(0) Example 4 : o(1) Example 4 : r(2) Example 4 : l(3) Example 4 : d(4) %\\ ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:3:2","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["Easy Go"],"content":"5.3.3 문자열 연산 문자열 추출 package main import \"fmt\" func main() { var str1 string = \"Golang\" var str2 string = \"World\" fmt.Println(\"Example 1 : \", str1[0:2], str1[0]) fmt.Println(\"Example 1 : \", str2[3:], str2[0]) fmt.Println(\"Example 1 : \", str2[:4]) fmt.Println(\"Example 1 : \", str1[1:3]) } Example 1 : Go 71 Example 1 : ld 87 Example 1 : Worl Example 1 : ol 문자열 비교 package main import \"fmt\" func main() { str1 := \"Golang\" str2 := \"World\" fmt.Println(\"Example 1 : \", str1 == str2) fmt.Println(\"Example 2 : \", str1 != str2) fmt.Println(\"Example 3 : \", str1 \u003e str2) fmt.Println(\"Example 4 : \", str1 \u003c str2) // Go 문자열 -\u003e 아스키 코드에 대한 사전식 비교 } Example 1 : false Example 2 : true Example 3 : false Example 4 : true 문자열 결합 문자열 결합연산은 java와 비슷하다. (일반연산보다 StringBuffer 를 쓰는 것 처럼) package main import ( \"fmt\" \"strings\" ) func main() { // Example 1 (결합 : 일반연산) // Java 와 비슷 - Java의 경우에도 문자열 일반연산보다 StrnigBuffer 쓰는거와 비 str1 := \"This document demonstrates the development of a simple Go package inside a module and introduces the go tool\" + \"the standard way to fetch, build, and install Go modules, packages, and commands.\\n\\n\" + \"Note: This document assumes that you are using Go 1.13 or later and the GO111MODULE environment variable is not set. If you are looking for the older,\" + \"pre-modules version of this document, it is archived here.\" str2 := \"This document demonstrates the development of a simple Go package\" fmt.Println(\"Example \", str1 + str2) var strSet []string //슬라이스 선언 strSet = append(strSet, str1) strSet = append(strSet, str2) fmt.Println(\"Example 2 :\", strings.Join(strSet, \"-----\")) } ","date":"2021-03-22","objectID":"/archives/golang/easy-golang-section5/:3:3","tags":["go","golang"],"title":"Section 5 : Go 데이터 타입","uri":"/archives/golang/easy-golang-section5/"},{"categories":["elasticsearch"],"content":"개요 파일비트를 사용하여 웹 서버(nginx) 로그 파일을 수집하고 Elasticsearch Cloud에 전송한다. Cloud에서 생성한 Kibana 사이트에 접속하면 여러 플랫폼에서 데이터를 수집할 수 있는 예시 파일을 참고 할 수 있다. ","date":"2021-03-21","objectID":"/archives/elasticsearch/nginx-log-es-cloud/:1:0","tags":["elasticsearch","elasticsearch cloud","filebeat"],"title":"nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/archives/elasticsearch/nginx-log-es-cloud/"},{"categories":["elasticsearch"],"content":"파일비트 설치 파일비트는 수집할 로그가 쌓이는 서버에 설치했다. cd /usr/local/src sudo curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.11.1-linux-x86_64.tar.gz tar xzvf filebeat-7.11.1-linux-x86_64.tar.gz cd filebeat-7.11.1-linux-x86_64 ","date":"2021-03-21","objectID":"/archives/elasticsearch/nginx-log-es-cloud/:1:1","tags":["elasticsearch","elasticsearch cloud","filebeat"],"title":"nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/archives/elasticsearch/nginx-log-es-cloud/"},{"categories":["elasticsearch"],"content":"Elastic Cloud 인증정보 설정 Elastic Cloud 접속을 위하여 filebeat.yml의 관련항목의 주석을 해제하고 인증정보를 설정한다. 그 외 필요한 설정 정보는 아래 링크를 참조한다. Configuration filebeat.yml filebeat.yml # =============================== Elastic Cloud ================================ # These settings simplify using Filebeat with the Elastic Cloud (https://cloud.elastic.co/). # The cloud.id setting overwrites the `output.elasticsearch.hosts` and # `setup.kibana.host` options. # You can find the `cloud.id` in the Elastic Cloud web UI. cloud.id: \"\u003cCLOUD_ID\u003e\" # The cloud.auth setting overwrites the `output.elasticsearch.username` and # `output.elasticsearch.password` settings. The format is `\u003cuser\u003e:\u003cpass\u003e`. cloud.auth: \"\u003cCLOUD_USER\u003e:\u003cCLOUD_PASS\u003e\" cloud.id : 연결하려는 elastic cloud 아이디를 복사하여 넣는다. cloud id는 메인화면에서 확인 가능하다. cloud.auth : 항목에는 “user:pass” 형태로 basic authentication 형태로 작성한다. ","date":"2021-03-21","objectID":"/archives/elasticsearch/nginx-log-es-cloud/:1:2","tags":["elasticsearch","elasticsearch cloud","filebeat"],"title":"nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/archives/elasticsearch/nginx-log-es-cloud/"},{"categories":["elasticsearch"],"content":"filebeat input 설정 엘라스틱서치로 전송할 input 파일 정보를 설정한다. 특별한 설정을 하지 않고 filebeat의 nginx 모듈을 활성화 한 경우 nginx의 기본 로그 폴더가 자동으로 설정된다. (/var/log/nginx/access.log*, /var/log/nginx/error.log* 등) 특정 로그 디렉토리를 설정하려면 직접 input 설정에 경로를 지정해야 한다. filebeat.yml # ============================== Filebeat inputs =============================== filebeat.inputs: # Each - is an input. Most options can be set at the input level, so # you can use different inputs for various configurations. # Below are the input specific configurations. - type: log # Change to true to enable this input configuration. enabled: true # Paths that should be crawled and fetched. Glob based paths. paths: - /home/riley/logs/*.log - /home/riley/logs/tomcat/*.log #- c:\\programdata\\elasticsearch\\logs\\* # Exclude lines. A list of regular expressions to match. It drops the lines that are # matching any regular expression from the list. #exclude_lines: ['^DBG'] # Include lines. A list of regular expressions to match. It exports the lines that are # matching any regular expression from the list. #include_lines: ['^ERR', '^WARN'] # Exclude files. A list of regular expressions to match. Filebeat drops the files that # are matching any regular expression from the list. By default, no files are dropped. #exclude_files: ['.gz$'] # Optional additional fields. These fields can be freely picked # to add additional information to the crawled log files for filtering #fields: # level: debug # review: 1 ### Multiline options # Multiline can be used for log messages spanning multiple lines. This is common # for Java Stack Traces or C-Line Continuation # The regexp Pattern that has to be matched. The example pattern matches all lines starting with [ #multiline.pattern: ^\\[ # Defines if the pattern set under pattern should be negated or not. Default is false. #multiline.negate: false # Match can be set to \"after\" or \"before\". It is used to define if lines should be append to a pattern # that was (not) matched before or after or as long as a pattern is not matched based on negate. # Note: After is the equivalent to previous and before is the equivalent to to next in Logstash #multiline.match: after filebeat.inputs.enabled : true 로 설정 filebeat.inputs.path : 사용자 지정 nginx 로그 경로 형식을 작성한다. ","date":"2021-03-21","objectID":"/archives/elasticsearch/nginx-log-es-cloud/:1:3","tags":["elasticsearch","elasticsearch cloud","filebeat"],"title":"nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/archives/elasticsearch/nginx-log-es-cloud/"},{"categories":["elasticsearch"],"content":"Output 설정 filebeat.yml # ================================== Outputs =================================== # Configure what output to use when sending the data collected by the beat. # ---------------------------- Elasticsearch Output ---------------------------- output.elasticsearch: # Array of hosts to connect to. hosts: [\"\u003cENDPOINT\u003e\"] # Protocol - either `http` (default) or `https`. protocol: \"https\" 파일은 Elasticsearch Cloud로 전송할 것이기 때문에 Elasticsearch 정보를 설정한다. host : Elasticsearch cloud의 endpoint protocol : endpoint가 ssl이 적용되어있는 경우 https로 설정한다. ","date":"2021-03-21","objectID":"/archives/elasticsearch/nginx-log-es-cloud/:1:4","tags":["elasticsearch","elasticsearch cloud","filebeat"],"title":"nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/archives/elasticsearch/nginx-log-es-cloud/"},{"categories":["elasticsearch"],"content":"filebeat 설정 적용 및 실행 filebeat nginx 모듈 활성화 sudo ./filebeat modules enable nginx filebeat 실행 sudo ./filebeat -e 403 ERROR 일 경우 ","date":"2021-03-21","objectID":"/archives/elasticsearch/nginx-log-es-cloud/:1:5","tags":["elasticsearch","elasticsearch cloud","filebeat"],"title":"nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/archives/elasticsearch/nginx-log-es-cloud/"},{"categories":["elasticsearch"],"content":"Kibana 실행 Cloud에 있는 Kibana를 실행하게 되면 파일비트로 전송된 nginx Log를 확인 할 수 있다. filebeat-* 형식으로 인덱스 패턴이 자동으로 등록된다. ","date":"2021-03-21","objectID":"/archives/elasticsearch/nginx-log-es-cloud/:1:6","tags":["elasticsearch","elasticsearch cloud","filebeat"],"title":"nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/archives/elasticsearch/nginx-log-es-cloud/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-19","objectID":"/archives/golang/easy-golang-section4/:0:0","tags":["go","golang"],"title":"Section 4 : Go 패키지 기초","uri":"/archives/golang/easy-golang-section4/"},{"categories":["Easy Go"],"content":"4.1 Go 패키지 Go의 패키지는 코드 구조화(모듈화) 및 재사용 기능을 제공한다. 응집도, 결합도를 느슨하게 해야 유지보수가 쉽고 가독성이 좋아진다. 클린코드 Go는 패키지를 사용해서 작은 단위의 컴포넌트를 작성하고 이러한 작은 패키지를 결합해서 프로그램을 작성할 것을 권고하고 있다. 패키지이름 = 디렉토리 이름 같은 패키지 내 소스파일들은 디렉토리명을 패키지명으로 사용한다. 네이밍 규칙 : 소문자 private 대문자 public Go에서 main 패키지는 특별하게 인식된다 → 컴파일러에서는 프로그램의 시작점 start point로 인식한다. package main // 선언 방법1 /*import \"fmt\" import \"os\"*/ // 선언 방법2 import ( \"fmt\" \"os\" ) func main() { var name string fmt.Println(\"이름은 ? : \") fmt.Scanf(\"%s\", \u0026name) fmt.Fprintf(os.Stdout, \"Hi! %s\\n\", name) } ","date":"2021-03-19","objectID":"/archives/golang/easy-golang-section4/:1:0","tags":["go","golang"],"title":"Section 4 : Go 패키지 기초","uri":"/archives/golang/easy-golang-section4/"},{"categories":["Easy Go"],"content":"4.1.1 패키지 사용 section4/lib/lib.go package lib import \"fmt\" // 변수 초기화 func init() { fmt.Println(\"lib Package \u003e init Start!!\") } func CheckNum(c int32) bool { return c \u003e 10 } section4/package2.go package main import ( \"fmt\" \"section4/lib\" ) func main () { fmt.Println(\"10보다 큰 수 ? \", lib.CheckNum(4)) } ","date":"2021-03-19","objectID":"/archives/golang/easy-golang-section4/:1:1","tags":["go","golang"],"title":"Section 4 : Go 패키지 기초","uri":"/archives/golang/easy-golang-section4/"},{"categories":["Easy Go"],"content":"4.2 접근제어 및 Alias ","date":"2021-03-19","objectID":"/archives/golang/easy-golang-section4/:2:0","tags":["go","golang"],"title":"Section 4 : Go 패키지 기초","uri":"/archives/golang/easy-golang-section4/"},{"categories":["Easy Go"],"content":"4.2.1 패키지 접근 제어 변수, 상수, 함수, 메서드, 구조체 등 식별자 첫글자 대문자 : 패키지 외부에서 접근 가능 첫글자 소문자 : 패키지 외부에서 접근 불가. 해당 패키지 내에서만 접근 가능 section4/lib2/lib.go package lib2 func CheckNum1(c int32) bool { return c \u003e 100 } func CheckNum2(c int32) bool { return c \u003e 1000 } section4/access1.go package main import ( \"fmt\" \"section4/lib2\" ) func main() { fmt.Println(\"100 보다 큰 수 ?\", lib2.CheckNum1(101)) fmt.Println(\"1000 보다 큰 수 ?\", lib2.CheckNum2(999)) } ","date":"2021-03-19","objectID":"/archives/golang/easy-golang-section4/:2:1","tags":["go","golang"],"title":"Section 4 : Go 패키지 기초","uri":"/archives/golang/easy-golang-section4/"},{"categories":["Easy Go"],"content":"4.2.2 별칭 사용 및 빈 식별자 사용 package main import ( \"fmt\" checkUp \"section4/lib\" _ \"section4/lib2\" ) func main() { fmt.Println(\"10보다 큰 수? : \", checkUp.CheckNum(11)) } ","date":"2021-03-19","objectID":"/archives/golang/easy-golang-section4/:2:2","tags":["go","golang"],"title":"Section 4 : Go 패키지 기초","uri":"/archives/golang/easy-golang-section4/"},{"categories":["Easy Go"],"content":"4.3 초기화 메소드 init ","date":"2021-03-19","objectID":"/archives/golang/easy-golang-section4/:3:0","tags":["go","golang"],"title":"Section 4 : Go 패키지 기초","uri":"/archives/golang/easy-golang-section4/"},{"categories":["Easy Go"],"content":"4.3.1 init 패키지 로드시에 가장 먼저 호출 된다. 가장 먼저 초기회 되는 작업 작성 시 유용하다. package main import ( \"fmt\" ) func init() { fmt.Println(\"Init Method Start!\") } func main() { fmt.Println(\"Main Method Start!\") } ","date":"2021-03-19","objectID":"/archives/golang/easy-golang-section4/:3:1","tags":["go","golang"],"title":"Section 4 : Go 패키지 기초","uri":"/archives/golang/easy-golang-section4/"},{"categories":["Easy Go"],"content":"4.3.2 초기화 메소드 실행 순서 section4/lib/lib.go package lib import \"fmt\" // 변수 초기화 func init() { fmt.Println(\"lib Package \u003e init Start!!\") } func CheckNum(c int32) bool { return c \u003e 10 } init 메소드는 여러개 지정할 수 있다. (보통은 잘 사용하지 않음) 다른 패키지에서 imort 할 때 init 메소드가 실행된다. package main import ( \"fmt\" _ \"section4/lib\" ) func init() { fmt.Println(\"Init1 Method Start! \") } func init() { fmt.Println(\"Init2 Method Start! \") } func init() { fmt.Println(\"Init3 Method Start! \") } func init() { fmt.Println(\"Init4 Method Start! \") } func main() { fmt.Println(\"Main Method Start!\") } ## 결과 lib Package \u003e init Start!! Init1 Method Start! Init2 Method Start! Init3 Method Start! Init4 Method Start! Main Method Start! ","date":"2021-03-19","objectID":"/archives/golang/easy-golang-section4/:3:2","tags":["go","golang"],"title":"Section 4 : Go 패키지 기초","uri":"/archives/golang/easy-golang-section4/"},{"categories":["elasticsearch"],"content":"개요 Elastic Cloud로 데이터 마이그레이션하기 A to Z filebeat, logstash 는 데이터 소스가 있는 시스템에 설치하고, Elasticsearch, Kinaba 는 Elastic Cloud 로 세팅하여 사용한다. 엘라스틱서치 운영 모니터링 까지 Elastic Cloud 에서 모두 지원하기 때문에 따로 구성하지 않아도 된다. ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:1:0","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"Elastic Cloud 구조 ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:1:1","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"작업 목표 On-promise로 구성되어 있는 검색어 키워드를 Elastic Cloud 환경으로 이관한다. 추후에 맵으로 시각화 할 수 있도록 기존 데이터에 location(latitude, longitude)를 추가한다. ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:2:0","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"현재 시스템 구성 현재 구성되어 있는 검색어 키워드 인덱스 명 → wini_srch_kwrd_hist-yyyymm ES_MASTER 서버에서 로그스태시가 매일 09:00 마다 키워드 테이블을 조회하여 엘라스틱서치에 저장시키고 있다. 현재 로그스태시 및 구성 문서 : 기간별 키워드 검색 추가를 위한 선행 작업(링크) ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:3:0","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"작업 진행 내용 ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:4:0","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"1. Raw 데이터 검색 쿼리 - 전일 키워드 히스토리를 가져오는 SQL ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:4:1","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"2. ES 템플릿을 등록한다 v_countrycd의 경우 사실 keyword 필드는 필요없다. (현재 반영되어 있는게 v_countrcyd.keyword 필드를 바라보고 있어서 따로 수정은 못함) location은 lat, lon 의 Object 형태의 goe_point로 설정한다. template 생성 JSON PUT _template/keyword_template { \"index_patterns\": [\"kwrd_hist-*\"], \"settings\": { \"index\" : { \"analysis\" : { \"filter\" : { \"english_stop\" : { \"type\" : \"stop\", \"stopwords\" : \"_english_\" }, \"filter_shingle\" : { \"max_shingle_size\" : \"3\", \"token_separator\" : \" \", \"output_unigrams\" : true, \"type\" : \"shingle\" } }, \"normalizer\": { \"default_normalizer\": { \"type\" : \"custom\", \"filter\" : [\"lowercase\", \"asciifolding\"] } }, \"analyzer\" : { \"default_analyzer\" : { \"type\" : \"custom\", \"tokenizer\" : \"standard\", \"filter\" : [\"lowercase\", \"filter_shingle\", \"asciifolding\"] } } } } }, \"mappings\": { \"properties\": { \"seq\" : { \"type\" : \"long\" }, \"v_countrycd\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\", \"fields\": { \"keyword\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\" } } }, \"v_keyword\" : { \"type\" : \"text\", \"analyzer\" : \"default_analyzer\", \"search_analyzer\": \"default_analyzer\", \"fields\": { \"keyword\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\" } } }, \"v_usercd\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\" }, \"v_userid\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\" }, \"location\" : { \"type\" : \"geo_point\" }, \"reg_dtm\" : { \"type\" : \"date\" } } } } ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:4:2","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"iso_alpha2 데이터를 가지고 lat, lon 정보를 세팅하는 dictionary 파일을 생성한다. 데이터 소스에서 국가코드는 2자리로만 수집하고 있다.(V_COUNTRYCD) 이 국가코드로 특정 위치를 알아내기 위해 국가코드를 키로하고 값으로 lat, lon 정보를 Object로 갖는 사전을 구성해야 한다. JSON은 더블 쿼테이션이나 형식이 복잡해지므로 간결하게 yml로 구성하였다. --- AD: iso_alpha2: AD iso_alpha3: AND latitude: 42.546245 longitude: 1.601554 country_name: Andorra AE: iso_alpha2: AE iso_alpha3: ARE latitude: 23.424076 longitude: 53.847818 country_name: United Arab Emirates AF: iso_alpha2: AF iso_alpha3: AFG latitude: 33.93911 longitude: 67.709953 country_name: Afghanistan .... (생략) // 내용이 많아 파일로 첨부 ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:4:3","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"4. 데이터를 가공하여 Elastic Cloud로 전송하도록 로그스태시를 설정한다. 최초 데이터 ~ 어제 데이터까지 한 번만 인입하는 로그 스태시 설정 input { jdbc { jdbc_validate_connection =\u003e true jdbc_connection_string =\u003e \"오라클접속정보\" jdbc_user =\u003e \"생략\" jdbc_password =\u003e \"생략\" jdbc_driver_library =\u003e \"/usr/share/logstash/lib/ojdbc6.jar\" jdbc_driver_class =\u003e \"Java::oracle.jdbc.driver.OracleDriver\" #use_column_value =\u003e true #schedule =\u003e \"0 9 * * *\" statement_filepath =\u003e \"쿼리 파일 위치\" last_run_metadata_path =\u003e \"/elastic/logstash/.meta\" } } filter { mutate { copy =\u003e {\"seq\" =\u003e \"[@metadata][_id]\"} copy =\u003e {\"target_yymm\" =\u003e \"[@metadata][target_yymm]\"} remove_field =\u003e [\"@version\", \"target_yymm\"] } # 국가코드로 lat, lon 정보 세팅 translate { field =\u003e \"v_countrycd\" destination =\u003e \"mapdata\" dictionary_path =\u003e \"/home/elastic/data/country_dic.yml\" fallback =\u003e nil } if [mapdata][latitude] and [mapdata][longitude] { mutate { add_field =\u003e [\"[location][lat]\", \"%{[mapdata][latitude]}\"] add_field =\u003e [\"[location][lon]\", \"%{[mapdata][longitude]}\"] remove_field =\u003e [\"mapdata\"] convert =\u003e [\"[location][lat]\", \"float\"] convert =\u003e [\"[location][lon]\", \"float\"] } } } output { stdout { codec =\u003e \"rubydebug\" } elasticsearch { cloud_id =\u003e [\"생략\"] } } ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:4:4","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"filter \u003e translate plugin translate { field =\u003e \"v_countrycd\" destination =\u003e \"mapdata\" dictionary_path =\u003e \"/home/elastic/data/country_dic.yml\" fallback =\u003e nil } v_countrycd 값을 가지고 country_dic.yml 데이터를 참고하여 latitude값과 longitude 값을 가져와mapdata라는 임시 필드에 저장시킨다. fallback 에는 매핑되지 못했을 경우 nill 값으로 리턴한다. ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:4:5","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"filter \u003e mutate if [mapdata][latitude] and [mapdata][longitude] { mutate { add_field =\u003e [\"[location][lat]\", \"%{[mapdata][latitude]}\"] add_field =\u003e [\"[location][lon]\", \"%{[mapdata][longitude]}\"] remove_field =\u003e [\"mapdata\"] convert =\u003e [\"[location][lat]\", \"float\"] convert =\u003e [\"[location][lon]\", \"float\"] } } 사전데이터에 존재하는 데이터의 경우 location 오브젝트의 lat 값에 latitude를 lon 값에 longitude 값을 저장한다. 임시 필드 mapdata는 삭제한다. 필드 데이터 타입을 float로 변경해준다. ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:4:6","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"output output { stdout { codec =\u003e \"rubydebug\" } elasticsearch { cloud_id =\u003e [\"클라우드아이디\"] } } output에는 Elastic Cloud 정보를 적어준다. cloud_id cloud_auth on-promise 에서는 host를 적었는데 cloud의 경우는 cloud id와 인증정보만 추가하면 된다. cloud_auth에서 : 형식이므로 password를 적지 않도록 keystore를 생성해서 처리하는 방식을 검색해보았지만 잘 안나와서 기본 예제에 따름… ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:4:7","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"5. 로그스태시 실행 ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:4:8","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"매일 오전 9시마다 데이터 수집하도록 logstash 설정 추가 ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:5:0","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"스케쥴링 용 logstash Config 파일 추가 # 아래 부분만 주석 해제 schedule =\u003e \"0 9 * * *\" ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:5:1","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"pipeline.yml 수정 이전 on-promise의 경우 -f 옵션을 주어 하나의 config 파일을 실행하였는데, 당분간은 on-promise 와cloud에 각각 데이터를 쌓아야 하 기 때문에 pipeline.yml을 이용하여 로그스태시를 실행 시키도록 한다. ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:5:2","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"데이터 실행 쉘 스크립트 수정 f 옵션을 제거하고 pipelines.yml을 기준으로 로그스태시를 실행 시킬 수 있도록 실행 옵션을 추가한다. /home/elastic/logstash-datapump/tmp/script/logstash-service.shCOMMAND='/home/elastic/logstash-datapump/bin/logstash --path.settings=/home/elastic/logstash- datapump/config' 적재 데이터 확인 키바나에서 어제까지의 데이터가 들어와 있음 성공^ᄋ^ ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:6:0","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"Alias 등록을 위한 스크립트 설정 검색 이력 인덱스는 “인덱스명-yyyyMMdd” 형태로 관리되고 있다. 별칭으로 전체 기간의 인덱스를 조회할 수 있도록 설정해야한다. 00시마다 크론탭에 의해 월이 넘어갔을때 신규인덱스에 별칭을 추가하도록 한다. 이전에 기록했던 설정 정보 : ALIAS 등록 스크립트 이전 스크립트에 elastic cloud 정보를 추가하도록 한다. ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:7:0","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"1. alias API 사용 권한을 갖는 API 키 발행 Kibana \u003e Management \u003e Dev Tools 에서 API Key를 추가한다. index는 alias에 등록될 인덱스 패턴과 별칭명도 추가해주어야 하는 것같다. privileges는 manage 로 설정한다. POST /_security/api_key { \"name\" : \"APIKey 이름\", \"role_descriptors\": { \"es-manager\" : { \"cluster\" : [\"all\"], \"index\" : [ { \"names\" : [\"인덱스 패턴\", \"별칭명\"], \"privileges\" : [\"manage\"]} ] } } } Kiabana \u003e Stack Management \u003e API Keys 키가 추가가 잘되었는지 확인 ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:7:1","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["elasticsearch"],"content":"2. 크론스크립트에 Cloud로 API를 요청하는 로직을 추가 #!/bin/bash # 2020.07.22 Riley # 2021.03.17 Riley : Add Elastic Cloud Setting FILE_LAST_MONTH=/home/elastic/logstash-datapump/tmp/last-alias-month.txt FILE_LAST_MONTH_CLOUD=/home/elastic/logstash-datapump/tmp/last-alias-month-cloud.txt THIS_MONTH=$(date '+%Y%m') LAST_MONTH=THIS_MONTH # Elastic Cloud LAST_MONTH=THIS_MONTH if [ ! -f \"$FILE_LAST_MONTH_CLOUD\" ]; then touch \"$FILE_LAST_MONTH_CLOUD\"; echo $(date '+%Y%m' --date=\"1 months ago\") \u003e $FILE_LAST_MONTH_CLOUD; fi while read TMP2; do LAST_MONTH=$TMP2; done \u003c $FILE_LAST_MONTH_CLOUD; if [ $((LAST_MONTH)) -lt $((THIS_MONTH)) ]; then RES_CODE=$(curl -o /dev/null -w \"%{http_code}\" -d \"{\\\"actions\\\":[{\\\"add\\\":{\\\"index\\\":\\\" 인덱스명-${THIS_MONTH}\\\",\\\"alias\\\":\\\"별칭명\\\"}}]}\" \\ -H \"Content-Type: application/json\" -H \"Authorization: ApiKey\u003c 여기에 API Key넣기\u003e \" -X POST https://엘라스틱 클라우드 주소/_aliases) echo $RES_CODE if [ $RES_CODE -eq 200 ]; then echo $THIS_MONTH \u003e $FILE_LAST_MONTH_CLOUD; fi fi ","date":"2021-03-17","objectID":"/archives/elasticsearch/es-cloud/:7:2","tags":["elasticsearch","elasticsearch cloud"],"title":"Elastic Cloud 이관 작업","uri":"/archives/elasticsearch/es-cloud/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:0:0","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.1 조건문 ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:1:0","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.1.1 조건문 IF if 문은 반드시 Boolean 형으로 검사해야 한다. 다른 언어처럼 1, 0 으로 조건문을 사용할 수 없다 → 자동 형변환 불가 소괄호는 사용하지 않는다. func main() { var a int = 20 b := 20 if a \u003e= 15 { fmt.Println(\"15 이상이다\") } if b \u003e= 25 { fmt.Println(\"25 이상이다\") } if c := 40; c \u003e= 35 { fmt.Println(\"35 이상\") } } Error Case // 에러 발생 1 if b \u003e= 25 { } // 에러 발생 2 if b \u003e= 25 fmt.Println(\"25이상\") ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:1:1","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.1.2 else func main() { var a int = 50 b := 70 // 예제 1 if a \u003e= 65 { fmt.Println(\"65 이상\") } else { fmt.Println(\"65 미만\") } if b \u003e= 70 { fmt.Println(\"70 이상\") } else { fmt.Println(\"70 미만\") } } ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:1:2","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.1.3 else if func main() { i := 100 // if - else if 예제 1 if i \u003e= 120 { fmt.Println(\"120 이상\") } else if i \u003e= 100 \u0026\u0026 i \u003c 120 { fmt.Println(\"100 이상 120 미만\") } else if i \u003c 100 \u0026\u0026 i \u003e= 50 { fmt.Println(\"50 이상 100 미만\") } else { fmt.Println(\"50 미만\") } } ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:1:3","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.2 조건문 switch switch 뒤 표현식은 생략이 가능하다. case 뒤 표현식 사용 가능 자동 break 때문에 fallthrough 존재 Type 분기 → 값이 아닌 변수 type 으로 분기 가능하다. ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:2:0","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"Switch 기본사용법 func main() { a := -7 switch { case a \u003c 0: fmt.Println(a, \"는 음수\") case a == 0: fmt.Println(a, \"는 0\") case a \u003e 0: fmt.Println(a, \"는 양수\") } } // 결과 // -7는 음수 func main() { switch b := 27; { case b \u003c 0: fmt.Println(b, \"는 음수\") case b == 0: fmt.Println(b, \"는 0\") case b \u003e 0: fmt.Println(b, \"는 양수\") } } // 결과 // 27는 양수 func main() { switch c := \"go\"; c { case \"go\": fmt.Println(\"Go!\") case \"java\" : fmt.Println(\"Java!\") default: fmt.Println(\"일치하는 값 없음\") } } // 결과 // Go! func main() { switch c := \"go\"; c + \"lang\" { case \"golang\": fmt.Println(\"Go lang\") case \"java\": fmt.Println(\"java\") default: fmt.Println(\"none\") } } // 결과 // Go lang func main() { switch i, j := 20, 30; { case i \u003c j : fmt.Println(\"i는 j보다 작다.\") case i == j : fmt.Println(\"i는 j는 같다.\") case i \u003e j : fmt.Println(\"i와 j보다 크다.\") } } // 결과 // i는 j보다 작다. ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:2:1","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"랜덤 값을 가지고 switch 문으로 범위 출력하기 package main import ( \"fmt\" \"math/rand\" \"time\" ) func main() { // Example 1 rand.Seed(time.Now().UnixNano()) switch i := rand.Intn(100); { case i \u003e= 50 \u0026\u0026 i \u003c 100: fmt.Println(\"i -\u003e \", i, \" 50 이상 100 미만\") case i \u003e= 25 \u0026\u0026 i \u003c 50: fmt.Println(\"i -\u003e \", i, \" 25 이상 50 미만\") default: fmt.Println(\"i -\u003e \", i, \" 기본 값\") } } ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:2:2","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"Example 3 package main import \"fmt\" func main() { // Example 1 a := 30 / 15 switch a { case 2, 4, 6: // i가 2, 4, 6 인 경우 fmt.Println(\"a -\u003e \", a, \"는 짝수\") case 1, 3, 5: fmt.Println(\"a -\u003e \", a, \"는홀수\") } } ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:2:3","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"fallthrough fallthrough를 사용하면 하나의 case 문을 거친 뒤, 그 다음 case 문 내용을 이어서 실행하는 동작이 가능하다. func main() { switch e := \"go\"; e { case \"java\": fmt.Println(\"Java!\") fallthrough case \"go\": fmt.Println(\"go!\") fallthrough case \"python\": fmt.Println(\"python!\") case \"ruby\": fmt.Println(\"ruby!\") fallthrough case \"c\": fmt.Println(\"c!\") } } // 결과 // go! // python! ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:2:4","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.3 반복문 for Go에서 for는 유일하게 제공하는 반복문이다. ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:3:0","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.1 반복문 사용법 반복문 기본 사용법 for i := 0; i \u003c 5; i++ { fmt.Println(\"EX1 : \", i) } 무한 루프 // java -\u003e while(true) {} for { fmt.Println(\"EX2 : Hello Go Lang \") fmt.Println(\"EX2 : Infinite Loop! \") } Range 사용하기 loc := []string {\"Seoul\", \"Busan\", \"Incheon\"} for index, name := range loc { // 첫번째 인자 - 인덱스, 두번째 인자 - 값 fmt.Println(\"EX 3 : \", index, name) } // index를 생략하고 싶으면 for _, name := range loc { fmt.Println(\"EX 3 : \", name) } ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:3:1","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.2 반복문의 여러가지 사용 패턴 Example 1 sum1 := 0 for i := 0; i \u003c= 100; i++ { sum1 += 1 // sum := sum + 1 } fmt.Println(\"EX1 : \", sum1) // 결과 // EX1 : 101 Example 2 // Example 2 sum2, i := 0, 0 for i \u003c= 100 { sum2 += i i++ // j := i++ (X) GO 에서는 후치연산은 반환이 안된다. } fmt.Println(\"EX2 : \", sum2) // 결과 // EX2 : 5050 j := i++ Go에서는 후치연산은 반환이 안되기 때문에 j에 i++ 값을 대입할 수 없다. ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:3:2","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.3 while 처럼 사용하기 sum3, i := 0, 0 for { // while 형태와 비 if i \u003e 100 { break } sum3 += i i++ } fmt.Println(\"EX3 : \", sum3) // 결과 // EX3 : 5050 for i, j := 0, 0; i \u003c= 10; i, j = i + 1, j + 10 { fmt.Println(\"EX4 : \", i, j) } // 결과 // EX4 : 1 10 // EX4 : 2 20 // EX4 : 3 30 // .... // Ex4 : 10 100 ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:3:3","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"3.4 GO 문법 특징 ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:4:0","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"GO 문법 특징 1 모호하거나, 애매한 문법 금지 후치(후위) 연산자는 허용하나 i++ 전치(전위) 연산자는 비허용 ++i (X) 증감연산자는 반환값이 없음 sum := i++ (X) 포인터를 허용한다. 포인터 연산은 비허용 주석 // , /**/ func main() { // Example 1 sum, i := 0, 0 for i \u003c= 100 { // sum += i++ // 예외 발생 sum += i i++ // ++i (전위증감 비허용) } fmt.Println(\"Example 1 : \", sum) } ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:4:1","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"GO 문법 특징 2 문장 끝 세미콜론 ; 주의 자동으로 Go 컴파일러가 끝에 세미콜론을 삽입 두 문장을 한 문장으로 표현할 경우 명시적으로 세미콜론을 사용 - (권장하지 않는다.) 반복문 및 제어문(조건문) if, for를 사용할 경우 주의 해야 한다. func main() { // Example 1 for i := 0; i \u003c= 10; i++ { // fmt.Println(\"Example 1 : \", i);fmt.Println(\"i\") fmt.Print(\"Example 1 : \") fmt.Println(i) } // Example 2 for j := 10; j \u003e= 0; j-- { fmt.Println(\"Example 2 : \", j) } } ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:4:2","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":"GO 문법 특징 3 코드 서식을 지정해주는 유틸을 내장하고 있다. 한 사람이 코딩한 것 같은 일관성을 유지해준다. 코드 스타일을 유지해준다. # 사용법 gofmt -h # 원본 파일에 코드 스타일을 반영 gofmt -w ","date":"2021-03-17","objectID":"/archives/golang/easy-golang-section3/:4:3","tags":["go","golang"],"title":"Section 3 : Go 제어문 및 반복문","uri":"/archives/golang/easy-golang-section3/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:0:0","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"2.1 변수 및 상수 ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:1:0","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"변수 선언 GO 언어는 자료형을 정적으로 검사하므로 변수에 자료형이 정해져 있다. 정적 자료형을 지원하지만 자료형 선언 할당하는 번거로움을 벗어나게 해주는 자료형 추론 기능이 있다. 정수 타입 0, 실수 0.0, 문자열 “”, boolean (true, false) 변수 명의 첫 글자는 숫자로 시작해서는 안된다. 대소문자는 구분하며 문자, 숫자, 밑줄, 특수기호로 변수명 선언이 가능하다. var a int var b string var c, d, e int var f, g, h int = 1, 2, 3 var i float32 = 11.4 var j string = \"Hi! Golang!\" var k = 4.74 // 선언과 동시 초기화 var l = \"Hi Seoul!\" var m = true a = 4 b = \"Hello Go!\" e = 77 ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:1:1","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"여러 변수 동시 선언 // 변수 여러개를 선언 var ( name string = \"machine\" height int32 weight float32 isRunning bool ) height = 250 weight = 350.56 isRunning = true ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:1:2","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"자료형 추론(짧은 선언) Go 언어에서는 자료형이 무엇인지 알 수 있는 경우에는 자료형을 쓰지 않아도 된다. 함수 내에서만 사용 가능하다 → 전역으로는 사용 불가 주로 제한된 범위의 함수에서 사용할 경우 코드의 가독성을 높일 수 있다. func main() { shortVar1 := 3 shortVar2 := \"Test\" shortVar3 := false // shortVar :=3 true // 예외 발생 } ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:1:3","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"IF 문에서 짧은 선언 사용시 // Example if i := 10; i \u003c 11 { fmt.Println(\"Short Variable Test Success\") } ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:1:4","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"상수 상수는 변수와 달리 한 번 선언 후에는 값을 변경할 수 없다. 고정 된 값을 관리할 때 사용한다. 상수는 선언과 동시에 할당이 되어야 한다. ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:2:0","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"상수를 선언하는 방법 const a string = \"Test1\" const b = \"Test2\" const c int32 = 10 * 10 // const d = getHeight() // 함수 결과값을 할당하는 경우 예외 발생. 함수 사용할 수 없다. const e = 35.6 const f = false /* 에러 발생이 되는 경우 const g string g = \"Test3\" // 상수는 선언과 동시에 할당이 되어야 한다. */ ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:2:1","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"여러 상수 동시 선언 const a, b int = 10, 99 const c, d, e = true, 0.84, \"test\" const ( x, y int16 = 50, 90 i, k = \"Data\", 7776 ) ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:2:2","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"열거형 - Enumeration 열거형은 상수를 사용하는 일정한 규칙에 따라 숫자를 계산 및 증가시키는 묶음이다. func main() { const ( Jan = 1 Feb = 2 Mar = 3 Apr = 4 May = 5 Jun = 6 ) fmt.Println(Jan, Feb, Mar, Apr, May, Jun) // Output // 1 2 3 4 5 6 } ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:3:0","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"iota 키워드 iota는 상수 선언에서 사용할 수 있는 예약어로 연속적인 정수 상수 0, 1, 2, … 를 나타낸다. 시작값은 0이고 이후부터는 +1 증가된 값으로 선언된다. func main() { const ( A = iota * 10 B C ) fmt.Println(A, B, C) // Output: // 0 10 20 } ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:3:1","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":"중간 값 스킵하기 중간 값을 스킵하려면 _ 를 사용하여 중간 값을 스킵할 수 있다. func main() { const ( _ = iota A _ C ) fmt.Println(A, C) // Output // 1 3 const ( _ = iota + 0.75 * 2 DEFAULT SILVER _ PLATINUM ) fmt.Println(\"D : \", DEFAULT) fmt.Println(\"S : \", SILVER) // fmt.Println(\"G : \", GOLD) // 사용하는 코드는 수정해야 한다. fmt.Println(\"P : \", PLATINUM) // Output // D : 2.5 // S : 3.5 // P : 5.5 } ","date":"2021-03-13","objectID":"/archives/golang/easy-golang-section2/:3:2","tags":["go","golang"],"title":"Section 2 : Go 기초 문법","uri":"/archives/golang/easy-golang-section2/"},{"categories":["Easy Go"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:0:0","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"1. 개발 환경 설정하기 The Go Programming Language ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:1:0","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"설치 단계 Golang 설치 하기 (Golang, Git) IDE 툴 설치 (atom) GOPATH Setting 설정 및 프로젝트 디렉토리 생성 Go 설치 확인하기 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:1:1","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"1.1 Golang 설치하기 https://golang.org/에서 인스톨러로 설치한다. ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:1:2","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"1.2 IDE 툴 설치 - ATOM https://atom.io 로 Editor 를 설치한다. Shell Commands 를 설정하여 터미널 어디서나 atom 명령어로 atom을 실행 command + i : 실행 opriton + d : go doc을 쉽게 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:1:3","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"1.3 환경 변수 등록하기 GOROOT : GO가 설치 된 실제 경로. 기본적으로 /usr/local/go 로 설정되어 있음 GOPATH : GO 프로젝트가 저장될 경로 GOBIN : 실행가능한 파일들이 지정되는 경로 vi ~/.bash_profile # go export GOPATH=$HOME/study/go export GOBIN=$GOPATH/bin export PATH=/usr/local/go/bin:$GOPATH:$GOPATH/bin:$PATH # 적용 source ~/.bash_profile ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:1:4","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"1.4 GO 설치 확인하기 go env ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:1:5","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"2. 작업 공간 설정하기 Git으로 작업 공간 설정하기 작업 디렉터리(GOPATH) 작성하기 작업 공간 내의 실행 파일들에 PATH 설정하기 패키지와 라이브러리 설치하기 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:2:0","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"2.1 Git 설치하기 기본적으로 제공되는 도구들을 내려받으려면 git이 필요하다. golang.org 아래에 있는 소스들이 git으로 접근하기 때문 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:2:1","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"2.2 작업 디렉터리(GO PATH) 작성하기 mkdir -p ~/study/go cd ~/study/go bin : 실행가능한 파일이 저장되는 곳. install 을 했을 때 실행가능한 파일이 생성된다. pkg : 패키지 오브젝트 파일이 들어간다. 소스가 컴파일된 후의 코드들이 여기에 위치. 실행가능한 파일들을 아니며 라이브러리들이 들어간다고 생각하면 된다. src : 소스 코드들이 들어간다. bin 디렉터리에 대한 PATH 추가하기 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:2:2","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"2.3 ATOM 설정 유용한 패키지 설치하기 go-plus platformio-ide-terminal script File \u003e Add Proejct Folder … 프로젝트로 작업할 디렉터리 선택 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:2:3","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"2.4 내 컴퓨터에서 코드 작성해보기 mkdir -p $GOPATH/src/section1 nano $GOPATH/src/section1/helloworld.go package main import \"fmt\" func main() { fmt.Println(\"Hello world!!\") } go run 바로 실행 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:2:4","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"go build 실행 가능한 파일을 생성 단위 테스트 할 때 유용 go install install 할 경우 의존과 관련된 모든 라이브러리들을 포함하여 bin 디렉토리에 실행 가능한 파일을 생성한다. ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:2:5","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"패키지와 라이브러리 하나의 패키지는 메인 패키지 혹은 라이브러리 패키지가 될 수 있다. 메인 패키지의 경우 실행 파일이 bin 아래에 생성된다. ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:3:0","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"패키지를 import 하기 import \"github.com/riley817/gogo/hanoi\" 패키지 안에 대문자로 시작하는 함수는 모두 hanoi.Move 와 같이 접근이 가능하다 다른 패키지에서 함수를 이용할 수 없게 하려면 첫 글자를 소문자로 작성한다. ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:3:1","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"예제1 src/github.com/riley817/gogo/seq/seq.go // Package seq implements functions for well-known sequences like Fibonacci. package seq // Fib returns nth (from 0th) Fibonacci number. func Fib(n int) int { p, q := 0, 1 for i := 0; i \u003c n; i++ { p, q = q, p+q } return p } /src/github.com/riley817/gogo/seq/cmd/fib/fib.go package main import( \"fmt\" \"github.com/riley817/gogo/seq\" ) func main() { fmt.Println(seq.Fib(6)) } go run fib.go no required module provides package github.com/riley817/gogo/seq: working directory is not part of a module 메세지와 함께 빌드가 되지 않았다… github.com/riley817/gogo/seq 해당 의존성을 찾지 못해 빌드가 되지 못했고 go get 명령어를 통해 의존성을 받아온다. go get go run fib.go ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:3:2","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"라이브러리 정렬 및 코드 규칙 여러 패키지들이 들어 있을 때 gofmt 가 자동으로 알파벳 순서로 정렬을 하며 중간에 빈 칸으로 구분되어 있으면 따로 정렬이 일어난다. 패키지 이름은 소문자로만 간결하게 붙이도록 한다. 패키지 내 함수 이름도 간결하게 붙인다. util과 같은 일반적인 이름도 피하는 것이 좋다. https://blog.golang.org/package-names ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:4:0","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"도구 사용하기 godoc : Go 프로그램의 문서를 볼 수 있는 도구 Oracle : 소스 코드에 대하여 여러 가지를 물어볼 수 있는 강력한 도구 Vet : 소스 코드 검사 도구 Fix : 이미 변경된 옛 API 호출 등을 자동으로 고쳐주는 도구 Test : 테스트를 수행하는 도구 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:5:0","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"godoc godoc 은 Go 프로그램의 문서를 볼 수 있는 도구이다. command에서 확인할 수 있고 웹서버로 확인할 수도 있다. -src 를 붙이면 패키지나 함수의 소스 코드도 볼 수 있다. go doc fmt go doc fmt Printf go doc cmd/go go doc -src fmt go doc -src fmt Printf -http 옵션을 주면 웹 서버를 돌릴 수 있다. godoc -http=:6060 ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:6:0","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"GO 오픈소스의 문서를 모아둔 사이트 Home · pkg.go.dev ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:7:0","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["Easy Go"],"content":"Oracle Oracle은 소스 코드에 대하여 여러 가지를 물어볼 수 있는 매우 강력한 도구이다. 사용법이 어렵기 때문에 편집기와 연동하여 쓰는 것을 권장한다. ","date":"2021-03-08","objectID":"/archives/golang/easy-golang-section1/:8:0","tags":["go","golang"],"title":"Section 1 : 개발 환경 설정","uri":"/archives/golang/easy-golang-section1/"},{"categories":["nginx"],"content":" version: '3.0' services: gitlab: container_name: gitlab image: gitlab/gitlab-ee:latest restart: always hostname: \"gitlab.mydomain.com\" environment: TZ: 'Asia/Seoul' GITLAB_OMNIBUS_CONFIG: | external_url 'http://gitlab.mydomain.com' letsencrypt['enable'] = false nginx['redirect_http_to_https'] = false nginx['listen_https'] = false nginx['listen_port'] = 8929 gitlab_rails['gitlab_shell_ssh_port'] = 2202 ports: - \"2202:22\" - \"8929:8929\" volumes: - \"/home/ubuntu/devops/gitlab/config:/etc/gitlab\" - \"/home/ubuntu/devops/gitlab/logs:/var/log/gitlab\" - \"/home/ubuntu/devops/gitlab/data:/var/opt/gitlab\" networks: - votenet jenkins: container_name: jenkins user: root image: jenkins/jenkins:lts restart: always ports: - \"8980:8080\" environment: - GRADLE_HOME=/app/jenkins/libs/gradle volumes: - \"/home/ubuntu/devops/jenkins/jenkins_home:/var/jenkins_home\" - \"/home/ubuntu/devops/jenkins/script:/app/jenkins/script\" - \"/home/ubuntu/devops/jenkins/source:/app/jenkins/source\" - \"/home/ubuntu/devops/jenkins/ssh_key:/app/jenkins/ssh_key\" - \"/home/ubuntu/devops/jenkins/libs:/app/jenkins/libs\" - \"/var/run/docker.sock:/var/run/docker.sock\" networks: - votenet nginx: image: nginx:latest restart: always container_name: nginx environment: TZ: 'Asia/Seoul' ports: - 80:80 - 443:443 volumes: - \"/home/ubuntu/devops/nginx/nginx.conf:/etc/nginx/nginx.conf\" - \"/home/ubuntu/devops/nginx/logs:/var/log/nginx\" networks: - votenet networks: votenet: ","date":"2021-02-05","objectID":"/archives/devops/docker-compose/:0:0","tags":["nginx"],"title":"docker","uri":"/archives/devops/docker-compose/"},{"categories":["elasticsearch"],"content":"VM 세팅 ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:1:0","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["elasticsearch"],"content":"리소스 그룹 생성 --location 으로 리젼을 선택할 수 있다. # 리젼 코드 조회하기 az account list-locations -o table # elastic Resource Group 생성 az group create --name elastic --location koreasouth ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:1:1","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["elasticsearch"],"content":"VM 생성하기 elastic 그룹에 VM 을 생성한다. yoon@Azure:~$ az vm create \\ \u003e --resource-group elastic \\ \u003e --name rileyVM \\ \u003e --image UbuntuLTS \\ \u003e --admin-username riley \\ \u003e --generate-ssh-keys 빠른 시작: Azure CLI를 사용하여 Linux VM 만들기 - Azure Virtual Machines ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:1:2","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["elasticsearch"],"content":"SSH 접속 세팅 VM 생성 시 --generate-ssh-ke 의 옵션을 주어 SSH Key를 생성하였다. SSH Private Key 다운로드방법 클라우드 쉘을 실행한다. 쉘 명령어 창에 파일 다운로드를 선택한다. /.ssh/id_rsa PK 가 저장된 위치를 입력 후 다운로드 버튼 클릭 접속 시 private Key를 사용하여 접속하도록 설정한다. Moba X Term ~/.ssh/config 설정 Host riley-azure HostName {IP 주소} User {유저명} Port {SSH 포트} PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_azure ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:1:3","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["elasticsearch"],"content":"VM에 Elasticsearch 와 Kibana 를 설치하기 Azure 레퍼런스에 잘 정리되어 있다. 👻 Azure의 개발 가상 머신에서 ElasticSearch 배포 - Azure Virtual Machines ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:2:0","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["elasticsearch"],"content":"Elasticsearch, Kibana 보안설정하기 Elasticsearch와 Kibana를 외부에서도 접근하고 싶다면 보안 설정을 해주어야 한다. ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:3:0","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["elasticsearch"],"content":"Elasticsearch와 Kibana host 설정 외부 IP로 접근이 가능하도록 host를 0.0.0.0 로 설정한 후 각각 서비스를 restart 한다. ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:3:1","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["elasticsearch"],"content":"elasticsearch.yml 설정 /etc/elasticsearch/elasticsearch.yml node.name에 노드 이름을 지어준다. network.host: 0.0.0.0 으로 설정해야 외부 IP에서 방화벽이 열려있는 경우 접근 할 수 있다. cluster.initial_master_nodes: [\"node-1\"] 엘라스틱서치를 여러개 돌릴경우 각각의 노드이름을 지정해주어야 한다. # ======================== Elasticsearch Configuration ========================= # # NOTE: Elasticsearch comes with reasonable defaults for most settings. # Before you set out to tweak and tune the configuration, make sure you # understand what are you trying to accomplish and the consequences. # # The primary way of configuring a node is via this file. This template lists # the most important settings you may want to configure for a production cluster. # # Please consult the documentation for further information on configuration options: # https://www.elastic.co/guide/en/elasticsearch/reference/index.html # # ---------------------------------- Cluster ----------------------------------- # # Use a descriptive name for your cluster: # #cluster.name: my-application # # ------------------------------------ Node ------------------------------------ # # Use a descriptive name for the node: # node.name: node-1 # # Add custom attributes to the node: # #node.attr.rack: r1 # # ----------------------------------- Paths ------------------------------------ # # Path to directory where to store the data (separate multiple locations by comma): # path.data: /var/lib/elasticsearch # # Path to log files: # path.logs: /var/log/elasticsearch # # ----------------------------------- Memory ----------------------------------- # # Lock the memory on startup: # #bootstrap.memory_lock: true # # Make sure that the heap size is set to about half the memory available # on the system and that the owner of the process is allowed to use this # limit. # # Elasticsearch performs poorly when the system is swapping the memory. # # ---------------------------------- Network ----------------------------------- # # Set the bind address to a specific IP (IPv4 or IPv6): # network.host: 0.0.0.0 # # Set a custom port for HTTP: # #http.port: 9200 # # For more information, consult the network module documentation. # # --------------------------------- Discovery ---------------------------------- # # Pass an initial list of hosts to perform discovery when this node is started: # The default list of hosts is [\"127.0.0.1\", \"[::1]\"] # discovery.seed_hosts: [\"127.0.0.1\"] # # Bootstrap the cluster using an initial set of master-eligible nodes: # cluster.initial_master_nodes: [\"node-1\"] # # For more information, consult the discovery and cluster formation module documentation. # # ---------------------------------- Gateway ----------------------------------- # # Block initial recovery after a full cluster restart until N nodes are started: # #gateway.recover_after_nodes: 3 # # For more information, consult the gateway module documentation. # # ---------------------------------- Various ----------------------------------- # # Require explicit names when deleting indices: # #action.destructive_requires_name: true ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:3:2","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["elasticsearch"],"content":"kibana.yml 설정 /etc/kibana/kibana.yml server.host에 0.0.0.0으로 설정해준다. # Kibana is served by a back end server. This setting specifies the port to use. #server.port: 5601 # Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values. # The default is 'localhost', which usually means remote machines will not be able to connect. # To allow connections from remote users, set this parameter to a non-loopback address. server.host: \"0.0.0.0\" ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:3:3","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["elasticsearch"],"content":"Azure 인바운드 설정하기 홈 \u003e 가상 머신 \u003e {가상머신 이름} \u003e 설정 \u003e 네트워킹 특정 IP에서만 접근 가능하도록 IP 추가 지정할 포트가 여러개인 경우 , 로 여러개를 나열하면 된다. ","date":"2021-01-22","objectID":"/archives/elasticsearch/azure-vm-elastic-stack/:3:4","tags":["elasticsearch","elasticsearch cloud","filebeat","azure"],"title":"Azure VM에 Elastic Stack 설정","uri":"/archives/elasticsearch/azure-vm-elastic-stack/"},{"categories":["docker/kubernetes"],"content":"docker 다운로드 및 이미지 생성 docker에서 내려 받을 수 있는 mysql 버전 확인 : https://hub.docker.com/_/mysql/ 버전을 명시 하지 않으면 가장 최신 버전을 다운로드하게 됨 # docker pull sudo docker pull mysql:8 # docker 이미지 확인 sudo docker images docker Mysql 컨테이너 생성 및 실행 # mysql 컨테이너 생성 및 실행 sudo docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=PASSWORD --name mysql8 -v /usr/riley/datadir:/var/lib/mysql mysql:8 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci # 실행된 컨테이너 확인 sudo docker ps -a MySql 컨테이너 bash 쉘 접속하여 MySQL 에 접속하기 # 컨테이너 bash 쉘 접속 sudo docker exec -it mysql8 bash # mysql 접속 mysql -u root -p 데이터베이스의 유저를 생성하고 권한 부여 % : 모든 접속을 허용. mysql\u003e CREATE USER 'riley'@'%' IDENTIFIED BY '패스워드'; Query OK, 0 rows affected (0.01 sec) mysql\u003e GRANT ALL PRIVILEGES ON *.* TO 'riley'@'%'; Query OK, 0 rows affected (0.00 sec) mysql\u003e flush privileges; Query OK, 0 rows affected (0.00 sec) ","date":"2020-05-30","objectID":"/archives/docker-kubernetes/docker-mysql/:0:1","tags":["docker"],"title":"Doker로 MySQL 설치하기","uri":"/archives/docker-kubernetes/docker-mysql/"},{"categories":["git"],"content":"git submodule 삭제하기 1. .gitmodules를 열어 해당 서브 모듈이 정의된 부분을 제거하거나 파일을 지운다. .gitmodules에 불필요한 모듈만 제거하거나 .gitmodules 파일이 불필요하다면 아예 삭제해 버린다. 2. .git/config 파일을 열어 불필요한 서브 모듈을 삭제한다. vi PROJECT_ROOT/.git/config 3. 해당 저장소의 캐시를 제거한다. # git rm --cached path_to_submodule git rm --cached spring-module-common 4. .git/modules/path_to_submodule 파일을 삭제한다. cd PROJECT_ROOT/.git/modules rm --rf spring-module-common 5. 변경된 사항을 커밋 한다. ","date":"2020-05-24","objectID":"/archives/git/git-submodule/:1:0","tags":["git","git submodule"],"title":"git submodule 삭제하기","uri":"/archives/git/git-submodule/"},{"categories":["git"],"content":"참고 https://git.wiki.kernel.org/index.php/GitSubmoduleTutorial#Removal ","date":"2020-05-24","objectID":"/archives/git/git-submodule/:2:0","tags":["git","git submodule"],"title":"git submodule 삭제하기","uri":"/archives/git/git-submodule/"},{"categories":["git"],"content":".gitignore .gitignore에 의도적으로 추적을 원하지 않는 파일을 무시하도록 지정할 수 있다. 그러나 git이 이미 추적을 한 파일은 영향을 받지 않는다. 이미 한번 추적이 된 파일을 .gitignore 파일에 적용하려면 아래와 같이 캐시를 삭제해 주어야 한다. git rm -r --cached . git add . git commit -m \"Apply .gitignore\" git push ","date":"2020-05-11","objectID":"/archives/git/git-ignore/:1:0","tags":["git","gitignore"],"title":"gitignore 적용하기","uri":"/archives/git/git-ignore/"},{"categories":["nginx"],"content":"nginx 컴파일 설치하기 CentOS 7에서 NGINX를 컴파일 버전으로 설치한다. 컴파일 설치를 하기 위해서는 몇 가지 라이브러리가 필요하다. 필요 의존 라이브러리는 openssl, pcre, zlib 등이 필요하므로 먼저 설치한다. ","date":"2020-05-06","objectID":"/archives/devops/nginx-compile/:1:0","tags":["nginx"],"title":"nginx 컴파일 설치하기 - centos7","uri":"/archives/devops/nginx-compile/"},{"categories":["nginx"],"content":"컴파일을 위한 라이브러리 설치 # pcre 라이브러리 설치 yum install pcre* # gzip 압축을 사용하기 위해서 설치 yum install zlib zlib-devel # open ssl 설치 yum install openssl openssl-devel # gcc 설치 yum install gcc ","date":"2020-05-06","objectID":"/archives/devops/nginx-compile/:1:1","tags":["nginx"],"title":"nginx 컴파일 설치하기 - centos7","uri":"/archives/devops/nginx-compile/"},{"categories":["nginx"],"content":"nginx 소스 파일을 다운로드 최신 버전 경로는 아래 url에 접속하여 원하는 버전 링크를 복사한다. http://nginx.org/en/download.html cd /usr/local/src # 원하는 버전 다운로드 wget http://nginx.org/download/nginx-1.14.0.tar.gz # 압축해제 tar xzf nginx-1.14.0.tar.gz ","date":"2020-05-06","objectID":"/archives/devops/nginx-compile/:1:2","tags":["nginx"],"title":"nginx 컴파일 설치하기 - centos7","uri":"/archives/devops/nginx-compile/"},{"categories":["nginx"],"content":"컴파일 –prefix에 nginx 루트 경로를 설정한다. 자세한 컴파일 옵션은 nginx Document를 참고한다. http://nginx.org/en/docs/configure.html ./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_gzip_static_module --with-http_flv_module --with-http_mp4_module --with-http_realip_module --with-http_v2_module --user=riley --group=riley # 컴파일 후 인스톨 make \u0026\u0026 make install ","date":"2020-05-06","objectID":"/archives/devops/nginx-compile/:1:3","tags":["nginx"],"title":"nginx 컴파일 설치하기 - centos7","uri":"/archives/devops/nginx-compile/"},{"categories":["nginx"],"content":"실행 스크립트 생성 # nginx-start.sh #!/bin/sh /usr/local/nginx/sbin/nginx # nginx-stop.sh #!/bin/sh /usr/local/nginx/sbin/nginx -s stop # nginx-reload.sh #!/bin/sh /usr/local/nginx/sbin/nginx -s reload chmod +x nginx-*.sh ","date":"2020-05-06","objectID":"/archives/devops/nginx-compile/:1:4","tags":["nginx"],"title":"nginx 컴파일 설치하기 - centos7","uri":"/archives/devops/nginx-compile/"},{"categories":["nginx"],"content":"nginx CORS 활성화 하기 nginx에서 CORS(Cross-Origin Resource Sharing) 설정을 활성화한다. ","date":"2020-05-06","objectID":"/archives/devops/nginx-cors/:1:0","tags":["nginx"],"title":"nginx CORS 활성화 하기","uri":"/archives/devops/nginx-cors/"},{"categories":["nginx"],"content":"nginx 설정파일 # # Wide-open CORS config for nginx # location / { if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; # # Custom headers and headers various browsers *should* be OK with but aren't # add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'; # # Tell client that this pre-flight info is valid for 20 days # add_header 'Access-Control-Max-Age' 1728000; add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; return 204; } if ($request_method = 'POST') { add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'; add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range'; } if ($request_method = 'GET') { add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'; add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range'; } } ","date":"2020-05-06","objectID":"/archives/devops/nginx-cors/:1:1","tags":["nginx"],"title":"nginx CORS 활성화 하기","uri":"/archives/devops/nginx-cors/"},{"categories":["java"],"content":" 자바 기본 잊지 않게 정리하기! 🤔 ","date":"2020-04-19","objectID":"/archives/java/thread/:0:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"프로세스와 스레드 프로세스(process) : 운영체제에서 실행 중인 하나의 애플리케이션을 의미 멀티 태스킹(multi tasking) 운영 체제에서 두 가지 이상의 다중 작업(프로세스)를 동시에 처리하는 것을 의미. 운영 체제에서는 멀티 태스킹을 할 수 있도록 CPU 및 메모리 자원을 적절히 할당하고 병렬로 실행시킨다. 할당받은 메모리를 가지고 실행하기 때문에 독립적이다. ","date":"2020-04-19","objectID":"/archives/java/thread/:1:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"메인 스레드 자바 애플리케이션은 메인 스레드(main thread)가 main() 메소드를 실행 하면서 시작. 메인 스레드는 필요에 따라 작업 스레드를 만들어 병렬로 실행 가능하다. 싱글 스레드에서는 메인 스레드가 종료되면 프로세스가 종료되지만, 멀티 스레드 애플리케이션에서는 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다. ","date":"2020-04-19","objectID":"/archives/java/thread/:2:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"작업 스레드 생성과 실행 자바에서는 스레드도 객체(클래스)로 생성된다. ","date":"2020-04-19","objectID":"/archives/java/thread/:3:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"implements runnable Runnable : 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체 인터페이스 타입이므로 run()을 재정의하여 실행 코드를 작성 Thread thread = new Thread(Runnable target); start() : 작업스레드는 매개값으로 받은 Runnable의 run() 메소드를 실행한다. Runnable task = new Task(); Thread thread = new Thread(task); /* Ruunable 익명 객체 */ Thread thread = new Thread(new Runnable() { @Override public void run() { // 스레드가 실행할 코드 } }); /* Java8 람다식 */ Thread thread = new Thread(() -\u003e { // 스레드가 실행할 코드 }); // 작업 스레드 실행 thread.start(); ","date":"2020-04-19","objectID":"/archives/java/thread/:3:1","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"extends thread Thread 클래스를 상속한 후 run 메소드를 재정의(overriding)해서 스레드가 실행할 코드를 작성 public class WorkerThread extends Thread { @Override public void run() { // 스레드가 실행할 코드 } } Thread thread = new WorkerThread(); /* 익명의 자식 객체로 생성 */ Thread thread = new Thread() { @Override public void run() { // 스레드가 실행할 코드 } }; ","date":"2020-04-19","objectID":"/archives/java/thread/:3:2","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"implements Runnable vs extends Thread 자바에서는 다중 상속을 허용하지 않기 때문에 extends Thread의 경우 다른 클래스의 상속을 받을 수 없다. 인터페이스의 경우 다중 상속이 가능하기 때문에 다른 클래스를 상속 받을 수 있다. 그러므로 implements Runnable을 통해 재 정의하여 확장하는 경우가 많다. ","date":"2020-04-19","objectID":"/archives/java/thread/:4:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"스레드의 이름 스레드는 자신의 이름을 setName()로 변경한다. 스레드 객체의 참조가 필요한 경우 Thread.currentThread()로 코드를 실행하는 현재 스레드의 참조를 얻을 수 있다. Thread thread = Thread.currentThread(); ","date":"2020-04-19","objectID":"/archives/java/thread/:5:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"스레드의 스케줄링 동시성(Concurrency) : 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질 병렬성(Parallelism) : 멀티 코어에서 개별 스레드를 동시에 실행하는 성질 스레드의 개수가 코어의 수보다 많을 경우, 스레드를 어떤 순서에 의해 동시성으로 실행할 것 인가를 결정해야 한다. 이것을 스레드 스케줄링 이라고 한다. ","date":"2020-04-19","objectID":"/archives/java/thread/:6:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"자바의 스레드 스케줄링 방식 우선순위(Priority)방식 우선순위가 높은 스레드가 실행 기회를 더 많이 갖는다. 스레드 객체에 우선순위 번호를 부여할 수 있어 개발자가 코드를 제어할 수 있다. 우선순위는 동시성에서만 의미가 있다고 볼 수 있다. 순환할당(Round-Robin)방식 시간 할당량 Time Slice을 정해서 하나의 스레드를 정해진 시간만큼 실행한다. ","date":"2020-04-19","objectID":"/archives/java/thread/:6:1","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"스레드 우선순위 우선순위는 1에서부터 10까지 부여. 1이 가장우선순위가 낮고 10이 가장 높음. Thread 클래스 상수로도 지정할 수 있다. 만약 쿼드 코어일 경우 4개의 스레드가 병렬성으로 실행 될 수 있기 때문에 4개 이하의 스레드를 실행할 경우 우선순위 방식이 크게 영향을 미치지 못함. thread.setPriority(Thread.MAX_PRIORITY); // 10 thread.setPriority(Thread.NORM_PRIORITY); // 5 thread.setPriority(Thread.MIN_PRIORITY); // 1 ","date":"2020-04-19","objectID":"/archives/java/thread/:6:2","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"동기화 메소드와 동기화 블록 ","date":"2020-04-19","objectID":"/archives/java/thread/:7:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"공유 객체를 사용할 때 주의할 점 멀티 스레드에서는 스레드들이 객체를 공유해서 작업해야 하는 경우가 있음. 스레드 A를 사용하던 객체가 스레드 B에 의해 상태가 변경될 수 있기 때문에 의도했던 것과 다른 결과를 산출 될 수 있다. ","date":"2020-04-19","objectID":"/archives/java/thread/:7:1","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"synchronized 임계 영역(critical section) : 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역 자바는 임계영역을 지정하기 위해 동기화(synchronize) 메소드와 블록을 제공. 스레드가 객체 내부의 동기화 메소드 또는 블록에 들어가면 즉시 객체에 잠금을 걸어 다른 스레드가 임계 영역 코드를 실행하지 못하도록 한다. synchronized 키워드는 인스턴스와 정적 메소드 어디든 붙일 수 있다. public synchronized void method() { // 임계 영역; } public void method() { // 여러 스레드가 실행 가능한 영역 ... synchronized(공유객체) { /*동기화 블록*/ // 임계 영역 } // 여러 스레드가 실행 가능한 영역 ... } ","date":"2020-04-19","objectID":"/archives/java/thread/:7:2","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"스레드 상태 스레드 객체를 생성하고 start() 메소드를 호출하면 실행 대기 상태가 된다. 실행 대기란 아직 스케줄링이 되지 않아 실행을 기다리고 있는 상태를 의미한다. 실행 대기 상태에 있는 스레드 중 스레드 스케줄링에 의해 CPU를 점유하고 run() 메소드를 실행한다. 일시 정지 상태 : WAITING, TIMED_WAITING, BLOCKED ","date":"2020-04-19","objectID":"/archives/java/thread/:8:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"Thread.State 열거 상수 상태 열거 상수 설명 객체 생성 NEW 스레드 객체 생성. 아직 start() 메소드 호출 전. 실행 대기 RUNNABLE 실행 상태로 언제든지 갈 수 있는 상태. 일시 정지 WAITING 다른 스레드가 통지(Notify)할 때까지 기다리는 상태 일시 정지 TIMED_WAITING 주어진 시간 동안 기다리는 상태 일시 정지 BLOCKED 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태 종료 TERMINATED 실행을 마친 상태 ","date":"2020-04-19","objectID":"/archives/java/thread/:8:1","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["java"],"content":"스레드 상태 제어 스레드 상태 제어 : 실행 중인 스레드의 상태를 변경하는 것 멀티 스레드 환경에서는 정교한 스레드 상태 제어가 필요하며, 스레드의 상태 변화를 가져오는 메소드를 파악해야 한다. ","date":"2020-04-19","objectID":"/archives/java/thread/:9:0","tags":["java"],"title":"Multi Thread","uri":"/archives/java/thread/"},{"categories":["devops"],"content":"목표 AWS에서 Cent OS 7로 테스트 서버를 구축한다. 콘솔접속경로 1. 콘솔 대시보드에서 인스턴스 시작을 선택한다. 2. Amazon Machine Image(AMI)에서 인스턴스 템플릿을 선택한다. 검색 창에 centos를 검색 후 원하는 버전을 선택한다. 3. 인스턴스 유형 선택 페이지에서 하드웨어 구성을 선택한다. 일단 난 프리티어니깐… t2.micro를 선택 🤔 4. 🤷🏻‍♀️ 검토 후 시작(Review and Launch) 버튼을 클릭하여 구성을 완료한다. 5. 보안 그룹 구성 6. 인스턴스 시작 검토 페이지에서 시작을 선택한다. 7. 키 페어 생성화면에서 키 페어를 생성한다. 프라이빗 키 파일(*.pem)을 다운로드한다. 해당 키로 EC2 인스턴스 액세스할 수 있다. 키 페어가 없이 처음에는 인스턴스에 연결할 수 없으므로 꼭 다운로드 한다. 준비가 완료되면 인스턴스 시작을 선택한다.👏🏻👏🏻👏🏻 ","date":"2020-03-20","objectID":"/archives/devops/build-aws-centos7/:1:0","tags":["aws","centos","devops"],"title":"AWS CentOS7 테스트 서버 구축하기","uri":"/archives/devops/build-aws-centos7/"},{"categories":["devops"],"content":"Mac 접속 설정하기 ~/.ssh/config centos AMI의 경우 접속계정은 centos이다. Linux 인스턴스 연결시 각 OS별 계정정보 참고 PuTTY를 사용하여 Windows에서 Linux 인스턴스에 연결 Host riley-aws HostName \"publicIP\" User centos Port 22 IdentityFile ~/.ssh/riley.pem .pem로 ssh 접속시 bad permissions 오류가 발생할 때 chmod 400 \u003cyour\u003e.pem ","date":"2020-03-20","objectID":"/archives/devops/build-aws-centos7/:1:1","tags":["aws","centos","devops"],"title":"AWS CentOS7 테스트 서버 구축하기","uri":"/archives/devops/build-aws-centos7/"},{"categories":["devops"],"content":"root 계정의 직접 접속 차단하기 Linux의 ssh 기본 설정에는 root 로그인이 허용되어 있다. 포트스캐닝을 통해 ssh 포트가 열려 있는게 확인되면 해커에 의해 무작위로 root 계정으로 ssh 접속을 시도 할 수 있다. 그러므로 root 계정으로 직접 접속을 차단하는 것이 좋다. sudo vi /etc/ssh/sshd_config #LoginGraceTime 2m PermitRootLogin no #StrictModes yes #MaxAuthTries 6 #MaxSessions 10 # 아무출력도 없으면 잘된거임 sudo systemctl restart sshd.service ","date":"2020-03-20","objectID":"/archives/devops/build-aws-centos7/:1:2","tags":["aws","centos","devops"],"title":"AWS CentOS7 테스트 서버 구축하기","uri":"/archives/devops/build-aws-centos7/"},{"categories":["devops"],"content":"계정 생성 및 패스워드 설정 root password 설정 sudo passwd root 사용자 추가하기 su -root adduser kai 새로 생성한 계정의 패스워드 설정하기 sudo passwd kai 새로 생성한 계정에 root 권한을 사용할 수 있도록 설정 sudo visudo ## Next comes the main part: which users can run what software on ## which machines (the sudoers file can be shared between multiple ## systems). ## Syntax: ## ## user MACHINE=COMMANDS ## ## The COMMANDS section may have other options added to it. ## ## Allow root to run any commands anywhere root ALL=(ALL) ALL kai ALL=(ALL) ALL ","date":"2020-03-20","objectID":"/archives/devops/build-aws-centos7/:1:3","tags":["aws","centos","devops"],"title":"AWS CentOS7 테스트 서버 구축하기","uri":"/archives/devops/build-aws-centos7/"},{"categories":["database"],"content":"이슈 해당 정보를 입력하고 연결정보를 클릭시 아래와 같은 에러가 발생하였다. Database \"/Users/riley/test\" not found, and IFEXISTS=true, so we cant auto-create it [90146-199] 90146/90146 ","date":"2020-03-20","objectID":"/archives/dbms/h2-database-not-found/:1:0","tags":["h2","database","issue note"],"title":"H2 설치후 연결시 Database ~ not found, and IFEXISTS=true, so we cant auto-create it [90146-199]","uri":"/archives/dbms/h2-database-not-found/"},{"categories":["database"],"content":"문제 해결 단계 아래 링크를 통하여 test 라는 이름의 새로운 데이터베이스를 생성해줌으로써 해결하였다. http://www.h2database.com/html/tutorial.html#creating_new_databases # 설치경로로 이동 cd /Users/riley/Utils/h2/bin 이동하면 h2-버전명 jar 파일이 있다. h2 쉘을 아래와 같이 실행해준다. java -cp h2-1.4.199.jar org.h2.tools.Shell URL 은 jdbc:h2:~/test 로 지정하였다. jdbc:h2:~/test 로 접속 URL 을 설정하였지만 어플리케이션에서 접속시 URL 은 jdbc:h2:tcp://localhost/~/test 로 접속해야한다. ","date":"2020-03-20","objectID":"/archives/dbms/h2-database-not-found/:2:0","tags":["h2","database","issue note"],"title":"H2 설치후 연결시 Database ~ not found, and IFEXISTS=true, so we cant auto-create it [90146-199]","uri":"/archives/dbms/h2-database-not-found/"},{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":" 시작하세요! 도커/쿠버네티스 책 정리 🐳🐳🐳 도커(docker)는 리눅스 컨테이너에 여러 기능을 추가함으로써 애플리케이션을 컨테이너로서 좀 더 쉽게 사용할 수 있게 만들어진 오픈소스 프로젝트이다. GO 언어로 작성되어 있으며 2013년 3월에 첫 번째 릴리스가 발표된 이후 지금까지 꾸준히 개발되고 있다. 도커와 관련된 프로젝트 Docker Compose Private Registry Docker Machine Kitematic 도커라고 하면 Docker Engine 혹은 도커와 관련된 모든 프로젝트를 의미한다. 도커 생태계에 있는 여러 프로젝트들은 도커 엔진을 좀 더 효율적으로 사용하기 위한 것에 불과하며 핵심이 되는 것은 도커 엔진이다. ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:0:0","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"1.1 가상 머신과 도커 컨테이너 ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:1:0","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"기존의 가상화 기술 [그림] 가상 머신 구조 하이퍼바이저를 이용해 여러 개의 운영체제를 하나의 호스트에서 생성해 사용하는 방식 여러 운영체제는 가상 머신이라는 단위로 구분되며 각 가상머신에는 Ubuntu, CentOS 등의 운영체제가 설치되어 사용되어짐. Guest OS : 하이퍼바이저에 의해 생성되고 관리되는 운영체제. 각 게스트 운영체제는 다른 게스트 운영체제와 완전히 독립된 공간과 시스템 자원을 할당받게 됨. Host OS : 서버를 부팅할 때 실행되는 운영체제 대표적인 가상화 툴 : VirtualBox, VMware 등 ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:1:1","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"기존의 가상화 기술의 문제점 하이퍼바이저를 반드시 거치기 때문에 일반 호스트 OS에 비해 성능이 손실이 발생 게스트 OS를 운영하기 위한 라이브러리, 커널 등을 전부 포함하기 때문에 가상머신의 이미지 크기가 클 수밖에 없음 ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:1:2","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"도커 컨테이너 [그림] 도커 컨테이너 구조 [출처] https://www.docker.com/resources/what-container ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:1:3","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"도커 컨테이너의 장점 성능 손실이 적다 가상화된 공간을 생성하기 위해 리눅스 자체 기능인 chroot, name space, cgroup을 사용함으로써 프로세스 단위의 격리 환경을 만들기 때문에 성능 손실이 없음. 이미지 용량이 가상머신에 비해 줄어들어 이미지를 만들고 배포하는 시간이 빠르다 컨테이너 필요한 커널은 호스트의 커널을 공유해 사용하고, 컨테이너 안에 애플리케이션 구동하는 데 필요한 라이브러리 및 실행 파일만 존재하므로 이미지 용량이 가상 머신에 비해 대폭 줄어듬. ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:1:4","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"1.2 도커를 시작해야 하는 이유 도커는 컨테이너 생태계에서 사실상 표준으로 사용 쿠버네티스, 메소스와 같은 오픈소스 프로젝트에서도 도커를 기준으로 개발 ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:2:0","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"1.2.1 애플리케이션의 개발과 배포가 편하다 도커 컨테이너는 호스트 OS 위에서 실행되는 격리 공간이기 때문에 독립된 개발 환경을 보장받을 수 있다. 도커 이미지라고 하는 일종의 패키지로 만들어서 관리하기 때문에 설치 작업 없이 복제를 통하여 간편하게 통합 환경 구성이 가능하다. ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:2:1","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"1.2.2 여러 애플리케션의 독립성과 확장성이 높아진다. 모놀리스(Monolith) 애플리케이션 소프트웨어의 여러 모듈이 상호 작용하는 로직을 하나의 프로그램에서 구동시키는 방식. 서비스의 기능이 복잡해지고 거대하질수록 확장성과 유연성이 줄어든다. 마이크로서비스(Micro-service) 여러 모듈을 독립된 형태로 구성하기 때문에 언어에 종속되지 않고 변화에 빠르게 대응 할 수 있고 각 모듈의 관리가 쉬워진다. 도커 컨테이너는 수 초 내로 생성과 시작이 가능하고 여러 모듈을 독립된 환경을 동시에 제공할 수 있어 마이크로서비스 구조에서 가장 많이 사용. 웹 서비스는 데이터베이스 컨테이너와 서버 컨테이너로 분리할 수 있으며, 웹 서비스에 부하가 발생할 시 마이크로서비스 구조의 웹 서버 컨테이너만을 동적으로 늘려서 부하를 분산할 수 있다. 웹 서버와 데이터베이스의 이미지를 독립적으로 관리하기 때문에 유지 보수도 용이 마이크로서비스는 개발자가 직접 구현하기보다 도커 스웜 모드, 쿠버네티스 등 컨테이너 오케스트레이션 플랫폼을 통해 사용하는 것이 일반적 ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:2:2","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"1.3 도커 엔진 설치 도커는 리눅스 컨테이너를 제어는 API를 Go 언어로 구현한 libcontainer를 사용하기 때문에 대부분 리눅스 운영체제에서 사용할 수 있다. 마이크로소프트 윈도우, 맥 OS X 에서도 도커를 사용할 수 있지만 윈도우 10, 맥 OS X 10.10.3 Yosemite 이전 버전을 사용한다면 도커를 사용하기 위해 별도의 가상화 공간을 생성해야 한다. ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:3:0","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"1.3.1 도커 엔진의 종류 및 버전 EE(Docker Enterprise Edition) 인 유료버전과 CE(Community Edition) 인 무료 버전으로 구분되어 제공 버전은 (출시 년도)-(출시 월)-(도커 엔진 종류) 의 형태 EE와 CE 부가적인 서비스 지원 수준에 차이만 있을 뿐 핵심적인 컨테이너 기술을 CE에서도 동일하게 사용가능 ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:3:1","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"1.3.2 리눅스 도커 엔진 설치 확인사항 최신 버전의 커널을 사용하고 있는지 확인한다. 호스트 운영체제가 최소한 3.10 버전 이상을 사용해야 도커가 정상적으로 사용 가능 uname -r 명령어를 통해 커널 버전을 확인한다. 지원 기간 내에 있는 배포 판인지 확인한다. 일부 오래된 리눅스 배포판은 업데이트 등의 지원을 받지 못할 수 있음. 64비트 리눅스 인지 확인 도커는 64비트에 최적화 되어 있으며 32비트 버전에서 도커를 실행하는 방법은 권장하지 않음 sudo 명령어를 통해 설치하거나 root 권한을 소유한 계정에서 설치를 진행해야 한다. 도커 설치 가이드 Install Docker Engine CentOS 7, RHEL7 sudo yum install -y yum-utils sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io sudo systemctl start docker # docker 가 정상동작하는지 확인하기 sudo docker info Ubuntu 14.04, 16.04, 18.04 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" apt-get update apt-get install docker-ce ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:3:2","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"1.3.3 윈도우, 맥 OS 도커 설치 이전에는 윈도우와 맥 OS X에서 도커를 설치하려면 도커 툴박스라는 패키지를 설치해야 했음. 최근에는 자체 가상화 기술을 사용한 도커가 설치되어 버추얼박스에 의존하지 않고 도커를 설치할 수 있다. Docker for Windows는 Hyper-V, Docker for Mac OS X 는 xhyve 기술을 이용한다. Docker for Windows WSL2 설정 Windows WSL2 리눅스 가상환경에서 도커를 실행할 경우 해당 옵션을 선택하면 된다. (Installer 실행시 꼭 관리자권한으로 실행…) WSL 2에서 Docker 원격 컨테이너 시작 General \u003e Use the WSL 2 based engine Resources \u003e WSL INTEGRATION \u003e Enable integration with my default WSL distro ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:3:3","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":null,"content":"Trouble Shooting centos 7.3 docker-engine conflicts with docker-common-2 ","date":"2019-08-02","objectID":"/archives/docker-kubernetes/chapter1-docker/:4:0","tags":null,"title":"About LoveIt","uri":"/archives/docker-kubernetes/chapter1-docker/"},{"categories":["jpa"],"content":"김영한님의 책 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2019-01-13","objectID":"/archives/dbms/jpa/jpa-programming6-2/:0:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 일대다","uri":"/archives/dbms/jpa/jpa-programming6-2/"},{"categories":["jpa"],"content":"6.2 일대다 일대다 관계는 엔티티를 하나 이상 참조할 수 있으므로 자바 컬렉션 (Collection, List, Set, Map ) 중 하나를 사용한다. ","date":"2019-01-13","objectID":"/archives/dbms/jpa/jpa-programming6-2/:1:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 일대다","uri":"/archives/dbms/jpa/jpa-programming6-2/"},{"categories":["jpa"],"content":"6.2.1 일대다 단방향 [1:N] 일대다 단방향 관계는 JPA 2.0 부터 지원한다. 일대다 단방향의 경우 반대편에서 테이블의 외래키를 관리하는 특이한 모습이 나타난다. Team.java @Entity public class Team { @Id @GeneratedValue @Column(name = \"TEAM_ID\") private String id; private String name; @OneToMany @JoinColumn (name = \"TEAM_ID\") // MEMBER 테이블의 TEAM_ID (FK) private List\u003cMember\u003e members = new ArrayList\u003cMember\u003e(); } Member.java @Entity public class Member { @Id @GeneratedValue @Column(name = \"MEMBER_ID\") private Long id; private String username; // Getter, Setter... } 일대다 단방향 관계를 매핑할때는 @JoinColumn 을 명시. ","date":"2019-01-13","objectID":"/archives/dbms/jpa/jpa-programming6-2/:1:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 일대다","uri":"/archives/dbms/jpa/jpa-programming6-2/"},{"categories":["jpa"],"content":"일대다 단방향 매핑의 단점 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점. public void testSave() { Member member1 = new Member(\"member1\"); Member member2 = new Member(\"member2\"); Team team1 = new Tema(\"team1\"); team1.getMembers().add(member1); team2.getMembers().add(member2); em.persist(member1); em.persist(member2); em.persist(team1); } ","date":"2019-01-13","objectID":"/archives/dbms/jpa/jpa-programming6-2/:1:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 일대다","uri":"/archives/dbms/jpa/jpa-programming6-2/"},{"categories":["jpa"],"content":"김영한님의 책 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2019-01-10","objectID":"/archives/dbms/jpa/jpa-programming6-1/:0:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/archives/dbms/jpa/jpa-programming6-1/"},{"categories":["jpa"],"content":"다양한 연관관계 다루기 ","date":"2019-01-10","objectID":"/archives/dbms/jpa/jpa-programming6-1/:1:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/archives/dbms/jpa/jpa-programming6-1/"},{"categories":["jpa"],"content":"엔티티의 연관관계를 매핑할때 고려할점 다중성 단방향, 양방향 연관관계의 주인 ","date":"2019-01-10","objectID":"/archives/dbms/jpa/jpa-programming6-1/:1:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/archives/dbms/jpa/jpa-programming6-1/"},{"categories":["jpa"],"content":"다중성 다대일(@ManyToOne), 일대다(@OneToMany), 일대일(@OneToOne), 다대다(@ManyToMany) 다중성을 판단하기 어려울 때는 반대방향을 생각해보자. 보통 다대일과 일대다 관계를 가장 많이 사용하고 다대다 관계는 실무에서는 거의 사용하지 않음. ","date":"2019-01-10","objectID":"/archives/dbms/jpa/jpa-programming6-1/:1:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/archives/dbms/jpa/jpa-programming6-1/"},{"categories":["jpa"],"content":"단방향, 양방향 객체 관계에서 한쪽만 참고하는 것을 단방향 관계라고하며, 양쪽이 서로 참조하는 것을 양방향 관계라 한다. ","date":"2019-01-10","objectID":"/archives/dbms/jpa/jpa-programming6-1/:1:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/archives/dbms/jpa/jpa-programming6-1/"},{"categories":["jpa"],"content":"연관관계의 주인 외래 키를 가진 테이블과 매핑한 엔티티가 외래키를 관리하는게 효율적이므로 보통 이곳을 연관관계의 주인으로 선택한다. 연관관계의 주인이 아니면 mappedBy 속성을 사용하며, 연관관계 주인의 필드 이름을 값으로 입력한다. ","date":"2019-01-10","objectID":"/archives/dbms/jpa/jpa-programming6-1/:1:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/archives/dbms/jpa/jpa-programming6-1/"},{"categories":["jpa"],"content":"6.1 다대일 다대일 관계에서 외래키는 항상 다(N) 쪽에 있다. 객체 양방향 관계에서 연관관계의 주인은 항상 다쪽이다. ","date":"2019-01-10","objectID":"/archives/dbms/jpa/jpa-programming6-1/:2:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/archives/dbms/jpa/jpa-programming6-1/"},{"categories":["jpa"],"content":"6.1.1 다대일 단방향 [N:1] @Entity public class Member { @Id @GeneratedValue @Column(name = \"MEMBER_ID\") private Long id; private String username; // 연관관계 매핑 @ManyToOne @JoinColumn(name = \"TEAM_ID\") private Team team; // Getter, Setter... } Team.java @Entity public class Team { @Id @GeneratedValue @Column(name = \"TEAM_ID\") private Long id; private String name; // Getter, Setter ... } 회원은 Member.team 으로 팀 엔티티를 참조할 수 있다. (반대로 팀에는 회원을 참조하는 필드가 없다.) @JoinColumn(name = \"TEAM_ID\") : TEAM_ID 외래키와 매핑했다. ","date":"2019-01-10","objectID":"/archives/dbms/jpa/jpa-programming6-1/:2:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/archives/dbms/jpa/jpa-programming6-1/"},{"categories":["jpa"],"content":"6.1.2 다대일 양방향 [N:1, 1:N] @Entity public class Member { @Id @GeneratedValue @Column(name = \"MEMBER_ID\") private Long id; private String username; // 연관관계 매핑 @ManyToOne @JoinColumn(name = \"TEAM_ID\") private Team team; // 연관관계 설정 public void setTeam(Team team) { this.team = team; // 무한 루프에 빠지지 않도록 체크 if (!team.getMembers().contains(this)) { team.getMembers().add(this); } } // Getter, Setter... } Team.java @Entity public class Team { @Id @GeneratedValue @Column(name = \"TEAM_ID\") private String id; private String name; @OneToMany(mappedBy = \"team\") private List\u003cMember\u003e members = new ArrayList\u003cMember\u003e(); public void addMember(Member member) { this.members.add(member); if (member.getTeam() != this) { member.setTeam(this); } } } 양방향은 외래 키가 있는 쪽이 연관관계의 주인 양방향 연관관계를 항상 서로를 참조해야 한다. 항상 서로를 참조하게 하려면 연관관계 편의 메소드를 작성하는 것이 좋다. (양쪽에 다 작성할 경우 무한루프에 빠지므로 주의. 또한 양쪽에 다 작성한 경우 둘 중 하나만 호출해도 된다.) ","date":"2019-01-10","objectID":"/archives/dbms/jpa/jpa-programming6-1/:2:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/archives/dbms/jpa/jpa-programming6-1/"},{"categories":["jpa"],"content":"김영한님의 책 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:0:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.3 양방향 연관관계 일대다 관계에서는 여러 건과 연관관계를 맺을 수 있으므로 컬렉션(Collection, Set, Map, List ..) 을 사용한다. ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:1:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.3.1 양방향 연관관계 매핑 Member.java 회원 엔티티에는 변경할 사항이 없다. @Entity public class Member { @Id @Column(name = \"MEMBER_ID\") private String id; private String username; // 연관관계 매핑 @ManyToOne @JoinColumn(name = \"TEAM_ID\") private Team team; // 연관관계 설정 public void setTeam(Team team) { this.team = team; } // Getter, Setter... } Team.java @Entity public class Team { @Id @Column(name = \"TEAM_ID\") private String id; private String name; @OneToMany (mappedBy = \"team\") private List\u003cMember\u003e members = new ArrayList\u003cMember\u003e(); // Getter, Setter ... } 팀과 회원은 1:N 이며 해당 다중성을 매핑하기 위하여 @OneToMany 매핑 정보를 사용한다. 또한 mappedBy 속성은 양방향 매핑일 때 사용하며, 반대쪽 매핑되는 필드의 이름을 값으로 설정하면 된다. ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:1:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.3.2 일대다 컬렉션 조회 public static void biDirection(EntityManager em) { Team team = em.find(Team.class, \"team1\"); List\u003cMember\u003e members = team.getMembers(); // 팀 -\u003e 회원 방향으로 객체 그래프를 탐색한다. for (Member member : members) { System.out.println(\"member.username : \" + member.getUsername()); } } ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:1:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.4 연관관계 주인 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리하지만, 객체의 경우 엔티티를 양방향으로 매핑하기 위해서는 객체의 참조를 통해서 서로 참조해야만 한다. (ex 회원-\u003e팀, 팀-\u003e회원) 엔티티를 양방향 연관관계로 설정하면 객체 참조는 둘인데 외래키는 하나이므로 둘 사이에 차이가 발생 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데 이것을 연관관계의 주인 이라고 한다. ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:2:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.4.1 양방향 매핑의 규칙 : 연관관계의 주인 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록, 수정, 삭제) 할 수 있다. 주인이 아닌 쪽은 읽기만 가능하다. 주인은 mappedBy 속성을 사용하지 않는다. 연관관계의 주인을 정한다는 것 -\u003e 외래키 관리자를 선택하는 것 ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:2:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.4.2 연관관계의 주인은 외래 키가 있는 곳 연관관계의 주인만 데이터베이스 연관관계와 매핑되며, 외래키를 관리할 수 있다. 주인이 아닌 반대편 (inverse, non-owning side) 은 읽기만 가능 외래키를 변경하지는 못한다. N:1, 1:N 에서는 항상 N 쪽이 외래 키를 갖는다. @ManyToOne 은 항상 연관관계의 주인이 되므로, mappedBy 속성이 존재하지 않는다. ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:2:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.6 양방향 연관관계의 주의점 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌곳에만 입력하는 실수를 유의해야 한다. public static void testSave(EntityManager em) { // 회원1 저장 Member member1 = new Member(\"member1\", \"회원1\"); em.persist(member1); // 회원2 저장 Member member2 = new Member(\"member2\", \"회원2\"); em.persist(member2); // 팀1 저장 Team team1 = new Team(\"team1\", \"팀1\"); // 주인이 아닌곳에 연관관계 설정 team1.getMembers().add(member1); team1.getMembers().add(member2); em.persist(team1); } 예제코드에서 Member 가 연관관계의 주인인데 Member.team 의 연관관계에 대해서 설정하지 않았다. 따라서 TEAM_ID 외래키의 값도 null 이 저장된다. ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:3:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.6.1 순수한 객체까지 고려한 양방향 연관관계 객체 관점에서 양쪽 방향에 참조 값을 입력해 주는 것이 가장 안전하다. Member.team : 연관관계의 주인. 이 값으로 외래키를 관리 Team.members : 연관관계 주인 아님. 따라서 저장시에는 사용되지 않음. 결론 : 객체의 양방향 연관관계는 양쪽 모두 관계를 맺어주자. // 양방향 연관관계 사용하여 저장 public static void testORM_양방향(EntityManager em) { Team team2 = new Team(\"team2\", \"팀2\"); em.persist(team2); Member member3 = new Member(\"member3\", \"회원3\"); member3.setTeam(team2); team2.getMembers().add(member3); // 연관관계 설정 member1 -\u003e team2 em.persist(member3); // 연관관계 설정 team2 -\u003e member1 Member member4 = new Member(\"member4\", \"회원4\"); member4.setTeam(team2); // 연관관계 설정 member4 -\u003e team2 team2.getMembers().add(member4); // 연관관계 설정 team2 -\u003e member4 em.persist(member4); } ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:3:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.6.2 연관관계 편의 메소드 양방향 연관관계는 양쪽 다 신경 써야 한다. 그러나 각각 호출하다보면 실수로 둘 중 하나만 호출해서 양방향이 깨질 수 있다. setTeam() 메소드 하나로 양방향 모두를 설정하도록 변경한다. 한 번에 양항뱡 관계를 설정하는 메소드를 연관관계 편의 메소드라고 한다. // Member.java 의 setTema() 메소드 수정 public void setTeamNew(Team team) { this.team = team; team.getMembers().add(this); } public static void testORM_양방향_리펙토링(EntityManager em) { Team team3 = new Team(\"team3\", \"팀3\"); em.persist(team3); Member member5 = new Member(\"member5\", \"회원5\"); member5.setTeam(team3); em.persist(member5); Member member6 = new Member(\"member6\", \"회원6\"); member6.setTeam(team3); em.persist(member6); } ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:3:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.6.3 연관관계 편의 메소드 작성 시 주의 사항 연관관계를 변경할 경우 기존 연관관계를 삭제하는 코드를 추가해야 한다. 객체에서 양방향 연관관계를 사용하려면 로직을 견고하게 작성해야 한다. // 연관관계 편의 메소드 public void setTeam(Team team) { // 기존 팀과 관계를 제거 if(this.team != null) { this.team.getMembers().remove(this); } this.team = team; team.getMembers().add(this); } ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:3:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"5.7 정리 단방향 매핑과 비교했을때 양방향 매핑은 복잡하고, 연관관계의 주인도 정해야하고 단방향 연관관계를 양방향으로 만들기 위해 로직도 잘 관리해야한다. 양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가 된것 뿐이다. 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야한다. ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:4:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"연관관계의 주인을 정하는 기준 비즈니스 로직의 중요도가 크다고 해서 무조건 연관관계의 주인이 되는 것은 아니다. 비즈니스 중요도를 배제하고 단순히 외래 키 관리자 정도의 의미만 부여해야 한다. 연관관계의 주인은 외래키의 위치와 관련해서 정해야 한다. ","date":"2018-12-30","objectID":"/archives/dbms/jpa/jpa-programming5-2/:5:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-2/"},{"categories":["jpa"],"content":"김영한님의 책 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 단방향 연관관계 객체는 참조(주소) 를 사용해서 관계를 맺고, 테이블을 외래 키를 사용해서 관계를 맺는다. 방향(Direction) : 단방향과 양방향이 있으며 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향 이다. 다중성(Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다 (N:N) 연관관계 주인 (owner) : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다. ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:0:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.1 단방향 연관관계 ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"객체 연관관계 회원 객체와 팀 객체는 단방향 관계 다. 회원은 Member.team 필드를 통해서 팀을 알 수 있지만 반대로 팀은 회원을 알 수 없다. ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"테이블 연관관계 회원 테이블과 팀 테이블은 양방향 관계 다. 회원 테이블의 TEAM_ID 외래키를 통해 회원팀과 조인 할 수 있고 반대로 팀과 회원도 조인할 수 있다. SELECT * FROM MEMBER M JOIN TEAM T ON M.TEAM_ID = T.ID; SELECT * FROM TEAM T JOIN MEMBER M ON T.ID = M.TEAM_ID; ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"정리 참조를 사용하는 객체의 연관관계는 단방향이다. A -\u003e B (a.b) 외래키를 사용하는 테이블의 연관관계는 양방향이다. A JOIN B 도 가능 하고 B JOIN A 도 가능하다. 객체를 양항뱡으로 참조하려면 단방향 연관관계를 2개 만들어야 한다. A-\u003eB (a.b) B-\u003eA (b.a) ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.1.1 순수한 객체 연관관계 객체그래프 : 객체는 참조를 사용해서 연관관계를 탐색할 수 있다. // 객체그래프 탐색 동작코드 public static void main(String[] args) { Member member1 = new Member (\"member1\", \"회원1\"); Member member2 = new Member (\"member2\", \"회원2\"); Team team1 = new Team (\"team1\", \"팀1\"); member1.setTeam(team1); member2.setTeam(team1); // 참조를 사용하여 연관관계를 탐색한다. Team findTeam = member1.getTeam(); } ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.1.2 테이블 연관관계 조인 : 데이터베이스는 외래 키를 사용해서 연관관계를 탐색할 수 있다. ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:5","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"테이블 생성 -- MEMBER CREATE TABLE MEMBER ( MEMBER_ID VARCHAR(255) NOT NULL, TEAM_ID VARCHAR(255), USERNAME VARCHAR(255), PRIMARY KEY (MEMBER_ID) ); -- TEAM CREATE TABLE TEAM( TEAM_ID VARCHAR(255) NOT NULL, NAME VARCHAR(255), PRIMARY KEY (TEAM_ID) ); ALTER TABLE MEMBER ADD CONSTRAINT FK_MEMBER_TEAM FOREIGN KEY (TEAM_ID) REFERENCES TEAM ; SQL 을 통하여 연관관계를 정의하기 INSERT INTO TEAM (TEAM_ID, NAME) VALUES ('team1', '팀1'); INSERT INTO MEMBER (MEMBER_ID, TEAM_ID, USERNAME) VALUSE ('member1', 'team1', '회원1'); INSERT INTO MEMBER (MEMBER_ID, TEAM_ID, USERNAME) VALUSE ('member2', 'team1', '회원2'); ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:6","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.1.3 JPA 로 객체 관계매핑 Member.java @Entity public class Member { @Id @Column(name = \"MEMBER_ID\") private String id; private String username; // 연관관계 매핑 @ManyToOne @JoinColumn(name = \"TEAM_ID\") private Team team; // 연관관계 설정 public void setTeam(Team team) { this.team = team; } // Getter, Setter... } Team.java @Entity public class Team { @Id @Column(name = \"TEAM_ID\") private String id; private String name; // Getter, Setter ... } @ManyToOne : 다대일(N:1) 관계 매핑 정보를 나타낸다. 회원객체를 기준으로 팀객체와는 다대일 관계. @JoinColumn(name = \"TEAM_ID\") : 조인 컬럼은 외래키를 매핑할 때 사용. ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:7","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.1.4 @JoinColumn 속성 기능 기본값 name 매핑할 외래 키 이름 필드명 + _ + 참조하는 테이블의 기본키 컬럼명 referencedColumnName 외래 키가 참조하는 대상 테이블의 컬럼명 참조하는 테이블의 키 컬럼명 foreignKey(DDL) 테이블 생성시 사용. 외래키를 직접 지정 가능 unique, nullable, inserable, updateable, columnDefinition, table @Column 속성과 동일 ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:8","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.1.5 @ ManyToOne 속성 기능 기본값 optional false 로 설정시 연관된 엔티티가 항상 있어야 한다. true fetch 글로벌 페치 전략 @ManytoOne = FetchType.EAGER, @OneToMany=FetchType.LAZY cascade 영속성 전이 기능 사용 targetEntity 연관된 엔티티 타입 정보를 설정. (이 기능은 거의 사용 안함) @OneToMany private List\u003cMember\u003e members; // 제네릭타입으로 정보를 알 수 있다. ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:1:9","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.2 연관관계 사용 ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:2:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.2.1 저장 public static void testSave(EntityManager em) { // 팀1 저장 Team team1 = new Team(\"team1\", \"팀1\"); em.persist(team1); // 회원1 저장 Member member1 = new Member(\"member1\", \"회원1\"); member1.setTeam(team1); // 연관관계 설정 member1 -\u003e team1 em.persist(member1); // 회원2 저장 Member member2 = new Member(\"member2\", \"회원2\"); member2.setTeam(team1); em.persist(member2); } JPA 는 참조한 팀의 식별자 (Team.id) 를 외래 키로 사용해서 적절한 등록 쿼리를 생성 ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:2:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.2.2 조회 연관관계가 있는 엔티티를 조회하는 방법 객체 그래프 탐색 (객체 연관관계를 사용한 조회) 객체 지향 쿼리 사용 (JPQL) 객체그래프 탐색 member.getTeam() 을 사용하여 Member 와 연관된 Team 객체를 조회할 수 있다. Member member = em.find(Member.class, \"member1\"); Team team = member.getTeam(); // 객체 그래프 탐색 객체지향 쿼리 사용 public static void queryLogicJoin(EntityManager em) { String jpql = \" SELECT m from Member m JOIN m.team t WHERE t.name = :teamName\"; List\u003cMember\u003e resultList = em.createQuery(jpql, Member.class) .setParameter(\"teamName\", \"팀1\") .getResultList(); for (Member member : resultList) { System.out.println(\"[query] member.username = \" + member.getUsername()); } } ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:2:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.2.3 수정 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다. 이것은 연관관계를 수정할 때도 동일하며, 참조하는 대상만 변경하면 나머지는 JPA 에서 자동으로 처리한다. public static void updateRelation(EntityManager em) { // 새로운 팀 Team team2 = new Team(\"team2\", \"팀2\"); em.persist(team2); // 회원1 을 팀2로 설정한다. Member member = em.find(Member.class, \"member1\"); member.setTeam(team2); // 플러시 발생시 자동으로 업데이트 } ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:2:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.2.4 연관관계 제거 private static void deleteRelation(EntityManager em) { Member member1 = em.find(Member.class, \"member1\"); member1.setTeam(null); } ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:2:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"5.2.5 연관된 엔티티 삭제 연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다. member1.setTeam(null); // 회원1 연관관계 제거 member2.setTeam(null); // 회원2 연관관계 제거 em.remove(team); // 팀 삭제 ","date":"2018-12-26","objectID":"/archives/dbms/jpa/jpa-programming5-1/:2:5","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/archives/dbms/jpa/jpa-programming5-1/"},{"categories":["jpa"],"content":"김영한님의 책 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:0:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"JPA 의 매핑 어노테이션 객체와 테이블 매핑 : @Entity, @Table 기본 키 매핑 : @Id 필드와 컬럼 매핑 : @Column 연관관계 매핑 : @ManyToOne, @JoinColumn ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:1:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.1 @Entity 테이블을 매핑할때 @Entity 어노테이션을 필수로 붙어야 한다. 속성 기능 기본값 name JPA 에서 사용할 엔티티 이름을 지정한다. 보통 기본값인 클래스 이름을 사용한다. 설정하지 않으면 클래스 이름을 그대로 사용. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:2:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"@Entity 적용시 주의할 점 매개변수가 없는 기본 생성자는 필수. final, enum, interface, inner 클래스에는 사용할 수 없다. 저장할 필드에 final 을 사용하면 안된다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:2:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.2 @Table @Table 은 엔티티와 매핑할 테이블을 지정한다. 속성 기능 기본값 name 매핑할 테이블 이름 엔티티 이름을 사용. catalog catalog 기능이 있는 데이터베이스에서 catalog 를 매핑 schema shcema 기능이 있는 데이터베이스에서 schema 를 매핑 uniqueConstrains(DDL) DDL 생성 시 유니크 제약조건을 만든다. 2개 이상의 복합 유니크 제약조건도 만들 수 있다. 이 기능은 스키마 자동생성 기능을 사용해서 DDL 를 만들때만 사용 ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:3:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.3 다양한 매핑 사용 ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:4:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.4 데이터베이스 스키마 자동생성 JPA 는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원 스키마 자동생성 기능을 사용하려면 persistence.xml 에 다음 속성을 추가해야 한다. \u003cproperty name=\"hibernate.hbm2ddl.auto\" value=\"create\" /\u003e 위 속성을 추가하면 애플리케이션 실행 시점에 데이터베이스 테이블을 자동으로 생성. 자동으로 생성되는 DDL 은 지정한 데이터베이스 방언에 따라 달라진다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:5:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"장점 개발자가 테이블을 직접 생성하는 수고를 덜 수 있다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:5:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"주의사항 운영 서버에서 create, create-drop, update 처럼 DDL 을 수정하는 옵션은 절대 사용하면 안됨. [표] hibernate.hbm2ddl.auto 속성 옵션 기능 create 기존 테이블을 삭제하고 새로 생성. (DROP + CREATE) create-drop create 속성에 추가로 어블리케이션을 종료할때 생성한 DDL 제거 update 데이터베이스를 테이블과 엔티티 매핑정보를 비교해서 변경 사항만 수정 validate 데이터베이스 테이블과 엔티티 매핑정보를 비교. 차이가 있으면 경고를 남기고 어플리케이션을 실행하지 않음. 이 설정은 DDL 을 수정하지 않는다. none 자동생성 기능을 사용하지 않음. (none 은 사실 유요하지 않은 옵션 값) ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:5:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"개발 환경에 따른 추천 전략 개발 초기 단계는 create 또는 update 초기화 상태로 자동화된 테스트 진행시 개발자 환경과 CI 서버는 create 또는 create-drop 테스트 서버는 update 또는 validate 스테이징과 운영 서버는 validate 또는 none ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:5:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"이름 매핑 전략 변경하기 단어와 단어를 구분시 자바 언어는 관례상 카멜(Camel) 표기법을 사용하고 데이터베이스는 언더스코어(_) 를 주로 사용하기 때문에 엔티티를 매핑하려면 @Column.name 속성을 명시해야 함. hiberante.ejb.naming_strategy 속성을 사용하면 이름 매핑 전략을 변경 할 수 있다. 하이버네이트에서는 org.hibernate.cfg.ImprovedNamingStrategy 클래스를 제공. 위 클래스는 테이블 명이나 컬럼 명이 생략되면 자바의 카멜 표기법을 테이블의 언더스코어 표기법으로 매핑. \u003cproperty name=\"hibernate.ejb.naming_strategy\" value=\"org.hibernate.cfg.ImprovedNamingStrategy\"/\u003e ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:5:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.5 DDL 생성 기능 @Column 매핑정보에 nullable 속성 값을 false 로 지정하여 NOT NULL 제약 조건 추가. length 를 지정하면 문자의 크기를 지정할 수 있다. // Member.java 추가 @Column(name = \"NAME\", nullable = false, length = 10) private String username; ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:6:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"유니크 제약조건 @Table 에 uniqueConstraints 속성을 지정. // Member.java @Entity @Table(name = \"MEMBER\", uniqueConstraints = { @UniqueConstraint (name = \"NAME_AGE_UNIQUE\", columnNames = {\"NAME\", \"AGE\"}) }) public class Member {...} DDL 을 자동생성할 때만 사용하고 JPA 의 실행 로직에는 영향을 주지 않는다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:6:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.6 기본키 매핑 데이터베이스마다 기본키를 생성하는 방식이 다르기때문에 JPA 에서는 기본 키 생성전략을 제공한다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"JPA 에서 제공하는 데이터베이스 기본 키 생성 전략 직접할당 : 기본 키를 애플리케이션에 직접 입력 자동생성 : 대리 키 사용 방식 IDENTITY : 기본 키 생성을 데이터베이스에 위임 SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본키 할당 TABLE : 키 생성 테이블 사용. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"주의사항 키 생성 전략을 사용하려면 persistence.xml 에 hibernate.id.new_generator_mapping=true 속성을 반드시 추가 해야 한다. 기존 하이버네이트 시스템을 유지보수 하는 것이 아니라면 반드시 true 로 설정할것. true 로 설정하면 키 생성을 최적화하는 allocationSize 속성을 사용하는 방식이 달라진다. persistence.xml \u003cproperty name=\"hibernate.id.new_generator_mappings\" value=\"true\" /\u003e \u003c!-- 키 생성 최적화 전략 --\u003e ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.6.1 기본 키 직접 할당 전략 기본키를 직접 할당하려면 @Id 로 매핑하면 된다. @Id 의 적용 가능 자바 타입 자바 기본형 자바 Wrapper 형 String java.util.Date java.sql.Date java.math.BigDecimal java.math.BigInteger // 기본키직접할당 Board board = new Board(); board.setId(\"id\"); em.persistence(board); ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.6.2 IDENTITY 전략 IDENTITY 전략은 기본 키 생성을 데이터베이스에 위임하는 전략이다. 주로 Mysql, PostgreSQL, SQL Server, DB2 에서 사용한다. Mysql 의 AUTO_INCREMENT 기능 @Entity public class Board { @Id @GeneratedValue(starategy = GenerationType.IDENTITY) private Long id; } @GeneratedValue 어노테이션을 사용하고 식별자 생성 전략을 명시한다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"참고 IDENTIY 전략은 데이터베이스에 INSERT 후에 기본 키 값을 조회할 수 있다. JDBC3 의 Statement.getGeneratedKeys() 를 사용하면 데이터를 저장하면서 동시에 생성된 키 값도 얻어 올 수 있다. 엔티티가 영속상태가 되려면 반드시 식별자가 필요한데, IDENTITY 전략의 경우 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:5","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.6.3 SEQUENCE 전략 데이터베이스의 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터 베이스 오브젝트이다. -- SEQUENCE DDL CREATE TABLE BOARD ( ID BIGINT NOT NULL PRIMARY KEY, DATE VARCHAR(255) ) -- 시퀀스 생성 CREATE SEQUENCE BOARD_SEQ START WITH 1 INCREMENT BY 1; SEQUENCE 전략은 em.persist() 를 호출할 때 먼저 데이터베이스 시퀀스를 사용해 식별자를 조회한다. 조회한 식별자를 엔티티에 할당한 후 엔티티를 영속성 컨텍스트에 저장 트랜잭션 커밋해서 플러시가 일어나면 엔티티를 데이터베이스에 저장 ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:6","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"@SequenceGenerator 속성 기능 기본값 name 식별자 생성기 이름 필수 sequenceName 데이터베이스에 등록되어 있는 시퀀스 이름 hibernate_sequence initialValue DDL 생성 시에만 사용. 시퀀스 DDL 을 생성할 때 처음 시작하는 수를 지정 1 allocationSize 시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용) 50 catalog, schema 데이터베이스 catalog, schema 이름 ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:7","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"SequenceGenerator.allocationSize SequenceGenerator.allocationSize 기본값이 50 이다. JPA 는 시퀀스에 접근하는 횟수를 줄이기 위해 allocationSize 사용한다. 여기에서 설정한 값만큼 한 번에 시퀀스 값을 증가시키고 나서 그만큼 메모리에 시퀀스 값을 할당한다. 이방법은 시퀀스 값을 선점하므로 JVM 이 동시에 접근해서 데이터를 등록시 시퀀스 값이 한번에 증가하는 점을 염두. INSERT 성능이 중요하지 않거나 시퀀스가 많이 증가하는 게 부담될 경우 allocationSize 를 1로 설정한다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:8","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.6.4 TABLE 전략 TABLE 전략은 키 생성 전용 테이블을 하나 만들고 이름과 값으로 사용할 컬럼을 만들어 데이터 시퀀스처럼 사용하는 전략이다. 이 전략은 모든 데이터베이스에 적용이 가능하다. -- TABLE 전략 시퀀스 테이블 DDL create table MY_SEQUENCES ( sequence_name varchar(255) not null, next_val bigint, primary key (sequence_name) ) ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:9","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"@TableGenerator 속성 기능 기본값 name 식별자 생성기 이름 필수 table 키생성 테이블명 hibernate_sequence pkColumnName 시퀀스 컬럼명 sequence_name valueColumnName 시퀀스 값 컬럼명 next_val initialValue 초기 값, 마지막으로 생성된 값이 기준이다 0 allocationSize 시퀀스 한 번 호출에 증가하는 수 (성능최적화 이용) 50 catalog, schema 데이터베이스 catalog, schema 이름 uniqueConstrains(DDL) 유니크 제약 조건을 지정할 수 있다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:10","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.6.5 AUTO 전략 GenerationType.AUTO 는 선택한 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택. AUTO 는 데이터베이스를 변경해도 코드를 수정할 필요가 없는 장점이 있다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:11","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.6.6 기본 키 매핑 정리 영속성 컨텍스트는 엔티티를 식별자 값으로 구분하므로 반드시 식별자 값이 있어야 한다. 권장하는 식별자 전략 null 값은 허용하지 않는다. 유일해야 한다. 변해서는 안된다. 테이블의 기본 키를 선택하는 전략은 크게 2 가지가 있다. 자연키 (natural key) : 비즈니스에 의미가 있는 키. ex) 주민등록번호, 이메일, 전화번호 대리키 (surrogate key) : 비즈니스와 관련없는 임의로 만들어진 키. ex) 오라클 시퀀스, auto_increment, 키생성 테이블 자연키보다는 대리 키를 권장한다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:7:12","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.7 필드와 컬럼 매핑 : 레퍼런스 ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:8:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.7.1 @Column @Column 은 객체 필드를 테이블 컬럼에 매핑한다. 자바 기본 타입에 @Column 을 사용하면, nullable=false 로 지정하는 것이 안전하다. 속성 기능 기본값 name 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름 nullable(DDL) null 값의 허용 여부 설정. false 로 설정시 not null 제약조건 true unique(DDL) 한 컬럼에 간단한 유니크 제약조건을 걸 때 사용 columnDefinition(DDL) 데이터베이스 컬럼 정보를 직접 줄 수 있다. length(DDL) 문자 길이 제약조건, String 타입에만 사용 255 precision, scale(DDL) BigDecimal/BigInteger 타입에서 사용. precision 은 소수점을 포함한 전체 자리수, scale 은 소수의 자리수 precision = 19, scale = 2 ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:8:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.7.2 @Enumerated 자바의 enum 타입을 매핑할 때 사용한다. EnumType.ORDINAL : enum 에 정의된 순서대로 데이터베이스에 저장된다. 장점 : 저장되는 데이터 크기가 작다. 단점 : 이미 저장된 enum 순서를 변경할 수 없다. EnumType.STRING : enum 이름을 데이터베이스에 저장. (권장) 장점 : 저장된 enum 순서가 바뀌거나 enum이 추가되어도 안전 단점 : 데이터베이스에 저장되는 크기가 ORINAL 에 비해 크다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:8:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.7.3 @Temporal 날짜 타입 (java.util.Date, java.util.Calendar) 을 매핑할 때 사용. TemporalType.DATE, TemporalType.TIME, TemporalType.TIMESTAMP ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:8:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.7.4 @Lob 데이터베이스의 BLOB, CLOB 타입과 매핑된다. @Lob 에는 속성을 지정할 수 없으므로, 매핑하는 필드 타입이 문자면 CLOB, 나머지는 BLOB 으로 매핑한다. @Lob private String lobString; // CLOB @Lob private byte[] lobByte; // BLOB CLOB : String, char[], java.sql.CLOB BLOB : byte[], java.sql.BLOB ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:8:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.7.5 @Transient 데이터베이스에 저장하지도 조회하지도 않는다. 객체에 어떤 값을 임시로 보관하고 싶을 때 사용한다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:8:5","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"4.7.6 @Access JPA 가 엔티티 데이터에 접근하는 방식을 지정 필드접근 : AccessType.FIELD 로 지정한다. 필드에 직접 접근하며, 필드 접근 권한이 private 이어도 접근 가능하다. 프로퍼티 접근 : AccessType.PROPERTY 로 지정. 접근자를 사용한다. ","date":"2018-12-23","objectID":"/archives/dbms/jpa/jpa-programming4/:8:6","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/archives/dbms/jpa/jpa-programming4/"},{"categories":["jpa"],"content":"김영한님의 책 자바 ORaM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-18","objectID":"/archives/dbms/jpa/jpa-programming3-2/:0:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/archives/dbms/jpa/jpa-programming3-2/"},{"categories":["jpa"],"content":"3.5 플러시 플러시(flush()) 는 영속성 컨텍스트의 내용을 데이터베이스에 반영한다. 영속성 컨텍스트의 변경 내용을 데이터베이스와 동기화 하는 것이 플러시이다. 플러시를 실행하면 변경 감지가 동작하여 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. =\u003e 수전된 엔티티는 수정 쿼리를 만들어 쓰기지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다. 플러시 방법 em.flush() 로 직접 호출. 트랜잭션 커밋 시 플러시 자동 호출 JPA 는 트랜잭션을 커밋할 때 플러시를 자동으로 호출한다. JPQL 쿼리 실행시 플러시 자동 호출 JPQL 이나 Criteria 같은 객체 지향 쿼리를 통하여 실행할때 플러시를 자동으로 호출한다. 식별자를 기준으로 조회하는 find() 메소드를 호출할 때는 플러시가 실행되지 않는다. // JPQL 시 자동 플러시 em.persist(memberA); em.persist(memberB); em.persist(memberC); // 중간에 JPQL 실행 // 조회시 memberA, memberB, memberC 도 쿼리결과에 포함된다. query = em.createQuery(\" SELECT m FROM Member m \", Member.class); List\u003cMember\u003e members = query.getResultList(); ","date":"2018-12-18","objectID":"/archives/dbms/jpa/jpa-programming3-2/:1:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/archives/dbms/jpa/jpa-programming3-2/"},{"categories":["jpa"],"content":"3.5.1 플러시 모드 옵션 javax.persistence.FlushModeType 사용 FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시값 (별도로 지정하지않으면 기본값) FlushModeType.COMMIT : 커밋할때만 플러시 em.setFlushMode(FlushModeType.COMMIT); // 플러시모드 직접 설정 ","date":"2018-12-18","objectID":"/archives/dbms/jpa/jpa-programming3-2/:1:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/archives/dbms/jpa/jpa-programming3-2/"},{"categories":["jpa"],"content":"3.6 준영속 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 된 것을 준영속 상태라고 한다. 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다. 개발자가 직접 준영속 상태로 만드는 일은 드물다. 준영속 상태를 만드는방법 em.detach(엔티티) : 특정 엔티티만 준영속 상태로 전환 em.clear() : 영속성 컨텍스트를 완전히 초기화 em.close() : 영속성 컨텍스트를 종료 ","date":"2018-12-18","objectID":"/archives/dbms/jpa/jpa-programming3-2/:2:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/archives/dbms/jpa/jpa-programming3-2/"},{"categories":["jpa"],"content":"3.6.1 엔티티를 준영속 상태로 전환 : detach() 1차 캐시부터 쓰기 지연 SQL 저장소 까지 해당 엔티티를 관리하기 위한 모든 정보가 제거 ","date":"2018-12-18","objectID":"/archives/dbms/jpa/jpa-programming3-2/:2:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/archives/dbms/jpa/jpa-programming3-2/"},{"categories":["jpa"],"content":"3.6.2 영속성 컨텍스트 초기화 : clear() 영속성 컨텍스트의 모든 것이 초기화 되버린다. 영속성 컨텍스트를 제거하고 새로 만든 것과 같다. ","date":"2018-12-18","objectID":"/archives/dbms/jpa/jpa-programming3-2/:2:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/archives/dbms/jpa/jpa-programming3-2/"},{"categories":["jpa"],"content":"3.6.3 영속성 컨텍스트 종료 : clese() 영속성 컨텍스트가 종료되었다. ","date":"2018-12-18","objectID":"/archives/dbms/jpa/jpa-programming3-2/:2:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/archives/dbms/jpa/jpa-programming3-2/"},{"categories":["jpa"],"content":"3.6.4 준영속 상태의 특징 거의 비영속 상태에 가깝다. : 1차캐시, 쓰기지연, 변경감지, 지연로딩을 포함한 영속성 컨텍스트의 기능이 동작하지 않는다. 식별자 값을 가지고 있다. : 준영속 상태에서는 이미 한 번 영속 상태였으므로 식별자 값을 가지고 있다. 지연 로딩을 할 수 없다. ","date":"2018-12-18","objectID":"/archives/dbms/jpa/jpa-programming3-2/:2:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/archives/dbms/jpa/jpa-programming3-2/"},{"categories":["jpa"],"content":"3.6.5 병합 : merge() 준영속 상태의 엔티티를 다시 영속 상태로 변경 할 때 사용한다. 병합은 파라미터로 넘어온 엔티티의 식별자 값으로 영속성 컨텍스트를 조회하고 찾는 엔티티가 없으면 데이터베이스를 조회하며, 데이터베이스에도 조회하지 못하면 새로운 엔티티를 생성해 병합한다. 병합은 준영속, 비영속을 신경 쓰지 않는다. 병합은 save or update 의 기능을 수행한다. 준영속 병합 비영속 병합 병합은 비영속 엔티티도 영속상태로 만들 수 있다. Member member = new Member(); Member newMember = em.merge(member); tx.commit(); [이미지 출처] http://ptgmedia.pearsoncmg.com/images/chap8_9780131587564/elementLinks/08fig01.jpg ","date":"2018-12-18","objectID":"/archives/dbms/jpa/jpa-programming3-2/:2:5","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/archives/dbms/jpa/jpa-programming3-2/"},{"categories":["jpa"],"content":"김영한님의 책 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:0:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"JPA 가 제공하는 기능 엔티티와 테이블을 매핑하는 설계 부분 매핑하는 엔티티를 실제 사용하는 부분 ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:1:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"3.1 엔티티 매니저 팩토리와 엔티티 매니저 ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:2:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"EntityManagerFactory EntityManagerFactory 는 이름 그대로 EntityManager 를 만드는 공장이다. 공장을 만드는 비용은 상당히 크다. 그러므로 한 개만 만들어서 애플리케이션 전체에 공유하도록 설계해야 한다. EntityManagerFactory 는 여러 스레드에서 동시에 접근해도 안전하므로 서로 다른 스레드간 공유해도 된다. JPA 구현체들은 EntityManagerFactory 생성시 커넥션 풀을 만든다. // MET-INF/persistence.xml 의 정보를 바탕으로 생성한다. EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"jpabook\"); ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:2:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"EnitityManager EntityManager 의 경우 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간 절대 공유해서는 안된다. 엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. (ex. 트랜잭션을 시작할 때 커넥션을 획득한다.) // 공장에서 엔티티 매니저 생성, 비용이 거의 들지 않는다. EntityManager em = emf.createEntityManager(); ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:2:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"3.2 영속성 컨텍스트 영속성 컨텍스트 (persistence context) 는 엔티티를 영구 저장하는 환경 이다. 영속성 컨텍스트는 엔티티를 조회, 보관 등 관리하는 곳으로 눈에 보이지 않는 논리적인 개념이다. 엔티티 매니저를 생성할 때 하나 만들어지며 엔티티 매니저를 통해 영속성 컨텍스트에 접근 및 관리 할 수 있다. // 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다. em.persist(member); 여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근 할 수도 있다. ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:3:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"3.3 엔티티의 생명주기 ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:4:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"엔티티의 4가지 상태 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태 영속 (managed) : 영속성 컨텍스트에 저장된 상태 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제 (removed) : 삭제된 상태 [그림] 엔티티 생명주기 ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:4:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"비영속 비영속 상태는 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다. // 객체를 생성한 상태(비영속) Member member = new Member(); member.setId(\"memberId\"); member.setUsername(\"홍길동\"); ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:4:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"영속 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태. 영속성 컨텍스트가 관리하는 엔티티를 영속 상태 라 한다. em.find() 나 JPQL 을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태다. // 객체를 저장한 상태(영속) em.persist(member); ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:4:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"준영속 영속성 컨텍스트가 관리하던 영속상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다. 준영속 상태로 만들려면 em.detach() 나 em.close() 를 호출하여 영속성 컨텍스트를 닫거나 또는 em.clear() 영속성 컨텍스트를 초기화 하는 방법이 할때 준영속 상태가 된다. // 회원 엔티티를 영속성 컨텍스트에서 분리 (준영속 상태) em.detach(member); ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:4:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"삭제 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다. // 객체를 삭제한 상태(삭제) em.remove(member); ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:4:5","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"3.4 영속성 컨텍스트의 특징 영속성 컨텍스트와 식별자 값 영속상태는 식별자 값이 반드시 있어야 한다. 영속성 컨텍스트는 엔티티를 식별자 값(@Id 로 테이블의 기본키와 매핑한 값) 으로 구분한다. 영속성 컨텍스트와 데이터 베이스 저장 JPA 는 보통 트랜잭션을 commit 하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터 베이스에 반영한다. 이것을 플러시(flush) 라고 한다. 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다. 1차 캐시 동일성 보장 트랜잭션을 지원하는 쓰기 지연 변경 감지 지연 로딩 ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:5:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"3.4.1 엔티티 조회 영속성 컨텍스트는 내부에 캐시를 가지고 있으며 이것을 1차 캐시라고 한다. 영속 상태의 엔티티는 모두 이곳에 저장된다. 영속성 컨텍스트 내부에 Map 이 하나 있는데 키는 @Id 로 매핑한 식별자고 값은 엔티티 인스턴스 이다. 1차 캐시의 키는 식별자 값이며 기본적으로 데이터베이스의 기본키와 매핑되어 있다. 영속성 컨텍스트 1차 캐시 회원 엔티티는 아직 데이터베이스에 저장되지 않았다. // 엔티티를 생성한 상태 (비영속) Member member = new Member(); member.setId(\"member1\"); member.setUserName(\"회원\"); em.persist(member); // 엔티티를 영속 1차 캐시에서 조회 em.find() 를 호출하면 우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다. Member findMember = em.find(Member.class, \"member1\"); 데이터베이스에서 조회 // 1차 캐시에 없는 member2 인스턴스를 조회 Member findMember2 = em.find(Member.class, \"member2\"); 만약 em.find() 를 호출했는데 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터 베이스를 조회하여 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후 반환한다. em.find(Member.class, \"member2\") 를 실행 member2 가 1차 캐시에 없으므로 데이터베이스에서 조회 조회한 데이터로 member2 엔티티를 생성하여 1차 캐시에 저장 (영속상태) 조회한 엔티티 인스턴스를 반환 영속성 엔티티의 동일성 보장 Member a = em.find(Member.class, \"member1\"); Member b = em.find(Member.class, \"member1\"); // 결과값은 true. System.out.println(a == b); em.find(Member.class, \"member1\") 를 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다. ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:5:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"3.4.2 엔티티 등록 // 엔티티 매니저 생성 EntityManager em = emf.createEntityManager(); // 트랜잭션 기능 획득 EntityTransaction transaction = em.getTransaction(); transaction.begin(); // 트랜잭션 시작 em.persist(memberA); em.persist(memberB); // 이때까지는 INSERT SQL 을 데이터베이스에 보내지 않는다. // 커밋하는 순간 INSERT SQL 을 보낸다. transaction.commit(); // 트랜잭션 커밋 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL 을 모아둔다. 그리고 트랜잭션을 커밋할때 모아둔 커밋을 데이터 베이스로 보낸다. 트랜잭션을 커밋할때 데이터베이스에 flush 가 되며 이것을 쓰기 지연transactional write-behind 이라 한다. flush 란 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 작업이며 이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다. 트랜잭션을 지원하는 쓰기 지연이 가능한 이유 등록 쿼리를 그때 그때 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 데이터베이스에 반영되지 않는다. 어떻게든 커밋 직전에만 데이터베이스에 SQL 을 전달해도 되기 때문에 쓰기 지연이 가능하다. 내부 쿼리 저장소에 저장한 쿼리를 데이터베이스에 한 번에 전달함으로써 성능을 최적화 할 수 있다. ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:5:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"3.4.3 엔티티 수정 엔티티의 변경사항을 감지하여 데이터베이스에 자동으로 반영하는 기능을 변경감지dirty checking 이라고 한다. // 엔티티 매니저 생성 EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); // 영속 엔티티 조회 Member memberA = em.find(Member.class, \"memberA\"); memberA.setUsername(\"riley\"); memberA.setAge(10); // em.update(memberA); // 이런 코드는 필요하지 않다. transaction.commit(); JPA 는 엔티티를 영속성 컨텍스트에 보관할때, 최초 상태를 복사해서 저장해며 이것을 스냅샷 이라고 한다. 플러시 시점에 스냅샷과 엔티티를 비교하여 변경된 엔티티를 찾는다. 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티만 적용된다. JPA 를 통하여 모든 필드를 업데이트 했을때 데이터베이스에 보내는 데이터 전송량이 증가하는 단점이 있다. 모든 필드를 사용하면 수정쿼리가 항상 같다. (물론 바인딩되는 데이터는 다름) 따라서 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용이 가능하다. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스에서는 이전에 파싱한 쿼리를 재사용한다. 필드가 많거나 저장되는 내용이 너무 크다면 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성하는 전략을 사용한다. // org.hibernate.annotations.DynamicUpdate @Entity @org.hibernate.annotations.DynamicUpdate @Table(name = \"Memeber\") public class Member {...} org.hibernate.annotations.DynamicUpdate 어노테이션을 사용하면 수정된 데이터만 사용해서 동적으로 UPDATE SQL 을 생성한다. 저장할때 데이터가 존재하는 필드만 INSERT SQL 을 동적으로 생성시에는 @DynamicInsert 를 사용한다. ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:5:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"3.4.4 엔티티 삭제 // 엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다. Member memberA = em.find(Member.class, \"memberA\"); em.remove(memberA); 엔티티 삭제도 엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 데이터베이스에 삭제 쿼리를 전달한다. em.remove(memberA) 를 호출하는 순간 memberA 는 영속성 컨텍스트에서 제거된다. ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:5:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"이미지 출처 http://ptgmedia.pearsoncmg.com/images/chap8_9780131587564/elementLinks/08fig01.jpg ","date":"2018-12-17","objectID":"/archives/dbms/jpa/jpa-programming3-1/:6:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/archives/dbms/jpa/jpa-programming3-1/"},{"categories":["jpa"],"content":"김영한님의 책 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:0:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"2.2 H2 데이터베이스 설치 H2DB 는 자바 기반의 오픈소스 관계형 데이터 베이스이다. 별도의 설치과정이 필요하지 않고 용량도 1.7M 로 가볍다. SQL 문법은 다른 DBMS 와 마찬가지로 표준 SQL 이 대부분 지원된다. ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:1:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"H2 데이터 베이스 설치방법 아래 링크에서 zip 파일을 내려받아 압축을 푼다. 링크 - http://www.h2database.com/html/main.html 압축을 푼 곳에서 bin/h2.sh 를 실행한다. 실행이 완료되면 http://localhost:8082 로 접속하면 H2에 접속할 수 있는 화면이 나온다. -- 회원테이블을 생성 CREATE TABLE MEMBER ( ID VARCHAR(255) NOT NULL, -- 아이디(기본키) NAME VARCHAR(255), -- 이름 AGE INTEGER NOT NULL, -- 나이 PRIMARY KEY (ID) ) ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:1:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"2.3 라이브러리와 프로젝트 구조 ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:2:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"JPA 구현체인 하이버네이트 사용을 위한 라이브러리 hibernate-core : 하이버네이트 라이브러리 hibernate-entitymanager : 하이버네이트가 JPA 구현체로 동작하도록 JPA 표준을 구현한 라이브러리. 이 라이브러리를 지정하면 hibernate-core 와 hibernate-jpa-2.1-api 라이브러리도 함께 내려 받는다. hibernate-jpa-2.1-api : JPA 2.1 표준 API를 모아둔 라이브러리 build.gradle dependencies { // h2 접속을 위한 라이브러리 implementation ('com.h2database:h2:1.4.199') implementation ('org.hibernate:hibernate-entitymanager:5.4.3.Final') testCompile group: 'junit', name: 'junit', version: '4.12' } ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:2:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"2.4 객체 매핑 @Entity : 엔티티 클래스를 나타내며 이 클래스를 테이블과 매핑한다고 JPA 에 알려준다. @Table : 엔티티 클래스에서 매핑할 테이블 정보를 명시한다. name 속성을 사용하여 매핑할 수 있으며, 이 어노테이션을 생략할 경우 클래스 이름을 테이블 이름으로 매핑한다. @Id : 엔티티 클래스 필드의 테이블 기본키 Primary Key 에 매핑한다. 이렇게 @Id 가 사용된 필드를 식별자 필드라 한다. @Column : 필드를 컬럼에 매핑한다. 매핑정보가 없는 필드 : 매핑 어노테이션을 생략하면 필드명을 사용해서 컬럼명을 매핑한다. 만약 대소문자를 구분하는 데이터베이스를 사용하면 명시적으로 매핑해야만 한다. package jpabook.start; // JPA 가 제공하는 매핑 어노테이션을 추가 import javax.persistence.*; @Entity @Table(name = \"MEMBER\") public class Member { @Id @Column(name = \"ID\") private String id; // 아이디 @Column(name = \"NAME\") private String username; // 이름 private Integer age; // 나이 // Getter, Setter // ... } ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:3:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"2.5 persistence.xml 설정 JPA 는 persistence.xml 을 사용해서 필요한 설정정보를 관리한다. 이 설정 파일이 META-INF/persistence.xml 클래스 패스 경로에 있으면 별도의 설정없이 JPA 가 인식할 수 있다. \u003cpersistence-unit name=\"jpabook\"\u003e JPA 설정은 영속성 유닛 persistence-unit 이라는 것부터 시작하는데 일반적으로 연결할 데이터베이스당 하나의 영속성 유닛을 등록한다. ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:4:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"데이터베이스 방언 JPA 는 특정 데이터베이스에 종속적이지 않은 기술이다. 각 데이터베이스는 데이터 타입, 제공 함수명, 페이징처리 등 제공하는 SQL 문법과 함수가 조금씩 다르다. SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능을 JPA 에서는 방언Dialect 라 한다. 하이버에니트를 포함한 대부분의 JPA 구현체들은 다양한 데이터베이스 방언 클래스를 제공한다. ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:4:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"각 데이터베이스별 방언클래스 https://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html_single/#configuration-optional-dialects ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:4:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"2.6 애플리케이션 개발 ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:5:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"2.6.1 엔티티 매니저 설정 엔티티 매니저 팩토리 생성 JPA 를 시작하기 위해서는 persistence.xml 설정 정보를 사용하여 엔티티 매니저 팩토리를 생성해야한다. 엔티티 매니저 팩토리는 persistence.xml설정 정보를 읽어 JPA 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서 커넥션 풀도 생성한다. 엔티티 매니저 팩토리는 생성 비용이 매우크므로 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다. 엔티티 매니저 생성 JPA 대부분의 기능을 엔티티 매니저에서 제공한다. 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 등록/수정/삭제/조회 할 수 있다. 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관련이 있으므로 스레드 간 공유하거나 재사용하면 안된다. 종료 사용이 끝난 엔티티 매니저와 엔티티 매니저 팩토리는 종료해야 한다. ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:5:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"2.6.2 트랜잭션 관리 JPA 를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션을 시작하려면 엔티티 매니저 에서 트랜잭션 API 를 받아와야 한다. 트랜잭션 API 를 사용하여 비즈니스 로직이 정상 동작하면 트랜잭션을 커밋 commit 하고 예외가 발생하면 rollback 한다. // 트랜잭션 기능 획득 EntityTransaction tx = em.getTransaction(); ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:5:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["jpa"],"content":"2.6.4 JPQL JPA 는 SQL 을 추상화한 JSQP 이라는 객체 지향 쿼리 언어를 제공한다. JPQL 은 SQL 과 문법이 거의 유사하다. 차이점 JPQL 은 엔티티 객체 를 대상으로 쿼리한다. SQL 은 데이터베이스 테이블 을 대상으로 쿼리한다. // 목록 조회 TypedQuery\u003cMember\u003e query = em.createQuery(\" SELECT m FROM Member m \", Member.class); List\u003cMember\u003e members = query.getResultList(); ","date":"2018-12-15","objectID":"/archives/dbms/jpa/jpa-programming2/:5:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/archives/dbms/jpa/jpa-programming2/"},{"categories":["python"],"content":"파이썬의 변수와 객체 C 와 같은 언어에서 변수는 메모리 상 저장공간에 직접 값을 할당한다면, 파이썬에서 변수는 메모리상에 생성된 객체를 참조 하는 개념이다. \u003e\u003e\u003e x = 100 \u003e\u003e\u003e y = 100 \u003e\u003e\u003e x is y True # 257 부터는 서로 다른 객체로 생성됨. \u003e\u003e\u003e x = 257 \u003e\u003e\u003e y = 257 \u003e\u003e\u003e x is y False 위의 예제에서는 x 와 y 는 100 이라는 메모리상 같은 객체를 가리키고 있다.(= 같은 메모리 주소를 가리킨다.) 파이썬에서는 자주 사용하는 정수 범위(0-256) 는 메모리에 한 번만 올려두고 여러 변수가 가리키게 함으로써 메모리를 효과적으로 사용하고 있다. 자바에서 기본타입(Primitive Type) 을 wrapper class 를 사용하여 객체로 다루는 것과 비슷하게 동작한다. (하지만 자바의 경우는 100 이라는 값을 갖는 새로운 메모리 주소를 생성할 수 있다.) ","date":"2018-12-14","objectID":"/archives/python/python-data-type/:1:0","tags":["python"],"title":"파이썬의 자료형","uri":"/archives/python/python-data-type/"},{"categories":["python"],"content":"파이썬의 숫자 자료형 파이썬에서는 숫자를 정수(int), 실수(float), 복소수(complex) 로 구분한다. ","date":"2018-12-14","objectID":"/archives/python/python-data-type/:2:0","tags":["python"],"title":"파이썬의 자료형","uri":"/archives/python/python-data-type/"},{"categories":["python"],"content":"1. 정수형 (Integer) 정수를 표현하는 자료형으로 10 진수 이외에도 2진수, 8진수, 16진수 로도 표현 할 수 있다. \u003e\u003e\u003e a = 0o177 # 8진수 (Oo 또는 0O 시작) \u003e\u003e\u003e b = 0x8ff # 16진수 (Ox 시작) 파이썬에서는 정수 자료형에 오버플로우가 없다 ","date":"2018-12-14","objectID":"/archives/python/python-data-type/:2:1","tags":["python"],"title":"파이썬의 자료형","uri":"/archives/python/python-data-type/"},{"categories":["python"],"content":"2. 실수형 (Floating-point) 파이썬에서 실수형은 소수점이 포함된 숫자를 의미한다. 정수부가 0 인 소수는 0 을 생략 할 수 있다. \u003e\u003e\u003e .1 0.1 컴퓨터에서는 표준에 따라 부동소수점 방식으로 표현한다. (IEEE 부동 소수점방식) 부동소수점 방식에는 숫자를 정수로 된 유효숫자와 정수로 된 지수의 곱으로 표현한다. \u003e\u003e\u003e 123e2 # 123.0 x 100 = 12300.0 12300.0 💻 컴퓨터에서 부동 소수점에 의한 실수 표현은 오차가 존재한다. ","date":"2018-12-14","objectID":"/archives/python/python-data-type/:2:2","tags":["python"],"title":"파이썬의 자료형","uri":"/archives/python/python-data-type/"},{"categories":["python"],"content":"3. 복소수 (complex) 파이썬에서는 허수를 표시하려면 i 가 아닌 j 를 사용한다. \u003e\u003e\u003e a = 3 + 3j \u003e\u003e\u003e type(a) \u003cclass 'complex'\u003e \u003e\u003e\u003e a = complex(3, 3) \u003e\u003e\u003e a (3+3j) ","date":"2018-12-14","objectID":"/archives/python/python-data-type/:2:3","tags":["python"],"title":"파이썬의 자료형","uri":"/archives/python/python-data-type/"},{"categories":["python"],"content":"연산자 파이썬에서 사용하는 연산자 연산자 설명 + 덧셈 - 뺄셈 * 곱셈 / 나눗셈 // 나눗셈의 몫 % 나누셈의 나머지 ** 지수 연산자 +value 단항덧셈 -value 단항뺄셈 \u003e\u003e\u003e 2 + 2 4 \u003e\u003e\u003e 50 - 5 * 6 20 \u003e\u003e\u003e (50 - 5*6) / 4 5.0 \u003e\u003e\u003e 8 / 5 1.6 \u003e\u003e\u003e / 연산자의 경우 python2 에서는 항목에 따라 정수형으로 나누어 떨어지지 않을경우 소수점을 버림으로써 정수형을 유지하는 반면, python3 에서는 정수형으로 나누어 떨어지지 않을경우 자동으로 소수형으로 형 변환된 결과를 출력한다. Python 2.7.15 (default, Mar 14 2019, 22:47:06) [GCC 7.3.0] on linux2 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e 8 / 5 1 Python 3.7.0 (default, Mar 13 2019, 22:44:23) [GCC 7.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e 8 / 5 1.6 / 의 연산자는 항상 float 를 리턴함으로 정수형 결과를 리턴받고 싶다면 // 연산자를 이용하면 된다. ","date":"2018-12-14","objectID":"/archives/python/python-data-type/:3:0","tags":["python"],"title":"파이썬의 자료형","uri":"/archives/python/python-data-type/"},{"categories":["python"],"content":"인터프리터 환경에서 _ 활용 파이썬 인터프리터에서는 마지막으로 실행된 결과값이 _ 라는 변수에 저장된다. \u003e\u003e\u003e tax = 12.5 / 100 \u003e\u003e\u003e price = 100.50 \u003e\u003e\u003e price * tax 12.5625 \u003e\u003e\u003e price + _ 113.0625 \u003e\u003e\u003e round(_, 2) 113.06 ","date":"2018-12-14","objectID":"/archives/python/python-data-type/:4:0","tags":["python"],"title":"파이썬의 자료형","uri":"/archives/python/python-data-type/"},{"categories":["python"],"content":"문자열 파이썬의 문자열 표현식 : ''(Single quotes) 또는 \"\" (double quotes) 이스케이프 (\\) 를 사용하여 문자열 리터럴 내에 이스케이프 혹은 연속된 3개 이상의 따옴표 표현 할 수 있다. \u003e\u003e\u003e 'spam eggs' # single quotes 'spam eggs' \u003e\u003e\u003e 'doesn\\'t' # use \\' to escape the single quote... \"doesn't\" \u003e\u003e\u003e \"doesn't\" # ...or use double quotes instead \"doesn't\" 문자열은 + 로 연결할 수 있고 * 연산자로 반복시킬 수 있다. 두 개이상의 문자열 리터럴이 연속으로 나타나면 자동으로 이어 붙여준다. 변수들 끼리 혹은 변수와 리터럴을 이어 붙이려면 + 연산자를 사용해야 한다. \u003e\u003e\u003e 3 * 'un' + 'ium' 'unununium' \u003e\u003e\u003e 'Py''thon' 'Python' # 변수와 리터럴을 이어 붙이려면 + 사용 \u003e\u003e prefix = 'Py' \u003e\u003e\u003e prefix + 'thon' 'Python' ","date":"2018-12-14","objectID":"/archives/python/python-data-type/:5:0","tags":["python"],"title":"파이썬의 자료형","uri":"/archives/python/python-data-type/"},{"categories":["python"],"content":"pyenv? pyenv 는 하나의 시스템에서 여러 다양한 버전의 Python 을 관리하기 위한 관리 도구이다. 파이썬 버전을 사용자 단위 혹은 프로젝트별로 각각 다른 버전을 사용할 수 있다. ruby 의 rvm, Node.js 의 nvm 와 같은 역할을 하는 Version Manager 이다. https://github.com/pyenv/pyenv ","date":"2018-12-13","objectID":"/archives/python/start-python-using-pyenv/:1:0","tags":["python","pyenv"],"title":"pyenv를 이용하여 python 시작하기","uri":"/archives/python/start-python-using-pyenv/"},{"categories":["python"],"content":"pyenv 설치 python 을 설치하는데 필요한 패키지 설치 $ sudo apt install curl git-core gcc make zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev libssl-dev pyenv 소스 다운로드 Gibhub 저장소에서 최신 pyenv 소스를 클론하여 ~/.pyenv 경로에 설치한다. $ git clone https://github.com/pyenv/pyenv.git ~/.pyenv 환경변수 등록 사용하는 Shell 맞추어 환경변수 설정한다. bash shell 을 사용하는 경우 ~/.bash_profile 또는 ~/.bashrc $ echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.zshrc $ echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.zshrc $ echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init -)\"\\nfi' \u003e\u003e ~/.zshrc # 변경 사항 적용을 위한 Shell 재기동 $ exec \"$SHELL\" ","date":"2018-12-13","objectID":"/archives/python/start-python-using-pyenv/:2:0","tags":["python","pyenv"],"title":"pyenv를 이용하여 python 시작하기","uri":"/archives/python/start-python-using-pyenv/"},{"categories":["python"],"content":"pyenv 사용하기 pyenv 설치 가능한 버전 확인 python 버전을 설치하기 전에 이 명령으로 설치 가능한 버전을 확인 할 수 있다. $ pyenv install --list # 설치가능한 python 버전을 보여준다. Available versions: 2.1.3 2.2.3 2.3.7 2.4.0 2.4.1 2.4.2 install 명령어를 사용하여 원하는 버전을 설치한다. $ pyenv install 3.7.2 Downloading Python-3.7.2.tar.xz... -\u003e https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tar.xz Installing Python-3.7.2... 설치된 모든 python 버전 보기 $ pyenv versions # 설치된 파이썬 버전이 출력 pyenv versions system 3.7.0 * anaconda3-5.3.1 (set by /home/riley/.pyenv/version pyenv 명령어를 사용하여 전역 파이썬 버전 설정하기 $ pyenv global 3.7.0 $ python -V # 변경된 버전 출력 $ Python 3.7.0 ","date":"2018-12-13","objectID":"/archives/python/start-python-using-pyenv/:3:0","tags":["python","pyenv"],"title":"pyenv를 이용하여 python 시작하기","uri":"/archives/python/start-python-using-pyenv/"},{"categories":["python"],"content":"💡 오류 해결 빌드 설치시 ModuleNotFoundError: No module named _ctypes 로 파이썬 빌드가 안될때 libffi-dev 를 설치한다. https://stackoverflow.com/a/35460842 # libffi-dev $ apt-get install -y libffi-dev ","date":"2018-12-13","objectID":"/archives/python/start-python-using-pyenv/:4:0","tags":["python","pyenv"],"title":"pyenv를 이용하여 python 시작하기","uri":"/archives/python/start-python-using-pyenv/"},{"categories":["python"],"content":"참고 및 출처 리눅스에서 파이썬 설치 및 파이썬 버전관리하기 ","date":"2018-12-13","objectID":"/archives/python/start-python-using-pyenv/:5:0","tags":["python","pyenv"],"title":"pyenv를 이용하여 python 시작하기","uri":"/archives/python/start-python-using-pyenv/"},{"categories":["jpa"],"content":"김영한님의 책 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:0:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"1.1 SQL을 직접 다룰 때 발생하는 문제점 ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:1:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"코드의 반복작성 데이터베이스는 객체 구조와는 달리 데이터 중심의 구조를 갖는다. 객체를 데이터베이스에 CRUD 하기 위해서는 너무 많은 SQL 과 JDBC API 를 사용하여 변환작업을 직접 해주어야 한다. ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:1:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"SQL 에 의존적인 개발 객체들이 어떤 엔티티를 참조하고 있는지 DAO(데이터 접근 계층) 을 열어 SQL 를 확인해야만 한다. SQL 과 JDBC API 를 DAO 에 은닉화하였지만 논리적으로는 엔티티와 아주 강한 의존관계를 가지고 있다. ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:1:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"JPA 와 문제해결 JPA 를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL 을 작성하는 것이 아닌 JPA 가 제공하는 API 를 사용하면 된다. JPA 저장기능 jpa.persist(member); // 저장 JPA 조회기능 JPA 는 객체와 매핑정보를 보고 적절한 SELECT SQL 을 생성하여 데이터베이스에 전달하고 그 결과를 Member 객체를 생성하여 반환한다. String memberId = \"id0001\"; Member member = jpa.find(Member.class, memberId); // 조회 JPA 수정기능 JPA 는 별도의 수정 메소드를 제공하지 않으며, 객체를 조회하여 값을 변경하면 트랜잭션을 커밋할때 데이터베이스에 적절한 UPDATE SQL 구문을 전달한다. Member member = jpa.find(Member.class, memberId); member.setName(\"이름변경\"); // 수정 연관된 객체 조회 JPA 는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 을 실행한다. Member member = jpa.find(Member.class, memberId); Team team = member.getTeam(); // 연관된 객체 조회 ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:1:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"1.2 패러다임의 불일치 관계형 데이터 베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 그리고 객체지향의 추상화, 상속, 다형성 같은 개념이 없다. 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르며 기능과 표현방법도 다르다. 이것을 객체와 관계형 데이터베이스의 패러다임 불일치 문제라 한다. 패러다임 불일치 문제로 객체 구조를 테이블 구조에 저장하는 데에는 한계가 있다. ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:2:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"패러다임 불일치 문제들 상속 객체는 상속이라는 기능을 갖고 있지만 테이블은 상속이라는 기능이 없다. 데이터베이스 모델링에서 슈퍼타입 서비타입 관계를 사용하면 객체 상속과 유사한 형태로 테이블을 설계 할 수 있다. // 객체 모델 코드 abstract class Item { Long id; String name; int price; } class Album extends Item { String artist; } class Movie extends Item { String director; String actor; } class Book extends Item { String author; String isbn; } 데이터베이스와 객체모델의 상속 패러다임 Album 객체를 저장하려면 Item 과 Album 객체에 대한 INSERT SQL 를 작성해야 하며 슈퍼타입 서브타입 모델링의 경우 부모객체에 자식타입을 저장해야한다. Album 조회하려면 Item 과 Album 을 조인하여 조회 후 그 결과로 Album 를 생성해야 한다. JPA 에서는 자바 컬렉션에 객체를 저장하듯이 JPA 에게 객체를 저장하면된다. ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:2:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"연관관계 객체 참조에 접근하여 연관된 객체를 조회한다. 객체는 참조가 있는 방향으로만 조회 할 수 있다. 테이블 외래키와 조인을 사용하여 다른 테이블과 연관관계를 가지고 조인을 사용하여 연관된 테이블을 조회한다. 데이터베스와 객체모델의 연관관계 패러다임 JPA 개발자가 연관관계를 설정하면 JPA 에서 참조를 외래키를 변환하여 데이터베이스에 전달한다. // 회원과 팀 연관관계를 설정 member.setTime(team); jpa.persist(member); // 회원과 연관관계 함께 저장 ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:2:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"객체 그래프 탐색 SQL 을 직접 다루면 실행하는 SQL 에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다. 모든 연관 객체 그래프를 조회하여 메모르에 올려두는 것 또한 현실성이 없으므로 회원을 조회하는 메소드를 상황에 따라 여러벌 작성해야 한다. // 객체 그래프를 탐색할 수 있을지 없을 시 코드만 보고는 예측할 수 없다. class MemberService { ... public void process () { Member member = memberDAO.find(memberId); memberId.getTema(); // member-\u003eteam 객체 그래프 탐색이 가능한가? member.getOrder().getDelivery() // ??? } } // 상황에 따라 여러벌 작성해야 한다.?!! memberDAO.getMember(); // Member 조회 memberDAO.getMemberWithTeam(); // Member 와 Team 조회 memberDAO.getMemberWithOrderWithDeliver(); // Member 와 Order 와 Delivery 조회 JPA 와 객체 그래프 탐색 JPA 는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 을 실행한다. 실제 객체를 사용하는 시점까지 조회를 미룬다고 하여 지연로딩 이라 한다. JPA 는 지연 로딩을 투명(transparent) 하게 처리한다. JPA 는 연관 객체를 즉시 함께 조회할 것인지 사용되는 시점에서 지연하여 조회할지 간단하게 설정할 수 있다. ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:2:3","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"비교 동일성 비교(idnetity) : == 비교이며, 객체 인스턴스의 참조 값(주소)을 비교한다. 동등성 비교(equals) : 메서드를 사용하여 객체 내부의 값을 비교한다. JPA 와 비교 JPA 는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다. // JPA 비교 String memberId = \"100\"; Member member1 = jpa.find(memberId); Member member2 = jpa.find(memberId); member1 == member2; // 같다. ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:2:4","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"정리 객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다. JPA 는 이러한 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다 ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:3:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"1.3 JPA 란 무엇인가. JPA Java Persistence API 는 자바 진영의 ORM 기술 표준이다. ORM Object-Relationship Mapping 은 객체와 관계형 데이터베이스를 매핑하며, 단순히 CRUD 를 제공하는 것 뿐만아니라 ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결 해준다. ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:4:0","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"1.3.1 JPA 소개 JPA 는 자바 ORM 기술에 대한 API 표준 명세이다. (쉽게 말하면, 인터페이스를 모아 둔 것) JPA 2.1 을 구현한 구현체로는 Hibernate, EclipseLink, DataNucleus 이며 이중 Hibernate 가 가장 대중적이다. ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:4:1","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["jpa"],"content":"1.3.2 JPA 를 사용해야 하는 이유 생산성 SQL 을 작성하고 JDBC API 를 사용하는 지루하고 반복적인 CRUD SQL 을 개발자가 직접 작성하지 않아도 된다. 유지보수 필드 추가나 수정 삭제 시에도 개발자가 작성해야 했던 SQL 과 JDBC API 코드를 JPA 가 대신 처리함으로 유지보수 해야하는 코드 수가 줄어든다. 객체 지향 모델의 장점들을 활용하여 유연하고 유지보수하기 좋은 도메인 모델을 설계할 수 있다. 패러다임의 불일치 해결 JPA 는 객체와 관계형 모델 간 패러다임의 불일치 (상속, 연관관계, 객체 그래프 탐색, 비교) 문제를 해결 성능 JPA 는 어플리케이션과 데이터베이스 사이에 다양한 성능 최적화 기능을 제공한다. 하이버네이트의 경우 SQL 힌트를 넣을 수 있는 기능도 제공한다. 데이터 접근 추상화와 벤더 독립성 관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 존재한다. JPA 는 애플리케이션과 데이터 베이스 사이에 추상화된 데이터 접근 계층을 제공하여, 특정 DBMS 에 종속되지 않도록 한다. 표준 JPA 는 자바 진영의 ORM 기술 표준으로, 표준을 사용하면 다른 구현 기술로 손쉽게 변경할 수 있다. ","date":"2018-12-09","objectID":"/archives/dbms/jpa/jpa-programming1/:4:2","tags":["jpa","orm"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/archives/dbms/jpa/jpa-programming1/"},{"categories":["javascript"],"content":" 👩🏻‍💻 회사에서는 외부 네트워크 연결이 불가능하도록 망분리가 되어있다. 개발시 npm install을 통해 외부 라이브러리를 설치해야하는 경우 사내 nexus 서버에 npm 기본 저장소를 프록시하도록 설정 후 다음과 같이 npm config 명령어를 통해 저장소 경로를 변경해 주었다. ","date":"2018-12-09","objectID":"/archives/javascript/change-default-repo-npm/:0:0","tags":["javascript","nodejs","npm"],"title":"NPM 기본 저장소 대신 지정한 저장소 사용하기","uri":"/archives/javascript/change-default-repo-npm/"},{"categories":["javascript"],"content":"npm repository 다른 저장소로 사용하기 npm config set registry 명령어로 기본 저장소 대신 다른 저장소를 사용할 수 있다. npm config set registry 다른저장소경로 ~/.npmrc에 변경된 저장소가 다음과 같이 설정되어 있다. registry=다른저장소경로 ","date":"2018-12-09","objectID":"/archives/javascript/change-default-repo-npm/:1:0","tags":["javascript","nodejs","npm"],"title":"NPM 기본 저장소 대신 지정한 저장소 사용하기","uri":"/archives/javascript/change-default-repo-npm/"},{"categories":["javascript"],"content":"Installation and Update ","date":"2018-12-09","objectID":"/archives/javascript/install-the-nodejs-with-nvm/:1:0","tags":["javascript","nodejs","nvm"],"title":"NVM을 이용하여 Node.js 설치하기","uri":"/archives/javascript/install-the-nodejs-with-nvm/"},{"categories":["javascript"],"content":"1. NVM 설치 Git Repo의 NVM의 README 파일을 참고한다. https://github.com/nvm-sh/nvm curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash ","date":"2018-12-09","objectID":"/archives/javascript/install-the-nodejs-with-nvm/:1:1","tags":["javascript","nodejs","nvm"],"title":"NVM을 이용하여 Node.js 설치하기","uri":"/archives/javascript/install-the-nodejs-with-nvm/"},{"categories":["javascript"],"content":"2. NVM 환경설정 .bashrc 혹은 .zshrc 에 추가한다. source ~/.bashrc 로 적용 또는 터미널을 재시작한다. export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 . \"$NVM_DIR/nvm.sh\" # This loads nvm ","date":"2018-12-09","objectID":"/archives/javascript/install-the-nodejs-with-nvm/:1:2","tags":["javascript","nodejs","nvm"],"title":"NVM을 이용하여 Node.js 설치하기","uri":"/archives/javascript/install-the-nodejs-with-nvm/"},{"categories":["javascript"],"content":"3. nvm 버전확인 및 설치 가능 Nodejs 리스트 확인 # nvm 버전 확인 nvm --version # 설치 가능 NodeJs 버전 확인 nvm ls-remote ","date":"2018-12-09","objectID":"/archives/javascript/install-the-nodejs-with-nvm/:1:3","tags":["javascript","nodejs","nvm"],"title":"NVM을 이용하여 Node.js 설치하기","uri":"/archives/javascript/install-the-nodejs-with-nvm/"},{"categories":["javascript"],"content":"4. NodeJs 설치하기 # v10의 최신버전 nvm install v10 # 최신버전 nvm install # LTS 최신 버전 nvm install --lts 5. 버전을 선택해서 사용하기 # nvm use version nvm use v10.17.0 ","date":"2018-12-09","objectID":"/archives/javascript/install-the-nodejs-with-nvm/:1:4","tags":["javascript","nodejs","nvm"],"title":"NVM을 이용하여 Node.js 설치하기","uri":"/archives/javascript/install-the-nodejs-with-nvm/"},{"categories":["Spring Framework"],"content":" spring-security-oauth2 프로젝트는 deprecated 되었다고 한다. 나는 그냥 적용했다… OAuth 2.0 Migration Guide ","date":"2018-12-09","objectID":"/archives/spring-framework/build-spring-oauth2-provider/:0:0","tags":["spring framework"],"title":"Spring Framework OAuth2 Provider 서버 구성하기(작성중)","uri":"/archives/spring-framework/build-spring-oauth2-provider/"},{"categories":["Spring Framework"],"content":"스프링 멀티모듈 프로젝트 구성 module-api를 Resource 서버로 사용하고 특정 API를 요청할때 마다 토큰 인증이 필요하게끔 구성한다. oauth 서버에서는 사용자 인증 처리와 토큰 발급을 한다. spring-demo └─ module-domain : DB 설정, Entity, 공통 Util을 정의. └─ module-api : 클라이언트(회원가입, 주문) 비즈니스 로직과 관련된 Controller / Service / Repository 정의. (Resource Server) └─ oauth : 스프링 시큐리티 / OAuth2 서버 기능을 정의한 모듈 build.gradle.kts JWT 토큰을 사용하기 위해 spring-security-jwt 라이브러리 의존성을 추가 하였다. project(\"oauth\") { dependencies { implementation(project(\":module-domain\")) implementation(\"org.springframework.boot:spring-boot-starter-web\") // OAuth2 라이브러리 관련 implementation (\"org.springframework.boot:spring-boot-starter-security\") implementation (\"org.springframework.security.oauth:spring-security-oauth2:2.1.1.RELEASE\") implementation (\"org.springframework.security:spring-security-jwt:1.0.9.RELEASE\") } } ","date":"2018-12-09","objectID":"/archives/spring-framework/build-spring-oauth2-provider/:1:0","tags":["spring framework"],"title":"Spring Framework OAuth2 Provider 서버 구성하기(작성중)","uri":"/archives/spring-framework/build-spring-oauth2-provider/"},{"categories":["Spring Framework"],"content":"Authorization Server Configuration ","date":"2018-12-09","objectID":"/archives/spring-framework/build-spring-oauth2-provider/:2:0","tags":["spring framework"],"title":"Spring Framework OAuth2 Provider 서버 구성하기(작성중)","uri":"/archives/spring-framework/build-spring-oauth2-provider/"},{"categories":["Spring Framework"],"content":"ClientDetailsServiceConfigurer ClientDetailsService는 in-memory 방식과 JDBC 방식으로 선택하여 구현할 수 있다. 나는 회원별로 ClientDetail 정보를 구성할 것이기 때문에 DB에서 가져오는 방식을 선택하였다. 하지만 운영하다보니 ClientDetailsService를 여러번 호출해서 사용하기 때문에 그때마다 DB에 접근하여 조회하는 것은 별로인 것 같아 추후에 ClientDetailsService에서 조회하는 정보는 캐시를 적용할 예정이다. 캐시를 적용하기 위해서 나는 ClientDetailsService를 재정의 하였다. DB 스키마 PlatformClientDetailService.java @Service public class PlatformClientDetailService implements ClientDetailsService { @Autowired private OAuthClientDetailsRepository oAuthClientDetailsRepository; @Override public ClientDetails loadClientByClientId(String clientId) throws ClientRegistrationException { ClientDetails client = oAuthClientDetailsRepository.getOAuthClient(clientId); if(client == null) { throw new ClientRegistrationException(\"Unauthorized client\"); } return client; } } OAuthConfiguration.java @Configuration public class OAuthConfiguration extends AuthorizationServerConfigurerAdapter { @Bean(\"clientDetailService\") public ClientDetailsService getPlatformClientDetailService() { return new PlatformClientDetailService(); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.withClientDetails(getPlatformClientDetailService()); } } ","date":"2018-12-09","objectID":"/archives/spring-framework/build-spring-oauth2-provider/:2:1","tags":["spring framework"],"title":"Spring Framework OAuth2 Provider 서버 구성하기(작성중)","uri":"/archives/spring-framework/build-spring-oauth2-provider/"},{"categories":["Spring Framework"],"content":"Configuring Client Details ","date":"2018-12-09","objectID":"/archives/spring-framework/build-spring-oauth2-provider/:2:2","tags":["spring framework"],"title":"Spring Framework OAuth2 Provider 서버 구성하기(작성중)","uri":"/archives/spring-framework/build-spring-oauth2-provider/"},{"categories":["elasticsearch lecture"],"content":"Other Settings /etc/security/limits.conf Elasticsearch 는 많은 파일을 쓰거나 핸들링하게 된다. 열 수 있는 File descriptor가 부족하면 데이터의 손실로 이어질 수 있으며 실행할 수 있는 최대 File Descriptor 를 65,536 개 이상으로 설정하도록 한다. vi /etc/security/limits.conf elasticsearch soft nofile 65536 elasticsearch hard nofile 65536 Thread 수 Elasticsearch 는 여러 유형의 작업에 대해 많은 Thread Pool을 사용하게 된다.. Elasticsearch 사용자가 만들 수 있는 Thread 가 4096 개 이상인지 확인한다. elasticsearch soft noproc 4096 elasticsearch hard noproc 4096 Sysconfig file RPM 또는 Debian 패키지를 사용하여 시스템 설정 및 환경 변수를 지정할 수 있다. /etc/sysconfig/elasticsearch Virtual Memory Elasticsearch 는 기본적으로 Index 를 저장하기 위해 FileSystem을 사용하기 위한 mmmap을 사용한다. mmap의 개수는 기본 운영체제의 제한이 너무 낮아 메모리 부족 예외를 발생시키기도 한다. sudo vi /etc/sysctl.conf vm.max_map_count=22144 sudo sysstl -p Swap disabling 일반적으로 JVM 옵션에서 메모리 사용이 제어되므로 Swap을 활성시킬 필요는 없다. # 일시적으로 swap을 비활성화 sudo swapoff -a swappiness configuration m.swappiness가 1로 설정되어 있는지 확인한다. 이렇게 하면 swap되는 경우가 줄어들고 일반적인 상황에서는 swapping으로 이어지지 않는다. ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-5/:0:1","tags":["elasticsearch"],"title":"3.5 그 외 설정","uri":"/elasticsearch-lecture3-5/"},{"categories":["elasticsearch lecture"],"content":"log4j2.properties Elasticsearch는 로깅을 위해 Log4j2를 사용한다. Log4j2는 log4j2.properties 파일을 사용하여 구성할 수 있다. ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-4/:1:0","tags":["elasticsearch"],"title":"3.4 log4j2.properties","uri":"/elasticsearch-lecture3-4/"},{"categories":["elasticsearch lecture"],"content":"로그참조 파일 ${sys:es.logs.base_path} 로그의 Base 디렉토리 elasticsearch.yml 의 path.log에 설정된 경로 ${sys:es.logs.cluster_name} 클러스트 이름을 나타낸다. elasticsearch.yml 의 cluster.name으로 설정할 수 있다. ${sys:es.logs.node_name} 노드의 이름을 나타냅니다. elasticsearch.yml 의 node.name으로 설정할 수 있다. ex) ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}.log /var/log/elasticsearch/mycluster.log ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-4/:1:1","tags":["elasticsearch"],"title":"3.4 log4j2.properties","uri":"/elasticsearch-lecture3-4/"},{"categories":["elasticsearch lecture"],"content":"jvm.options jvm.options 의 설정을 통해 JVM(Java Virtual Machine) 의 옵션을 변경할 수 있다. 설정 파일은 config/jvm.options(tar or zip 배포판) 또는 /etc/elasticsearch/jvm.options(rpm 패키지 설치) 에서 위치하고 있다. ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-3/:1:0","tags":["elasticsearch"],"title":"3.3 jvm.options","uri":"/elasticsearch-lecture3-3/"},{"categories":["elasticsearch lecture"],"content":"JVM Heap Size Configuration Elasticsearch 는 Java 기반이기 때문에 Heap 메모리를 어떻게 설정하느냐에 따라 성능에 큰 영향을 미치게 된다. 기본적으로 Elasticsearch 의 최소, 최대 Heap 사이즈는 2GB로 설정되어 있다. 실제 운영환경에 따라서 Elasticsearch 에서 충분한 Heap 을 사용할 수 있도록 Heap Size 를 구성하는 것이 중요하다. ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-3/:2:0","tags":["elasticsearch"],"title":"3.3 jvm.options","uri":"/elasticsearch-lecture3-3/"},{"categories":["elasticsearch lecture"],"content":"Elasticsearch 와 Heapsize 아래는 jvm.options에서 최소 및 최대 힙 사이즈 크기를 설정하는 예시이다. # set the minimun heap size to 2GB -Xms2g # set the maximum heap size to 2GB -Xmx2g ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-3/:2:1","tags":["elasticsearch"],"title":"3.3 jvm.options","uri":"/elasticsearch-lecture3-3/"},{"categories":["elasticsearch lecture"],"content":"설정 권고 사항 최소 힙 크기(Xms) 와 최대 힙 크기(Xmx) 를 동일하게 설정하는 것이 좋다. 힙 크기가 크면 클 수록 많은 데이터를 힙 영역에서 사용할 수 있으나 GC (Garbage Collection) 발생에 대한 JVM 의 성능 저하 및 정지에 대한 이슈를 고려해야 한다. (Stop the world) 최대 힙 크기(Xmx) 를 실제 물리메모리(RAM) 에 50%를 넘지 않게 하는 것이 좋다. 힙 크기는 32G 를 넘지 않는 것이 좋다. JVM 은 데이더(Object) 에 접근하기 위한 메모리상의 주소를 OOP(Ordinary Object Pointer) 라는 구조체로 저장한다. OOP 는 아키텍쳐에 따라 32bit 와 62bit 크기의 주소값으로 참조하게 되며 32bit 환경에서 2^32 (= 4GB) 의 주소값을 나타낼 수 있고 64 bit 환경에서는 2^64(=18EB) 까지의 주소값을 표시할 수 있다. 64bit 환경에서는 메모리의 참조 영역이 넓기 때문에 성능이 떨어질 수 밖에 없다. 이러한 문제 때문에 JVM 은 32bit 기반의 OOP를 이용하며 Heap 영역이 4GB 를 넘어가는 경우에 메모리 주소의 offset 을 가리키는 Compressed OOP를 활용하게 된다. Compressed OOP 의 경우 메모리 주소의 Offset 을 가리키게 되며 이 오프셋은 8의 n 배수로 계산되어 기존 OOP 보다 8 배 더 많은 32GB 참조가 가능해진다. JVM option Description -XX:+UseConcMarkSweepGC 기본적으로 CMS GC 옵션을 사용. -XX:CMSInitiatingOccupancyFraction old generation 힙 공간의 사용량을 지정하여 CMS GC 주기를 설정할 수 있다. ex) -XX:CMSInitiatingOccupancyFraction=75 이면 old generation 75% 인 경우 CMS 주기를 시작하라는 의미. -XX:+UseCMSInitiatingOccupancyOnly GC 통계를 따르지 않고 CMSInitiatingOccupancyFraction 을 기준으로 GC 주기를 시작 -XX : HeapDumpOnOutOfMemoryError OOM(Out of Memory) 등으로 더이상 힙 영역을 할당할 수 없는 경우 Heap Dump 를 생성하는 옵션 -XX:HeapDumpPath Heap Dump를 저장할 경로를 지정 ex) -XX:HeapDumpPath=/var/lib/elasticsearch -XX:ErrorFile=filename 심각한 오류 로그(JVM Fatal Error logs를 받을 수 있는 경로를 지정 -XX:ErrorFile=/var/log/elasticsearch/hs_err_pid%p.log ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-3/:2:2","tags":["elasticsearch"],"title":"3.3 jvm.options","uri":"/elasticsearch-lecture3-3/"},{"categories":["elasticsearch lecture"],"content":"elasticsearch.yml elasticsearch.yml 은 데이터 파일 위치, 로그파일 위치 등 클러스터의 핵심적인 설정을 할 수 있는 구성 파일이다. 파일 포맷은 YAML 로 되어있다. # path.data : 데이터파일의 위치를 설정 # path.logs : ES 의 로그 파일이 저장될 위치를 설정 path: data: /var/lib/elasticsearch logs: /var/log/elasticsearch # 클러스터를 고유하게 식별할 수 있는 이름 설정 cluster: name: es-cluster # 노드를 고유하게 식별할 수 있는 이름설정 # 보통 호스트명 기준으로 설정하는 것이 운영에 용이 node: name: es-master01 path.data path.data 는 Index 의 데이터를 저장할 경로를 지정할 수 있으며 경로는 하나 혹은 여러개로도 지정이 가능하다. # ex) single path path: data: /data1 # ex ) multi path path: data: /data1, /data2 path.logs path.logs 는 Elasticsearch 의 로그를 저장할 경로할 수 있으며, 어플리케이션 운영 로그와 Elasticsearch Deprecated 로그, Indexing, Searching Slow 로그 등이 저장됩니다. ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:1:0","tags":["elasticsearch"],"title":"3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["elasticsearch lecture"],"content":"Discovery discovery 모듈은 클러스터 내의 노드를 발견하고 마스터 노드를 찾아내는 방식을 의미한다. Elasticsearch 는 P2P 기반의 시스템이며, 노드간 통신은 ping 을 기반으로 동작한다. ( 노드간 작업의 위임 broadcast ) 이 discovery 모듈에는 Zen discovery, EC2 discovery, GCE(Google Computer Engine) discovery 등을 지원한다. Elasticsearch 는 노드간 클러스터링 및 마스터 선출을 위해 Zen Discovery 라는 사용자 정의 검색 구현을 설정할 수 있다. discovery.zen.ping.unicast.hosts 동일한 클러스터 명을 전제로 설정된 호스트들 가운데 Master 를 선출할 수 있다. 이 설정에는 다른 노드 들에게 마스터 노드의 목록을 제공할 수 있다. # ex) master node host discovery.zen.ping.unicast.hosts: [ \"1.1.1.1:9300\", \"1.1.1.2:9300\", \"2.2.2.1:9300\", ] discovery.zen.minimum_master_nodes 적합한 마스터 노드의 최소 갯수를 설정 할 수 있다. 이 설정을 통하여 네트워크 장애등으로 인한 동일 클러스트 내에 마스터들이 최소 갯수만큼 내려가면 데이터 무결성을 위해 클러스터가 중지처리 된다. ( Split Brain 피하기 위함.) 마스터 노드의 최소 갯수 (master_eligible_nodes / 2) + 1 ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:2:0","tags":["elasticsearch"],"title":"3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["elasticsearch lecture"],"content":"Network 설정 network.host 노드가 응답 할 수 있는 IP 또는 호스트를 설정한다. 기본적으로 Elasticsearch는 루프백 주소에만 바인드 한다. (ex 127.0.0.1 ) 이는 단일 노드에서는 문제 없으나 여러 노드가 운용되는 클러스트 구성을 위해서는 비 루프백 주소를 바인드 해 주어야 한다. network.bind_host notework.host 설정에서 외부의 데이터 호출을 받는 부분만 분리 할 수 있다. # ex) network.bind_host network.bind_host: 0.0.0.0 network.publish_host 클러스트 내 다른 노드들과 통신 하는 부분만 분리 할 수 있다. # ex) network.bind_host network.publish_host: 10.190.5.5 http.port HTTP 프로토콜을 통해 Elasticsearch 의 API 를 전달할 때 사용할 포트를 지정할 수 있다. # ex) http.port http.port: 9200 transport.tcp.port 클러스터 내에 노드들이 서로 통신할 때 사용할 포트를 설정한다. 노드들은 서로의 용량과 샤드들의 상태를 알아야 하기 때문에 TCP 통신을 한다. # ex) transport.tcp.port transport.tcp.port: 9300 ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:3:0","tags":["elasticsearch"],"title":"3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["elasticsearch lecture"],"content":"Node Role 설정 Node Role 로는 master-eligible, data, ingest node, coordinate node 가 있다. elasticsearch.yml 설정을 통하여 각 노드의 역할을 부여할 수 있다. Master-eligible Node 마스터 노드로서의 역할을 할 수 있는 노드를 의미 # ex) master node role node.master: true node.data: false node.ingest: false Data Node 데이터를 저장되는 역할을 할 수 있는 노드를 의미 # ex) data node role master.node: false node.data: true node.ingest: false Ingest Node 문서가 인덱싱 되기 전에 파이프라인을 통해 사전처리를 할 수 있는 역할이 부여된 노드. 기본값은 true이며 보통 client node 를 세팅할 때 사용한다. # ex) ingest node role master.node: false node.data: false node.ingest: true Coordinate Node 클라이언트의 요청을 받고 라우팅 및 분산처리만 할 수 있는 역할이 부여된 노드. # ex) Coordinate node role master.node: false node.data: false node.ingest: false ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:4:0","tags":["elasticsearch"],"title":"3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["elasticsearch lecture"],"content":"그외 설정 http.cors.enabled: true 웹 브라우저나 Elasticsearch 에서 접근할 수 있도록 설정. Head / HQ 플러그인 사용시 설정할 수 있다. http.cors.allow-origin: “*” 웹 브라우저로 접근할 수 있는 IP ACL 설정 ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:5:0","tags":["elasticsearch"],"title":"3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["elasticsearch lecture"],"content":"참고 https://www.elastic.co/guide/en/elasticsearch/reference/6.4/discovery-settings.html#minimum_master_nodes https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html#node-ingest-node ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:6:0","tags":["elasticsearch"],"title":"3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["elasticsearch lecture"],"content":"Elasticsearch 는 정적으로 설정을 구성할 수 있을 뿐만 아니라 클러스터 운영중에도 클러스터 세팅 업데이트 API 를 통하여 동적인 설정 구성이 가능하다. ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-1/:0:0","tags":["elasticsearch"],"title":"3.1 Elasticsearch 구성하기","uri":"/elasticsearch-lecture3-1/"},{"categories":["elasticsearch lecture"],"content":"Static settings Elasticsearch는 노드별로 설정파일을 구성할 수 있다. Elasticsearch 에는 세 개의 구성 파일이 있으며, 이 설정 파일들의 위치는 아카이브 배포판 설치시에는 $ES_HOME/config, 패키지 배포시에는 (RPM 설치 등) /etc/elasticsearch 에 위치한다. elasticsearch.yml : Elasticsearch 의 핵심 설정 jvm.options : JVM 옵션 설정 ( heapsize 설정 ) log4j2.properties : Elasticsearch 의 logging 설정 ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-1/:1:0","tags":["elasticsearch"],"title":"3.1 Elasticsearch 구성하기","uri":"/elasticsearch-lecture3-1/"},{"categories":["elasticsearch lecture"],"content":"Dynamic settings 클러스터에 REST API 로 호출하여 클러스터를 운영중에도 구성 설정을 변경 할 수 있다. ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-1/:2:0","tags":["elasticsearch"],"title":"3.1 Elasticsearch 구성하기","uri":"/elasticsearch-lecture3-1/"},{"categories":["elasticsearch lecture"],"content":"참고 https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#settings ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-1/:3:0","tags":["elasticsearch"],"title":"3.1 Elasticsearch 구성하기","uri":"/elasticsearch-lecture3-1/"},{"categories":["elasticsearch lecture"],"content":"Elasticsearch 플러그인 플러그인은 사용자 정의 방식에 의해 ES 의 긴능을 향상 시키는 방법이다. 플러그인은 모든 노드에 설치해야 하며 설치 후 클러스터를 재시작 해야 한다. ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:1:0","tags":["elasticsearch"],"title":"2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["elasticsearch lecture"],"content":"플러그인 범주 ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:2:0","tags":["elasticsearch"],"title":"2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["elasticsearch lecture"],"content":"Core Plugins (권고) Elasticsearch 에서 공식적으로 지원하는 플러그인 Elasticsearch 버전이 업데이트 될때마다 버전 업데이트가 지원됨. ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:2:1","tags":["elasticsearch"],"title":"2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["elasticsearch lecture"],"content":"Community contributed 개인 개발자나 회사에 의해 지원되는 플러그인 ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:2:2","tags":["elasticsearch"],"title":"2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["elasticsearch lecture"],"content":"참고 Elasticsearch Reference - modules-plugins. ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:3:0","tags":["elasticsearch"],"title":"2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["elasticsearch lecture"],"content":"Elastic HQ 설치하기 ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:1:0","tags":["elasticsearch"],"title":"2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["elasticsearch lecture"],"content":"Requirements Python 3.4+ Elasticsearch. Supported versions: 2.x, 5.x, 6.x ElasticHQ Git Repository 에서 클론 혹은 다운로드 한다. # git 이 설치되어 있지 않으면 sudo yum -y install git git clone https://github.com/ElasticHQ/elasticsearch-HQ.git Python 3.4+ 설치한다. (pip 은 파이선 패키지 관리자) # clone 한 디렉터리로 이동 후 cd elasticsearch-HQ/ sudo yum -y install python34 python34-pip Repository 의 의존성 패키지 설치한다. pip install -r requirements.txt 서버시작 구동 python3 application.py 브라우저에서 http://localhost:5000 로 접속한다. ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:1:1","tags":["elasticsearch"],"title":"2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["elasticsearch lecture"],"content":"참고 HQ Git Repository HQ Documents ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:2:0","tags":["elasticsearch"],"title":"2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["elasticsearch lecture"],"content":"Elasticsearch Head 클러스트들을 한눈에 보기 위한 도구. 직접 서버를 구성하여 설치할 수도 있고 크롬의 브라우저 익스텐션으로도 제공한다. ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-3/:1:0","tags":["elasticsearch"],"title":"2.3 Head 소개","uri":"/elasticsearch-lecture2-3/"},{"categories":["elasticsearch lecture"],"content":"Installation ES Head git repository 에서 클론 혹은 다운로드한다. # git 이 설치되어 있지 않으면 sudo yum -y install git git clone https://github.com/mobz/elasticsearch-head.git npm 으로 관련 의존성 모듈 설치 cd elasticsearch-head/ sudo yum -y install bzip2 epel-release sudo yum -y install npm # Node 가 설치되어있어야 한다. npm install 내장서버 실행 npm run start 브라우저에서 http://localhost:9100 으로 확인한다. ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-3/:1:1","tags":["elasticsearch"],"title":"2.3 Head 소개","uri":"/elasticsearch-lecture2-3/"},{"categories":["elasticsearch lecture"],"content":"참고 Head Git Repository ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-3/:2:0","tags":["elasticsearch"],"title":"2.3 Head 소개","uri":"/elasticsearch-lecture2-3/"},{"categories":["elasticsearch lecture"],"content":"플러그인 설치 인터넷이 가능한 환경에서 설치시 $ cd /usr/share/elasticsearch/ $ sudo bin/elasticsearch-plugin install [플러그인이름] # example $ sudo bin/elasticsearch-plugin install analysis-nori ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:1:0","tags":["elasticsearch"],"title":"2.2 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["elasticsearch lecture"],"content":"파일서버 등에서 설치시 $ sudo bin/elasticsearch-plugin install file://path/to/plugin.zip # 파일서버 $ sudo bin/elasticsearch-plugin install [파일서버URL] ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:1:1","tags":["elasticsearch"],"title":"2.2 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["elasticsearch lecture"],"content":"설치된 플러그인 리스트 확인 sudo bin/elasticsearch-plugin list ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:1:2","tags":["elasticsearch"],"title":"2.2 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["elasticsearch lecture"],"content":"설치된 플러그인 제거 sudo bin/elasticsearch-plugin remove [플러그인이름] ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:1:3","tags":["elasticsearch"],"title":"2.2 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["elasticsearch lecture"],"content":"참고 Elasticsearch Reference - plugin-management ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:2:0","tags":["elasticsearch"],"title":"2.2 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"인덱스 생성, 삭제 및 조회하기 ","date":"2018-10-27","objectID":"/elasticsearch-lecture4/:1:0","tags":["elasticsearch"],"title":"Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"1. 인덱스 생성하기 인덱스는 문서document의 모음이다. 인덱스를 생성하는 방법 Index Settings를 정의한다. Index Mappings를 정의한다. 사용자 정의된 도큐먼트를 인덱싱한다. ","date":"2018-10-27","objectID":"/elasticsearch-lecture4/:1:1","tags":["elasticsearch"],"title":"Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"2. 인덱스의 settings Static Index Settings index.number_of_shards : 인덱스가 가져야 하는 Primary 샤드의 개수 설정. 기본값 5 Dynamic Index Settings index.number_of_replicas : 각 기본 샤드의 복제본 (Replica 샤드 개수 설정). 기본값은 1 index.refresh_interval : 검색 commit point 를 만드는 refresh interval 설정 (새로 고침 작업수행 빈도). -1 비활성화. 기본값 1s index.routing.allocation.enable : 인덱스의 샤드들의 라우팅 허용 설정 Other Settings Analysis, Mapping, Slowlog … ","date":"2018-10-27","objectID":"/elasticsearch-lecture4/:1:2","tags":["elasticsearch"],"title":"Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"3. 인덱스 생성 인덱스 Settings로 인덱싱 하기 # PUT 메소드를 이용한다. curl -X PUT \"localhost:9200/twitter\" -H 'Content-Type: application/json' -d { \"settings\" : { \"index\" : { \"number_of_shards\" : 3, \"number_of_replicas\" : 2 } } } CLI 사용 curl -X PUT -H \"Content-Type:application/json\" -d '{\"settings\" : {\"index\" : {\"number_of_shards\" : 3,\"number_of_replicas\" : 1}}}' http://localhost:9200/twitter2 ","date":"2018-10-27","objectID":"/elasticsearch-lecture4/:1:3","tags":["elasticsearch"],"title":"Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"4. 인덱스 삭제하기 DELETE 메소드를 사용한다. 인덱스 삭제시는 조심해서 삭제해야 한다. 주로 nginx와 같은 웹서버를 앞단에 두어 특정 IP 에서만 DELETE Method를 요청할 수 있도록 설정하거나 혹은 Index의 Read only 설정을 사용하여 아예 삭제 할 수 없도록 설정하는 것이 좋다. curl -X DELETE -H 'Content-Type: application/json' http://{ES_URL}:9200/{index} Read only로 삭제 방지, true/null로 설정/해제 PUT twitter/_settings { \"index.blocks.read_only_allow_delete\": true } ","date":"2018-10-27","objectID":"/elasticsearch-lecture4/:1:4","tags":["elasticsearch"],"title":"Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"5. 인덱스 조회 인덱스 세팅 확인하기 GET twitter/_settings 인덱스 상태를 확인 인덱스의 사이즈, Document 개수, 실행된 명령 정보들 확인하기 GET twitter/_stats 인덱스 샤드 및 세그먼트 정보 확인 GET twitter/_segments 인덱스 요약 정보 GET _cat/indices?v GET _cat/indices/twitter?v ","date":"2018-10-27","objectID":"/elasticsearch-lecture4/:1:5","tags":["elasticsearch"],"title":"Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"문서 색인 및 조회 인덱스는 미리 정의된 샤드 개수에 의해 나누어짐 한 번 설정한 샤드 개수는 변경 불가 문서는 인덱싱 할 때 랜덤한 string을 Document ID로 할당받거나 사용자가 정의한 Document ID로 생성된다. 사용자는 생성된 Document ID로 Document를 조회 할 수 있다. 샤드 할당 알고리즘 shard = hash(routing) % number_of_primary_shards 인덱싱의 필수 조건 primary shard가 항상 제일 먼저 writing되어야 한다. primary shard가 writing이 전부 완료된 이후에 replica shard로 복제한다. 인덱스 API 샤드 할당 알고리즘 PUT /\u003ctarget\u003e/_doc/\u003c_id\u003e PUT twitter/_doc/1 { \"user\" : \"kimchy\", \"post_date\" : \"2009-11-15T14:12:12\", \"message\" : \"trying out Elasticsearch\" } ","date":"2018-10-27","objectID":"/elasticsearch-lecture4/:1:6","tags":["elasticsearch"],"title":"Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"참고 Elasticsearch Reference - index modules ","date":"2018-10-27","objectID":"/elasticsearch-lecture4/:2:0","tags":["elasticsearch"],"title":"Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Elasticsearch 설치하기 Elasticsearch 는 Java 언어로 이루어진 아파치 Lucene 기반으로 이루어져 있다. 그러므로 설치를 위해서는 Java 가 먼저 설치되어 있어야 한다. ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:0","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"1. yum 으로 설치하기 RPM Repository 등록하기 /etc/yum.repos.d/elasticsearch.repo elastic 저장소를 수동으로 추가 한다. # /etc/yum.repos.d/elasticsearch.repo [elasticsearch-6.x] name=Elasticsearch repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md sudo yum install elasticsearch RPM Download 하여 설치하기 Elasticsearch RPM 다운로드 후 설치한다. elasticsearch의 user, group이 자동 생성 # rpm 파일 내려받기 wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.0.rpm rpm -ivh elasticsearch-6.4.0.rpm ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:1","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"2. zip, tar 다운로드하여 설치하기 Elasticsearch는 .zip 또는 .tar.gz 패키지로도 제공된다. 모든 시스템에 제한없이 가장 쉽게 설치할 수 있는 방법이다. root가 아닌 일반 계정으로만 설치 가능 rpm 설치와 비교했을 때 config, data가 추가로 생성 .zip 다운로드 및 설치하기 wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.zip unzip elasticsearch-6.4.2.zip tar.gz 패키지로 다운로드 및 설치하기 wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.tar.gz tar -xzf elasticsearch-6.4.2.tar.gz ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:2","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"3. Elasticsearch 실행하기 ./bin/elasticsearch # running as a daemon ./bin/elasticsearch -d -p pid Elasticsearch running 중 인지 확인하기 기동시 옵션으로 포트를 지정하지 않으면 기본 포트는 9200. curl 과같은 HTTP 요청으로 JSON 결과값이 올바르게 오는지 확인. curl http://localhost:9200 ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:3","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"4. Elasticsearch 서비스 시작하기 Elasticsearch 설정파일 Elasticsearch 의 3개의 설정파일이 존재한다. elasticsearch.yml : Elasticsearch 기본설정 jvm.options : Elasticsearch JVM 설정 log4j2.properties : Elasticsearch Logging 설정 elasticsearch.yml elasticsearch.yml 기본 설정 파일이다. YAML 형식으로 작성되어 있으며, 필요한 옵션을 수정할 수 있다. /etc/elasticsearch/elasticsearch.yml # data 파일 경로와 log 파일의 경로를 수정하기. path.data: /var/lib/elasticsearch path.logs: /var/log/elasticsearch 서비스 시작하기 # init 사용 service elasticsearch start # systemd 사용 systemctl start elasticsearch.service ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:4","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Kibana 설치하기 Kibana는 Elasticsearch의 오픈 소스 데이터 시각화 플러그인이다. Elasticsearch 클러스터에 인덱싱 된 데이터들을 시각화 하는 기능을 제공한다. ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:2:0","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"1. yum 으로 Kibana 설치하기 RPM Repository 등록 vi /etc/yum.repos.d/kibana.repo # /etc/yum.repos.d/kibana.repo [kibana-6.x] name=Kibana repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md yum 명령어로 install yum install kibana ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:2:1","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"2. Kibana 설정 Kibana서버는 시작할 때 kibana.yml에서 속성을 읽는다. kibana.yml은 배포파일(.zip/.tar.gz)로 설치한 경우 $KIBANA_HOME/config 에 위치하며 패키지 배포판 에서는 /etc/kibana 에 위치한다. kibana 서버는 기본적으로 localhost:5601 로 구동된다. kibana.yml 설정 vi /etc/kibana/kibana.yml server.host : 기본값 localhost. Back-end 서버의 host를 지정한다. elasticsearch.url : ES 의 인스턴스 URL kibana.index : 저장된 검색, 시각화 및 대시보드를 저장하기 위에 ES의 색인을 사용S하는데, 인덱스가 아직 없을 경우 키바나가 새 인덱스를 생성 server.host: \"localhost\" elasticsearch.url: “http://localhost:9200\" kibana.index: \".my-kibana\" ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:2:2","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"3. Kibana 서비스 시작하기 service kibana start ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:2:3","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"참고 Install Elasticsearch ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:3:0","tags":["elasticsearch","kibana"],"title":"Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Inverted Index 전통적인 데이터베이스는 필드당 하나의 값을 저장하기 때문에 전체 텍스트 검색에는 적합하지 않다. 즉 다중 값을 색인화 할 수 있어야 하는데, Elasticsearch 에서는 Inverted Index 형태의 인덱싱을 통해 Full-text Search 가 가능하도록 했다. 모든 문서에서 발생하는 모든 고유 값 또는 용어의 정렬된 목록을 포함하며, 각 용어에 대해 이를 포함하는 모든 문서 목록을 표시한다. Full-text Search (전체 텍스트 검색) 는 요청한 모든 단어를 문서 또는 데이터베이스에서 모든 단어와 비교하는 포괄적 인 검색 방법이다. 전체 텍스트 쿼리에는 간단한 단어와 구 또는 여러 형식의 단어나 구가 포함될 수 있으며, 텍스트 쿼리는 일치 항목이 하나 이상 있는 문서를 모두 반환한다. Inverted Index Term | Doc 1 | Doc 2 | Doc 3 | ... ------------------------------------ brown | X | | X | ... fox | X | X | X | ... quick | X | X | | ... the | X | | X | ... Inverted Index는 단어가 포함된 문서 목록 뿐만아니라 단어의 관련성 혹은 유사성 ( 각 단어를 포함하는 문서의 수, 특정 문서에 단어가 나타나는 횟수, 각 문서의 단어 순서, 각 문서의 길이, 모든 문서의 평균 길이 등) 의 정보를을 저장할 수 있으며 이러한 통계를 통해 중요도 혹은 어떤 문서(document)가 중요한지 결정할 수 있다. 초기에는 하나의 거대한 Inverted Index가 전체 문서 모음을 위해 디스크에 쓰여진다. 새 색인이 준비되게 되면 이전 색인이 바뀌고 최근 변경사항을 검색 할 수 있게 된다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture2/:1:0","tags":["elasticsearch"],"title":"Elasticsearch 개념 및 용어정리 - Inverted Index, Segment","uri":"/elasticsearch-lecture2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Immutable (불변성) 디스크에 쓰여진 Inverted Index 는 변경이 불가한 불변의(Immutable) 특성을 갖고 있다. 불변성의 이점 Data lock 을 걸 필요없이 일관성을 유지할 수 있다. : 동시에 변경을 시도하는 여러 프로세스에 대해 주의할 필요 없음. 전체 Index 가 버퍼 캐시에 로드 가능하다면, 변경이 없는 경우 항상 메모리에 로드된 상태이며 이는 File I/O 가 아닌 메모리 캐시를 통해 접근되므로 성능이 향상 된다. Inverted Index 를 작성하게 되면 데이터를 압축 할 수 있으므로 리소스 소모가 높은 디스크 I/O 를 줄이고 캐시하는데 필요한 RAM 의 용량을 줄일 수 있다. 불변성의 단점 말그대로 Update 가 불가능하다. 새 문서를 검색 가능하게 하려면 전체 색인을 다시 작성해야 한다. 다시 작성해야 하기 때문에 인덱스에 포함 할 수 있는 데이터 양이나 업데이트 빈도에 상당한 제한이 있다. 어떻게 불변성의 이점을 잃지 않고 Inverted Index를 갱신할 수 있을까? 전체 Inverted Index를 재작성하는 대신 변화된 데이터를 나타내는 새로운 보조 인덱스를 추가한다. 검색 요청이 발생하면, 가장 오래된 인덱스부터 시작하여 결과를 조합하여 리턴한다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture2/:1:1","tags":["elasticsearch"],"title":"Elasticsearch 개념 및 용어정리 - Inverted Index, Segment","uri":"/elasticsearch-lecture2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Segment shard는 다시 segment로 이루어진다. document가 인덱싱될 때 데이터는 시스템 버퍼 캐시 영역으로 적재되며 이후 디스크의 segment에 기록하게 된다. 이 과정에서 refresh를 거쳐야 commit point를 생성하며 검색 가능한 상태로 전환되게 된다. [그림1] Document 가 인덱싱 될 때 시스템 버퍼 캐시에 먼저 적재된다. [그림2] 이후, 디스크의 Segment 에 기록된다. 이 상태에서 refresh 를 거쳐야 commit point 가 생성되어 검색 가능한(searchable) 상태로 전환된다. Segment 는 하나의 Inverted Index를 의미하지만, commit point를 갖는 모든 추가된 Inverted Index를 의미한다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture2/:2:0","tags":["elasticsearch"],"title":"Elasticsearch 개념 및 용어정리 - Inverted Index, Segment","uri":"/elasticsearch-lecture2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"참조 Elasticsearch Reference - inside-a-shard Elasticsearch Reference - dynamic-indices ","date":"2018-10-20","objectID":"/elasticsearch-lecture2/:3:0","tags":["elasticsearch"],"title":"Elasticsearch 개념 및 용어정리 - Inverted Index, Segment","uri":"/elasticsearch-lecture2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Elasticsearch 클러스터 분산구성 시나리오 ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:0","tags":["elasticsearch"],"title":"Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"단일 노드에 3개의 샤드로 클러스터 구성하기 blogs라는 인덱스에 3개의 primary 샤드와 1개의 replica 샤드가 운용되도록 할당한다. curl -X PUT \"localhost:9200/blogs\" -H 'Content-Type: application/json' -d { \"settings\" : { \"number_of_shards\" : 3, \"number_of_replicas\" : 1 } } [그림1] 샤드의 개수는 3이고 레플리카 개수는 1개인 단일 노드 클러스터는 정상적으로 작동되나 하드웨어의 오류가 발생할 경우 데이터 손실의 위험이 있다. 데이터 적재량이 많을 경우 싱글노드가 허용하는 볼륨을 모두 소진할 수도 있어 더이상 적재가 불가능 할 수도 있다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:1","tags":["elasticsearch"],"title":"Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"모든 기본 노드에 복제본 샤드 할당 클러스터에 동일한 설정의 노드를 한대 더 투입한다. 두 번째 노드가 클러스터에 추가되면 각 기본 샤드에 대해 하나씩 3개의 Replica shard가 생성된다. 각 샤드에 대해 레플리카 샤드가 존재하기 때문에 모든 데이터는 손상되지 않는다. 새로 인덱싱 된 문서는 먼저 기본 샤드에 저장 된 다음 연결된 복제본 샤드에 병렬로 복제된다. [그림2] 모든 기본 노드에 replica shard 할당 ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:2","tags":["elasticsearch"],"title":"Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"수평 확장 애플리케이션 수요 증가에 따라 노드를 확장해야할 경우가 발생한다. Node3을 시작하게 되면 2개의 샤드가 Node3으로 이동되었으며, 각 하드웨어의 리소스 (CPU, RAM, I/O) 가 더 적은 수의 샤드에 공유되므로 각 샤드의 성능이 향상된다. [그림3] 부하 분산을 위한 샤드 재할당 ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:3","tags":["elasticsearch"],"title":"Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"좀 더 확장하기 기본 샤드의 수는 인덱스 생성되는 순간 고정된다. 이 숫자는 인덱스에 저장할 수 있는 최대 데이터 양을 정의한다. 그러나 읽기 요청은 기본 샤드나 레플리카 샤드에서 처리할 수 있으므로 더 많은 레플리카가 있을 수록 더 많은 검색량 처리가 가능하다. 레플리카 개수는 동적으로 변경이 가능하다. number_of_replicas를 1개에서 2개로 변경한다. # 레플리카 개수를 2개로 변경 PUT /blogs/_settings { \"number_of_replicas\" : 2 } [그림4] 레플리카 개수를 1개에서 2개로 변경 총 9개의 노드로 구성되어 있으며 3개의 primary shard와 6개의 replica shard가 존재하게 되었다. 위의 노드 구성을 통해 Node 2 개가 Fail 이 발생하여도 데이터의 손실은 막을 수 있다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:4","tags":["elasticsearch"],"title":"Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"실패에 대처하기 한대의 노드가 fail 발생했을 경우 [그림5] 한대의 노드가 fail이 발생했을 때 마스터 노드였던 Node 1번에 Fail이 발생한다면 가장먼저 노드간 새로운 마스터 노드를 선출한다. 남아있는 나머지 노드들의 replica shard가 primary shard로 승격되게 된다. Info [그림6] node1를 다시 active 상태로 변환 종료했던 Node1번을 다시 active 시키면 나머지 노드들이 primary shard를 복제하여 replica shard로 만든다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:5","tags":["elasticsearch"],"title":"Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"참고 Elasticsearch Reference - distributed cluster ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:2:0","tags":["elasticsearch"],"title":"Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Elasticsearch Elasticsearch 는 Apache Lucene 기반의 Full-Text 검색엔진 이며 분석엔진 이다. 고가용성(High Availability) 의 확장 가능한 오픈 소스이다. HTTP 웹 인터페이스와 스키마에서 자유로운 JSON 문서로 제공된다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:1:0","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"검색 엔진으로서의 Elasticsearch Elasticsearch 는 루씬 기반의 대중적인 엔터프라이즈 검색엔진으로, Apach 2.0 License 에 의거 오픈 소스로 출시 되었다. 또한 대부분의 루씬이 제공하는 기능들을 Eleasticsearch 에서도 제공한다. HTTP Web Interface와 Schema에 자유로운 JSON 형태의 도규먼트를 지원하는 준 실시간 분산형 검색엔진이다. Apache Lucene 정보검색(Information Retrieval, IR) 소프트웨어 검색 라이브러리 Apahce Software 재단의 검색엔진 상위 프로젝트 자바 언어로 개발되어 있다. 오픈소스 주요기능 사용자 위치 정보 이용 가능 다국어 검색 지원 자동 완성 지원 미리 보기 지원 철자 수정 기능 지원 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:1:1","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"분석 엔진으로서의 Elasticsearch Elasticsearch 는 검색엔진으로 단독으로 서비스 하지만, 몇 가지 솔루션을 추가하여 분석엔진으로서도 활용이 가능하다. 관련 솔루션 Kibana Elasticsearch로 수집된 데이터를 통계 및 집계하여 시각화 Beats 데이터 수집기. 서버 혹은 단말에 Agent 형태로 로그나 데이터 원본을 Elasticsearch로 전달 Logstash 직접 로그를 전달하거나 Beats 에서 데이터를 전달받아 파싱 혹은 필터링 하여 Elasticsearch 로 전달 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:1:2","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Elasticsearch의 용어 및 개념 정리 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:2:0","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Document 도큐먼트는 JSON (Javascript Object Notation) 형태의 Elasticsearch 의 기본 저장단위 이다. 관계형 데이터 베이스의 Row 와 비슷한 개념으로 볼 수 있다. 도큐먼트는 데이터에 적재될 때 Document ID 를 갖는다. Document ID 는 지정하지 않으면 랜덤하게 생성 되며, 사용자가 정의한 값으로도 생성 가능하다. Document ID 는 데이터를 찾아가는 Metadata 로 볼 수 있다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:2:1","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Index Index 는 비슷한 형질을 가지는 도큐먼트 간의 집합이다. 관계형 데이터 베이스의 Database 와 비슷한 개념으로 볼 수 있다. 여러 도큐멘트들이 하나의 인덱스에 적재된다. 인덱스 이름은 문서에 대한 인덱싱/검색/갱신/삭제 등을 수행할 때 참조값으로 사용된다. 인덱스는 사전에 정의되어야 할 데이터 타입이나, 특정한 구조가 필요하지 않다면 최초 데이터가 인입될 때 생성 된다. ex) 고객정보, 제품카탈로그, 주문정보 등… ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:2:2","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Type 관계형 데이터 베이스의 Table 과 비슷한 개념으로 볼 수 있다. 타입은 인덱스의 파티션으로 사용 된다. 하나의 인덱스에 도큐먼트를 저장할때 타입을 분리해서 인덱싱이 가능하다. Note ES 6.0.0 버전 부터는 Multi Type 을 지정이 deprecated 되었으며, 하나의 인덱스에는 단일 타입으로만 지정하도록 권고하고 있다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:2:3","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Cluster Elasticsearch는 클러스터로 구성되어 있다. 클러스터는 전체 데이터 (모든 노드) 간 통합 인덱싱 및 검색이 가능한 1개 이상의 노드(서버) 의 집합이다. 사용자는 이 클러스터를 통해 데이터를 저장하고 검색 요청을 할 수 있다. 클러스터는 고유의 cluster_name 과 cluster_uuid 를 갖는다. 클러스터 이름은 따로 지정하지 않으면 유니크한 이름으로 생성된다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:2:4","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Node 노드는 클러스터를 구성하는 단일 서버로써, 서로 헬스 체크를 하거나 실제 데이터를 저장하고 클러스터에 참여하여 인덱싱과 검색 역할을 수행한다. 노드는 각자의 노드 이름을 갖으며 노드가 기동될때 랜덤 UUID 를 갖는다. 노드는 역할에 따라 master node, data node, all node, client node 등으로 구성할 수 있다. Note 모든 노드는 클러스터의 다른 모든 노드에 대해 알고 있으며, 클라이언트 요청을 해당 노드로 전달할 수 있다. Node 종류 Node Description master node 클러스터를 제어하는 마스터 노드. 구성 노드들의 헬스 체크를 담당한다 data node 데이터를 저장하고 검색 및 집계와 같은 데이터 관련 작업을 수행한다 all node master 혹은 data 노드의 구분이 필요 없을 때 두가지 역할을 담당한다. 보통은 확장이 필요 없거나 요청 쿼리가 많지 않고 데이터를 오래 보관해야 하는 경우 구성한다 client node 쿼리만을 받기 위한 노드이며, 부하가 많거나 요청 쿼리량이 많을 때 부하 분산용으로 구성한다 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:2:5","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의 정리"],"content":"Shard shard는 인덱스 데이터를 나누는 단위 이다. 인덱스는 무한한 데이터 저장이 가능하며 인덱스 데이터가 단일 노드의 하드웨어 용량을 초과하여 더이상 데이터를 저장할 수 없게 되거나 CPU, 메모리 자원 초과로 인덱싱이나 검색 성능의 저하가 발생하는 문제가 발생 이와 같은 문제를 해결하기위해 ES에 도입된 개념이다. 샤딩의 특징 콘텐츠 볼륨의 수평(Horizontal) 분할 및 확장이 가능하다. 관계형 데이터베이스처럼 컬럼별로 나누는 것이 아닌 횡별로 나누어 샤드에 저장. 여러 샤드에 분산 배치하여 병렬화 함으로써 성능 및 처리량을 늘릴 수 있다. I/O 가 두배로 발생하여 인덱싱 성능이 저하된다. 디스크 볼륨 또한 실제 도큐먼트 용량의 두배가 필요하다. Shard 의 종류 Primary Shard Primary Shard 는 Indexing 되어 들어온 Document 의 원본 Shard 를 의미한다. Primary Shard 는 각 인덱스 별로 최소 1개 이상 존재 해야 한다. ElasticSearch 에 Document 가 인덱싱 될 때 가장 처음에 생성되는 샤드이다. 샤드 개수를 지정하지 않는다면 기본으로 5 개로 지정된다. Replica Shard Network / Cloud 환경의 샤드 노드가 오프라인 상태가 되거나 혹은 사라지게 될 경우를 대비하여 인덱스 샤드에 대해 하나 이상의 복사본을 생성할 수 있다. 이를 Replica Shard 라고 한다. ElasticSearch 에서 Primary Shard 가 인덱싱 된 후, Primary Shard 가 저장된 데이터 노드와는 다른 곳에 복제된다. Replica Shard 에도 넘버링을 하며, 어떤 Primary Shard 의 복제본인지 식별이 가능하다. replica 의 기본값은 1 인덱싱 시 Primary Shard 의 복제를 하는 과정이 추가된다. ES 플러그인 인 Head 로 각 노드에 샤드 dashboard를 확인 할 수 있다. Info Elasticsearch의 샤드는 Lucene 의 인덱스이며, 단일 Lucene 인덱스가 포함할 수 있는 도큐먼트의 최대 개수는 2,147,483,519 개 이다 Replica Shard 가 있기 때문에 샤드 혹은 노드의 오류가 발생하더라도 Elasticsearch 클러스터의 고가용성이 유지된다. 모든 Replica Shard에서 병렬 방식으로 검색을 실행할 수 있으므로 검색 처리량 확장 가능하다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:2:6","tags":["elasticsearch"],"title":"Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":null,"content":"author::riley title:: 대규모 서비스를 위한 AWS의 대표적인 NoSQL Database 서비스 알아보기 date::2022-01-20 10:12:47 tags:: #AWS #NoSQL #데이터베이스 ","date":"0001-01-01","objectID":"/archives/aws-nosql/:0:0","tags":null,"title":"","uri":"/archives/aws-nosql/"},{"categories":null,"content":"모던 애플리케이션과 데이터베이스 db-engines.com 인기순이 top 10 NoSQL JSON NoSQL데이터베이스의 확장성 트랜잭션과 보조 인덱스를 흡수하여 단점을 제거 하고 있다 - 릴레이션쉽 오픈 소스 데이터베이스를 더 많이 사용하고 있다. ","date":"0001-01-01","objectID":"/archives/aws-nosql/:1:0","tags":null,"title":"","uri":"/archives/aws-nosql/"},{"categories":null,"content":"모던 애플리케이션 사용자 글로벌, 다양한 디바이스와 데이터양이 많아졌다. 빠른 성능요구 빠르게, 무제한으로 확장이 가능 Amazon Prime Day ","date":"0001-01-01","objectID":"/archives/aws-nosql/:1:1","tags":null,"title":"","uri":"/archives/aws-nosql/"},{"categories":null,"content":"마이크로 서비스 아키텍처 하나의 모노리틱 서비스가 -\u003e 마이크로 서비스 구조에서는 각 데이터베이스 DevOps 형태로 각 마이크로 서비스 별로 2피자 팀구성 각 데이터베스별로 잘하는 것과 잘 못하는 것이 있다. -\u003e 내 워크로드에 맞는 ㅇ -\u003e 확장성, 성능 , 가용성 SQL or NoSQL SQL \u0026 NoSQL 내 서비스에 워크로드에 맞는 데이터베이스를 골라 사용해야 한다. 최근 모던 애플케이션은 혼용하여 사용 대용량 데이터 처리 SQL 튜닝 메인디비 scale up read replica로 분산 cache layer - redis -\u003e 동일한 결과 값이 나오는 경우 cahce layer cluster shard node -\u003e 여전히 어려움. 운영 어려움 DynamoDB 인프라 갖고 있고 이를 관리하는 것은 간단 PUT, GET QUERY 명령어를 사용해서 세부적인 서비스 Amazon DynamoDB, Amazon ElasticCache Redis Redis Blazing fast 다양한 자료구조 읽기 부하 분산을 위한 캐시 고정값을 중심으로 히트률이 높은 데이터를 인메모리 기반에 Redis 기반에 두고 사용 string redis사용할 수 있다. 세션스토어 저절한 TTL 시간과 함께 Redis 사용 별도의 세션스토에 Stateless한 상태로 만들어야 사용자 경험에는 변함이 없다 hash Redis 리더보드 실시간 정보 Redis Sorted Set 쉽게 구현 지리정보 앱 특정 거리 안에 있는 오브젝트 간 거리를 구할 수 있다. Redis Geo ","date":"0001-01-01","objectID":"/archives/aws-nosql/:1:2","tags":null,"title":"","uri":"/archives/aws-nosql/"},{"categories":null,"content":"9. RDS, Aurora \u0026 ElastiCache ","date":"0001-01-01","objectID":"/archives/aws-rds/:0:0","tags":null,"title":"","uri":"/archives/aws-rds/"},{"categories":null,"content":"AWS RDS RDS는 관계형 데이터 베이스 서비스 Relational Database Service 를 나타내며 SQL 쿼리 언어를 사용하는 데이터베이스를 위한 서비스이다. ","date":"0001-01-01","objectID":"/archives/aws-rds/:1:0","tags":null,"title":"","uri":"/archives/aws-rds/"},{"categories":null,"content":"RDS에서 제공하는 데이터베이스 Postgres MySQL MariaDB Oracle Microsoft SQL Server Aurora - AWS Proprietary database ","date":"0001-01-01","objectID":"/archives/aws-rds/:1:1","tags":null,"title":"","uri":"/archives/aws-rds/"},{"categories":null,"content":"EC2에 DB를 운용하지 않고 RDS 사용했을 때 이점 AWS RDS 데이터서비스 뿐만 아니라 여러 기타 서비스를 포함하고 있다. 프로비저닝 및 OS 패치 자동화 지속적 백업과 특정 timestamp 기준 복구 Point Time Restore 대시보드 모니터링 읽기 성능 향상을 위한 읽기 전용 레플리카 재해복구 DZ(Disaster Recovery) 를 위한 Multi AZ 셋업 가능 업그레이드를 위한 유지보수 확장성 (vertical and horizontal) EBS 스토리지 백업 (gp2 or io1) **⚠️ 그러나 인스턴스에 SSH를 따로 가질 수는 없다. ","date":"0001-01-01","objectID":"/archives/aws-rds/:1:2","tags":null,"title":"","uri":"/archives/aws-rds/"},{"categories":null,"content":"RDS Backup RDS에서는 자동으로 백업이 실행된다. ","date":"0001-01-01","objectID":"/archives/aws-rds/:2:0","tags":null,"title":"","uri":"/archives/aws-rds/"},{"categories":null,"content":"RDS 자동백업 매일 수행되는 데이터베이스 전체에 대한 백업 ","date":"0001-01-01","objectID":"/archives/aws-rds/:2:1","tags":null,"title":"","uri":"/archives/aws-rds/"},{"categories":null,"content":"ubuntu@ip-172-31-5-67:~/devops$ ssh-keygen -t rsa -C “yeonju.yoon@tysystems.com” Generating public/private rsa key pair. Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa): /home/ubuntu/.ssh/id_riley Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/ubuntu/.ssh/iid_riley. Your public key has been saved in /home/ubuntu/.ssh/iid_riley.pub. The key fingerprint is: SHA256:pWN3gazEalsETHSURFQtTIRwGpyZNnjKjIX6dk7jU5k yeonju.yoon@tysystems.com The key’s randomart image is: +—[RSA 2048]—-+ | . **XBB+. | | . o XBo.o.. | | . = +..+ +.. | |. . + + + . | | . ooS . . | | o +.E+ o . | | . = o. | | + | | . | +—-[SHA256]—–+ ","date":"0001-01-01","objectID":"/archives/devops/ci-cd/set-gitlab-jenkins/:0:0","tags":null,"title":"","uri":"/archives/devops/ci-cd/set-gitlab-jenkins/"},{"categories":null,"content":"EC2 ","date":"0001-01-01","objectID":"/archives/ec2/:0:0","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"목적 EC2를 좀 더 효율적으로 사용하는 방법에 대해 소개 ","date":"0001-01-01","objectID":"/archives/ec2/:1:0","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"Amazon EC2 기본 개념 container 환경의 오케스트레이션, 서버리스 환경도 제공 2006년 8월 출시 온디맨드 구매 방식만 존재 베어 메탈, ssd, 네트워크 기능 향상 On-demand 외에도 세이빙 플랜등을 통해 비용을 좀더 효율적으로 여러가지 폭 넓은 구매 옵션 ","date":"0001-01-01","objectID":"/archives/ec2/:2:0","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"Amazon EC2 Mac instances 제공 ","date":"0001-01-01","objectID":"/archives/ec2/:2:1","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"AWS License Manager 소프트웨어 공급 업체의 라이선스를 보다 쉽게 관리 라이선스를 중앙화하여 관리 온프로미스 라이센스도 제공 ","date":"0001-01-01","objectID":"/archives/ec2/:2:2","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"Processors and Accelerators 애플리케이션 및 워크로드에 맞는 적합한 프로세서 제공 ","date":"0001-01-01","objectID":"/archives/ec2/:2:3","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"AWS Gravition Processor 컴퓨팅에 집중된 워크로드 -\u003e 450개가 넘는 인스턴스 타입을 제공하고 있다. ","date":"0001-01-01","objectID":"/archives/ec2/:2:4","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"Amazon EC2 수명주기 ","date":"0001-01-01","objectID":"/archives/ec2/:2:5","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"나의 워크로드에 적합한 EC2 인스턴스 선택하기 EC2 인스턴스의 경우 지속적으로 모니터링하고 최적화 M 특정워크로드 - M의 경우 6 인스턴스세대 - 세대가 올라갈 수록 더 높은 성능 제공 d 추가기능 - d의 경우 disk 성능 인스턴스 크기 : xlarge vcpu T타입의 경우 크레딧을 통해 -\u003e ","date":"0001-01-01","objectID":"/archives/ec2/:3:0","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"EC2 인스턴스 타입에 대한 지속적인 최적화 비용효율적으로 EC2 자원을 효율적으로 사용하고 있는가 사용하고 있는 EC2자원이 워크로드 요구사항에 적합한가 ","date":"0001-01-01","objectID":"/archives/ec2/:4:0","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"AWS Compute Optimizer 비용을 줄이고 비용 및 성능 향상을 위한 권장 사항제공 EC2 ","date":"0001-01-01","objectID":"/archives/ec2/:4:1","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"스팟 인스턴스를 통한 유연한 확장 auto scaling I/O CPU 자원사용율에 따라 EC2 인스턴스수를 ","date":"0001-01-01","objectID":"/archives/ec2/:5:0","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":" EBS - SSD \u003e general purpse, st/sc 네트워크 기반으로 API를 통해 생성, EC2가 삭제되어도 ![[알아두면 쓸모 있는 EC2 이야기.pdf]] ","date":"0001-01-01","objectID":"/archives/ec2/:6:0","tags":null,"title":"","uri":"/archives/ec2/"},{"categories":null,"content":"gPRC 설정 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28 go install github.com/envoyproxy/protoc-gen-validate@v0.6.3 echo 'export GOPATH=$HOME/Go' \u003e\u003e $HOME/.zshrc echo 'export PATH=$PATH:$GOPATH/bin' \u003e\u003e $HOME/.zshrc ","date":"0001-01-01","objectID":"/archives/grpc/:0:1","tags":null,"title":"","uri":"/archives/grpc/"},{"categories":null,"content":"Strategyzer Over View ","date":"0001-01-01","objectID":"/archives/strategyzer/:1:0","tags":null,"title":"","uri":"/archives/strategyzer/"},{"categories":null,"content":"Strategyzer App Training 도서 블로그 도서 링크 참고 가치제안 캔버스 - 고객 분석 가치제안 캔버스 - 제품 분석 사업 모델 캔버스 - ","date":"0001-01-01","objectID":"/archives/strategyzer/:1:1","tags":null,"title":"","uri":"/archives/strategyzer/"},{"categories":null,"content":"가치제안 캔버스 불특정 다수에게 제품이나 서비스를 판매하기 위해 고객의 니즈를 파악 어떠한 고객을 타겟으로 할 건지 파악해야한다. 고객 고객을 이해하는 것 원으로 표현 ex) 겜블러 Job : 용도 - 게임한다 - 돈을 딴다. Gain(보상): - 잭팟이 터졌다. Pain(불만): - 온라인 게임은 신뢰할 수 없다. -\u003e 항목이 많아질 경우 우선순위가 높은 것을 원 안으로 -\u003e 가설에 대한 검증을 계속 제품 상자로 표현 고객항목에서 작성한 내용을 대칭되는 항목을 작성 ","date":"0001-01-01","objectID":"/archives/strategyzer/:1:2","tags":null,"title":"","uri":"/archives/strategyzer/"},{"categories":null,"content":"사업모델 캔버스 - 9 block diagram Relationship - Customer 와 Product에 관계 Channel - ex. Web, Mobile Product, Relationship, channel, customer -\u003e 고객과의 관계 Partner - ex CATS, Activity - 마케팅, 사업을 영위하기 위해서 핵심적인 활동 Resources - Studio, 사업을 영위하기 위해서 핵심적인 자산 Cost(비용), Revenue(수입) 100 page 사업기획서는 의미 없음 가치제안 캔버스, 사업모델 캔버스 Hypotheses - 가설 Experments - 실험 Evidence - 증거 Insights ","date":"0001-01-01","objectID":"/archives/strategyzer/:1:3","tags":null,"title":"","uri":"/archives/strategyzer/"}]