[{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":" Go 언어를 활용한 네트워크 프로그래밍 책 정리 ","date":"2023-04-10","objectID":"/network-programming-with-go-copy/:0:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 3. 신뢰성 있는 TCP 데이터 스트림","uri":"/network-programming-with-go-copy/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"TCP를 신뢰성 있게 만드는 것 패킷손실packet loss : 무선 네트워크 간섭이나 네트워크 정체 등의 이유로 데이터가 전송에 실패하여 목적지까지 도달하지 못한 경우 발생 네트워크 정체network congestion : 네트워크의 연결상 처리할 수 있는 양 이상의 데이터를 전송하려 할 때 발생 TCP는 흐름제어 flow control 절차를 통해 데이터의 전송 속도를 조정하여 네트워크의 상태가 변경되더라도 손실된 패킷을 최소로 유지하면서 데이터를 빠르게 전송할 수 있다. TCP는 수신한 패킷을 추적하고, 승인되지 않은 패킷은 필요에 따라 재전송 한다. 흐름제어, 재전송과 함께 이러한 속성들은 TCP가 패킷 손실의 문제를 해결하고 데이터의 전송의 신뢰도를 높여준다. ","date":"2023-04-10","objectID":"/network-programming-with-go-copy/:1:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 3. 신뢰성 있는 TCP 데이터 스트림","uri":"/network-programming-with-go-copy/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"TCP 세션 사용 TCP 세션을 사용하면 어떠한 크기의 데이터 스트림이라도 전송할 수 이으며 데이터가 정상적으로 수신되었다는 것을 확인할 수 있다. TCP 세션은 두 노드간 대화라고 생각할 수 있다. ","date":"2023-04-10","objectID":"/network-programming-with-go-copy/:2:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 3. 신뢰성 있는 TCP 데이터 스트림","uri":"/network-programming-with-go-copy/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"TCP 핸드셰이크를 통한 세션 수립 TCP 연결은 두 노드 사이에 3방향 핸드셰이크 three-way handshake라 부르는 과정을 통해 진행된다. TCP 세션이 수립되려면 서버는 반드시 연결 요청을 수신 대기하고 있어야 한다. 클라이언트는 SYNsynchronize 플래그가 설정된 패킷을 서버로 전송한다. 이 SYN 패킷은 서버에게 클라이언트의 정보와 이후 통신에서 사용할 슬라이딩 윈도 설정값을 알려준다. 서버는 ACKAcknowledgement 플래그와 SYN 플래그가 설정된 패킷을 클라이언트로 전송한다. ACK 플래그는 클라이언트가 보낸 SYN 패킷을 정상적으로 수신하였다는 의미이다. 서버의 SYN 패킷은 클라이언트가 보낸 SYN 패킷의 설정 값에서 어떤 설정 값을 통신 중에 사용할지 클라이언트에게 통보한다. 클라이언트는 서버의 SYN 패킷을 승인한다는 ACK 패킷을 보내며 3방향 핸드셰이크가 완료된다. 3방향 핸드셰이크가 완료되면 TCP 세션이 수립되며 이후 두 노드는 데이터를 주고받을 수 있다. ","date":"2023-04-10","objectID":"/network-programming-with-go-copy/:2:1","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 3. 신뢰성 있는 TCP 데이터 스트림","uri":"/network-programming-with-go-copy/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"시퀀스 번호를 이용한 패킷 수신 확인 ","date":"2023-04-10","objectID":"/network-programming-with-go-copy/:2:2","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 3. 신뢰성 있는 TCP 데이터 스트림","uri":"/network-programming-with-go-copy/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":" Go 언어를 활용한 네트워크 프로그래밍 책 정리 컴퓨터 네트워크(coumputer network) 란 두 개 이상의 장치 또는 노드간의 연결을 말한다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:0:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"네트워크 토폴로지 유형 네트워크 토폴로지topology 란 네트워크상의 노드의 구성을 말한다. 토폴로지의 유형은 점대점 연결형, 데이지 체인형, 버스형, 링형, 스타형, 그물형의 6가지 기본 범주로 나뉜다. 1. 점대점 point-to-point 연결형 두 노드가 하나의 연결을 공유 한다. 이러한 유형의 네트워크 연결을 드물지만 두 노드 간에 직접 통신이 필요할 때 매우 유용하다. 2. 데이지 체인 daisy chain 연결형 일련의 점대점 연결 출발지 노드와 목적지 노드 사이의 중간 노드를 일반적으로 홉이라고 한다. 3. 버스형 bus 버스형 토폴로지상의 노드들은 공통, 공유 네트워크 링크를 갖는다. 주로 무선 네트워크에서 사용 되며 유선 네트워크상의 노드는 모든 트래픽을 보고 자신에게 필요한 트래픽만을 선택적으로 무시하거나 수신한다. 무선 네트워크상의 노드들 또한 서로의 트래픽을 볼 수 있지만 일반적으로는 암호화 되어 있다. 4. 링형 ring 데이터가 단일 방향으로 이동하는 폐쇄 루프 이다. 노드 N은 노드 O -\u003e P -\u003e Q를 통해 R로 메세지를 전송한다. 중간 노드에서 메시지를 전송하지 못하면 전송된 메세지는 목적지에 도달하지 않는다. 가장 느린 노드의 속도로 제한된다. 5. 스타형 start 중앙 노드는 다른 모든 노드에 개별 점대점을 연결한다. 유선 네트워크는 대부분 스타형 토폴로지 형태이다. 중앙 노드는 종종 네트워크 스위치 이며, 이는 데이터를 수신하여 목적지 노드로 데이터를 재전송하는 장치이다. 스타형 토폴로지에서는 단 하나의 홉만 이동한다. 6. 그물형 mesh 모든 노드는 다른 모든 노드와 직접 연결된다. 단일 장애 지점 (Single Point Of Failure, SPOF) 제거 : 단일 노드의 장애 시 다른 노드 간 트래픽에 영향을 주지 않는다. 노드 수가 증가함에 따라 복잡성이 증가하기 때문에 대규모 네트워크에서는 사용할 수 없다. 7. 하이브리드 hybrid 토폴로지 둘 이상의 기본적인 토폴로지를 결합한 형태 보통 하나의 네트워크 토폴로지만 구성된 경우는 거의 없으며 대부분 하이브리드 토폴로지의 형태로 구성하고 있다. 각 토폴로지의 장점을 활용하고 단점을 개별 네트워크 세그먼트로 제한하여 안정성, 확장성 및 유연성을 향상할 수 있다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:1:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"대역폭 vs 레이턴시 ","date":"2023-03-07","objectID":"/network-programming-with-go/:2:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"네트워크 대역폭 bandwith 네트워크 대역폭 이란 일정 시간 내에 네트워크 연결을 통해 전송할 수 있는 데이터의 양을 의미한다. 대역폭이 높다고 해서 반드시 성능이 좋은 것은 아니다. 대역폭이 낮더라도 레이턴시가 작은 경우가 대역폭이 높지만 큰 레이턴시를 갖는 네트워크보다 성능이 더 좋을 수 있다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:2:1","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"네트워크 레이턴시 latency 네트워크 레이턴시는 네트워크 리소스 요청을 보내고 응답을 받는 사이에 측정된 시간이다. 레이턴시가 크면 나쁜 사용자 경험을 제공하게 되며, 종종 악의적인 공격자들에 의해 DDos 공격을 받을 수도 있다. 웹사이트에서 레이턴시는 클라이언트와 서버간 레이턴시, 데이터 저장소에서 데이터 검색하는데 걸리는 시간, 서버 측에서 동적인 콘텐츠를 컴파일하는 데 걸리는 시간, 웹 브라우저가 페이지를 렌더링하는 데 걸리는 시간 등 다양한 이유로 발생한다. 레이턴시 해결 방법들 CDN(Content Delivery Network) 이나 클라우드를 사용하여 사용자와 서비스 사이의 거리와 홉 수를 줄인다. 요청 및 응답 크기를 최적화하여 레이턴시를 줄일 수 있다. 캐싱 전략을 수립하여 성능을 크게 개선할 수 있다. 동시성, 병행성을 통하여 응답이 블로킹 되는 것을 최소화한다. (Go 언어의 고루틴 등을 활용) ","date":"2023-03-07","objectID":"/network-programming-with-go/:2:2","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"OSI(Open Systems Interconnection) 참조 모델 개방형 시스템 상호 연결(OSI) 모델은 프로토콜의 개발과 통신을 위한 프레임워크 역할을 한다. 프로토콜 (protocol) 이란 네트워크를 통해 전송되는 데이터의 포맷과 순서를 결정하는 규칙 혹은 절차를 의미한다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:3:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"OSI 참조 모델의 계층 구조 레이어 OSI 참조 모델은 네트워크 내의 모든 활동을 7개의 계층으로 구성된 엄격한 계층 구조로 추상화하였다. 7 계층(애플리케이션 계층) 네트워크 애플리케이션과 라이브러리는 대부분 애플리케이션 계층과 상호 작용한다. 호스트를 식별하고 리소스를 검색하는 역할을 담당한다. 웹 브라우저, 비트토렌트 클라이언트 등이 있다. 6계층 (프레젠테이션 계층) 데이터가 아래 계층으로 이동할 때 네트워크 계층에 대한 데이터를 준비하고, 데이터가 스택 위로 이동할 때 애플리케이션 계층에 데이터를 제공한다. 암호화, 암호 해독 및 데이터 인코딩이 있다. 5계층 (세션 계층) 네트워크의 노드 간의 연결 수명 주기를 관리한다. 연결 수립, 연결 시간 초과 관리, 작동 모드 조정, 연결 종료 등의 기능 담당 일분 7계층의 프로토콜은 5계층에서 제공하는 서비스에 의존한다. 4계층 (전송 계층) 전송의 안정성을 유지하면서 두 노드 간 데이터의 전송을 제어하고 조정한다. 데이터의 전송이 신뢰성을 유지하기 위해 에러 수정, 데이터 전송 속도 제어, 데이터 청킹 및 분할, 누락된 데이터 재전송, 수신 데이터 확인 과정등이 포함된다. 수신자가 데이터 수신을 인정하지 않은 경우 이 계층의 프로토콜이 데이터를 재전송한다. 3계층 (네트워크 계층) 노드 간 데이터를 전송하는 역할을 한다. 원격 노드에 직접 연결하지 않고도 네트워크 주소로 데이터를 전송할 수 있다. 네트워크 계층에서는 전송의 신뢰성이나 전송 에러등을 전송자에게 알려주기 위한 별도의 프로토콜이 필요하지 않는다. 라우팅, 주소 지정, 멀티 캐스팅 및 트래픽 제어와 관련된 네트워크 관리를 위한 프로토콜의 중심 2계층 (데이터 링크 계층) 직접 연결된 두 노드 간 데이터 전송을 처리한다. 시스템에서 스위치로, 스위치에서 다른 시스템으로 데이터를 쉽게 전송할 수 있도록 지원한다. 데이터 링크 계층에서의 프로토콜은 물리 계층의 에러를 식별하여 수정을 시도한다. 1계층 (물리 계층) 네트워크 스택에서 발생한 비트를 하위의 물리적 매체가 제어할 수 있는 전기, 광학 또는 무전 신호로 변환하고 타 노드의 물리적 매체에서 받은 신호를 다시 비트로 변환한다. 비트 전송률을 제어한다. 비트 전송률은 데이터의 최대 제한 속도이다. 초당 1기가 비트의 비트 전송률은 출발지와 목적지 사이에 초당 최대 10억 비트의 데이터가 이동할 수 있음을 의미한다. BPS 네트워크의 전송 속도를 계산할 때는 1초당 전송할 수 있는 0과 1, 즉 비트의 수를 센다. 네트워크 전송 속도는 초당 비트 단위로 측정된다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:3:1","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"데이터 캡슐화를 사용한 트래픽 전송 ","date":"2023-03-07","objectID":"/network-programming-with-go/:4:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"캡슐화 (encapsulation) 캡슐화는 구현의 세부 정보를 숨기고 관련한 기타 세부 정보만 사용할 수 있도록 하는 방법 우체국에 소포를 보내는 것과 비슷하다. 봉투가 내용물을 캡슐화하고 봉투에는 도착할 목적지 주소와 수취인 정보, 목적지까지 거쳐가는 정보등의 중요 정보만 기록한다. 소포의 내용물은 소포를 전송하는 것과 무관하며 운송에 중요한 것은 소포의 기타 세부 정보일 뿐임 데이터가 스택을 따라 이동할 때 하위 계층에 의해 캡슐화 된다. 스택을 따라 이동하는 데이터를 페이로드 혹은 메세지 본문(message body) 이라고도 하며 서비스 데이터 단위(Service Data Unit, SDU) 라는 용어를 사용하기도 한다. 페이로드는 프레젠테이션 계층에서 캡슐화 한다. 페이로드가 스택 위로 이동하면 각 레이어는 이전 레이어에서의 헤더 정보를 제거하게 된다. OSI 프로토콜 캡슐화 클라이언트와 서버가 모두 웹 콘텐츠를 교환하는 데 사용하는 7계층 프로토콜인 하이퍼 텍스트 전송 프로토콜(HTTP/1) 프로토콜도 데이터 캡슐화를 사용한다. HTTP는 클라이언트의 7계층에서 서버의 7계층으로 전송하는 헤더 정보를 포함한 전체 메세지를 정의한다. 네트워크 스택은 클라이언트의 요청을 HTTP 서버 애플리케이션에 전달하고 HTTP 서버는 네트워크 스택에 대한 응답을 시작하여 7계층 페이로드 생성 후 클라이언트의 7계층 애플리케이션으로 다시 전송한다. 수평 통신(horizontal communication) 동일 계층 내 클라이언트와 서버 간 통신을 수평 통신이라고 한다. 동일 계층 내에서 직접 데이터를 전송하는 것이 아니라 실제 데이터는 클라이언트 네트워크 스택에 따라 하위 계층으로 이동 후 서버의 네트워크 스택을 따라 상위 계층으로 이동하게 된다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:4:1","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"클라이언트와 서버간 발생한 7계층의 HTTP 요청 출발지 노드의 어떤 계층에서 전송된 데이터는 목적지 노드의 동일한 계층에 도달하게 된다. 클라이언트와 서버 간에 발생한 7계층 HTTP 요청 7 계층 데이터 HTTP 송신 과정 클라이언트의 6계층이 7계층의 페이로드를 수신 후 헤더로 페이로드를 캡슐화 후 6계층의 페이로드 생성 5계층은 6계층의 페이로드를 수신하고 자체적으로 헤더를 추가하여 4계층 페이로드를 전송한다. 4계층인 전송 프로토콜 TCP의 페이로드는 세그먼트 혹은 데이터그램이라고 한다. TCP는 5계층으 페이로드를 받아서 헤더를 추가하고 세그먼트를 3계층으로 전송 3계층의 인터넷 프로토콜은 TCP의 세그먼트를 수신후 이를 헤더와 함께 캡슐화하고 3계층 페이로드인 패킷을 생성한다. 2계층에서는 3계층으로부터 패킷을 수신하고 헤더와 푸터를 추가하여 페이로드를 만드는데 이 페이로드를 프레임이라고 한다. 2계층의 헤더로부터 수신자의 IP 주소를 네트워크 인터페이스에 할당된 고유 식별자인 미디어 접근 제어 주소로 변환. 푸터에는 에러를 감지하는데 도움이 되는 체크섬인 프레임 검사 시퀀스 FCS가 포함되어 있다. 1계층에서는 2계층의 페이로드를 비트 형태로 받고 비트를 서버로 전송한다. 7 계층 데이터 HTTP 수신 과정 1계층은 비트를 수신하여 프레임으로 변환 후 프레임을 2계층으로 전송 2계층은 프레임에서 헤더와 푸터를 제거하고 패킷을 3계층으로 전달 페이로드가 7계층에 도달할 때까지 각 레이어에서 진행한 캡슐을 역순으로 진행 최종적으로 HTTP 서버는 네트워크 스택에서 클라이트의 요청을 수신하게 된다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:4:2","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"TCP/IP 모델 전송 프로토콜(TCP)와 인터넷 프로토콜(IP)의 이름을 딴 TCP/IP는 종단 간의 연결을 원칙end-to-end principle 으로하는 네트워크이다. OSI 참조 모델과 마찬가지로 TCP/IP는 추상적인 기능을 위해 계층 캡슐화에 의존한다. 애플리케이션 계층, 전송 계층, 인터넷 계층, 링크 계층의 총 네 개의 계층으로 구성된다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:5:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"애플리케이션 계층 OSI의 애플리케이션 계층과 마찬가지로 소프트웨어 애플리케이션과 직접 상호 작용한다. TCP/IP의 애플리케이션 계층은 OSI 모델의 애플리케이션 계층, 프레젠테이션 계층, 세션 계층 세 개의 계층을 포함한다. 애플리케이션 계층의 프로토콜로는 HTTP, FTP(파일 전송 프로토콜), SMTP(단순 메일 전송 프로토콜), DHCP(동적 호스트 구성 프로토콜), DNS(도메인 네임 시스템) 가 있다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:5:1","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"전송 계층 OSI 모델과 마찬가지로 두 노드간 데이터 전송을 처리한다. 전송 계층의 프로토콜은 출발지에서 전송된 모든 데이터가 목적지로 데이터 무결성을 보장하며 완전하고 올바르게 전송되도록 한다. TCP 프로토콜의 무결성은 중복된 데이터나 누락된 데이터 없이 목적지에 수신한 데이터의 순서가 정확하다는 의미이다. TCP, UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜) UDP의 경우 더 빠른 전송처리를 위해 세그먼트의 에러 수정, 흐름제어, 재전송 및 전송 확인등의 기능을 애플리케이션에서 직접 구현해야 한다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:5:2","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"인터넷 계층 출발지 노드와 목적지 노드 사이의 상위 계층에서 데이터 패킷을 라우팅하며 종종 이기종 물리적 매체를 사용하는 여러 네트워크를 통해 라우팅한다. OSI의 3계층인 네트워크 계층과 동일한 기능을 가지고 있다. TCP/IP 계층의 호스트 식별 및 라우팅을 제공하는 프로토콜 인터넷 프로토콜 버전 4(ipv4) 인터넷 프로토콜 버전 6(ipv6) 경계 경로 프로토콜(Border Gateway Protocol, BGP) 인터넷 제어 메시지 프로토콜 ICMP 인터넷 그룹 관리 프로토콜 IGMP 인터넷 프로토콜 보안 IPsec ","date":"2023-03-07","objectID":"/network-programming-with-go/:5:3","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"링크 계층 OSI 참조 모델의 1계층과 2계층에 해당한다. TCP/IP 프로토콜의 핵심적인 부분과 물리적인 매체 사이의 인터페이스이다. ARP(Address Resolution Protocol, 주소 결정 프로토콜) 노드의 IP 주소를 네트워크 인터페이스의 MAC 주소로 변환한다. 일부 TCP/IP 구현에는 링크 계층 프로토콜이 포함되어 있지 않다. 아날로그 모뎀의 ISP에 직렬 연결을 맺었는데 이러한 직렬 연결에는 직렬 드라이버 또는 모뎀을 통한 링크 계층의 기능이 포함되어 있지 않았으며 이러한 기능을 위해 SLIP(직렬 회선 인터넷 프로토콜), PPP(점대점 프로토콜)와 같은 링크 계층의 프로토콜을 사용해야만 했다. ","date":"2023-03-07","objectID":"/network-programming-with-go/:5:4","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Go 언어를 활용한 네트워크 프로그래밍"],"content":"참조하기 OSI 참조 모델 ","date":"2023-03-07","objectID":"/network-programming-with-go/:6:0","tags":["GO"],"title":"[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요","uri":"/network-programming-with-go/"},{"categories":["Flutter"],"content":"플러터 구글에서 개발한 공개 모바일 SDK 이다. 모바일 앱을 만들기 위한 기존 방식은 안드로이드와 IOS를 별도로 구현하여 배포해야했기에 요구되는 기술 스펙과 비용이 컸으나 플러터를 사용하면 한번의 구현으로 배포가 가능하다. 플러터는 렌터링 엔진, UI 컴포넌트, 테스트 프레임워크, 도구, 라우터 등 앱 제작에 필요한 기능을 모두 제공하므로 개발자는 앱 구현에 집중하여 생산성을 높일 수 있다. ","date":"2023-02-16","objectID":"/flutter/:1:0","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"플러터가 Dart 언어를 사용하는 이유 다트는 JIT(just-in-time), AOT(ahead-of-time) 컴파일을 모두 지원한다. AOT 컴파일러는 다트 코드를 효율적인 네이티브 코드로 바꾸어 개발자 및 사용자가 모두 빠르게 사용할 수 있다. 다트의 선택형 JIT 컴파일러는 핫 리로드hot reload를 지원해 빠른 개발 속도와 반복iteration을 가능하게 해 생산성을 높여준다. 다트는 객체지향 언어이기에 마크업 언어를 사용하지 않고 다트 언어만으로 UI/UX 를 쉽게 구현할 수 있다. 기존 자바, C 등의 파생언어들과 유사해 생산성이 좋고 예측이 가능하다. 기존 다른 언어에 익숙할 수록 쉽게 접근이 가능하다. 다트의 최초 목적은 웹 개발언어였으며 자바스크립트를 대체하려고 만들었다가 방향을 틀어 컴파일러로 구현되었는데 이는 다트의 모든 기능이 자바스크립트로 표현이 가능하다. 모듈을 지원하지 않고 오직 객체지향을 기반으로 한다. ","date":"2023-02-16","objectID":"/flutter/:1:1","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"다른 모바일 개발 옵션 ","date":"2023-02-16","objectID":"/flutter/:2:0","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"네이티브 개발 (안드로이드, iOS) 앱을 가장 완벽하게 제어 가능하며 디버깅 도구, 성능을 100% 활용 가능하다. 그러나 플랫폼 별로 앱을 구현해야 한다. ","date":"2023-02-16","objectID":"/flutter/:2:1","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"자바스크립트 기반 크로스 플랫폼 web view, react native 와 같은 자바스크립트 기반의 크로스 플랫폼을 사용하는 방법도 있다. 네이티브 개발 경험이 없지만 최신 자바스크립트 기술을 어느정도 파악하면 웹개발자도 모바일 앱 개발에 참여할 수 있는 장점이 있다. 단점으로는 자바스크립트 다리 Javascrtip birdge을 꼽을 수 있다. 자바스크립트 다리 Javascrtip birdge 웹뷰WebView는 웹킷Webkit(브라우저 렌더링 엔진)으로 구동되는데 웹킷에서 DOM을 처리하는 일의 비용이 높고 성능이 좋지 않은 문제가 있다. 자바스크립트가 네이티브 코드와 직접 통신할 수 있도록 자바스크립트 다리를 만들어 이런 문제를 해결하였으며 DOM을 사용하지 않아 속도도 개선이 되었다. 하지만 앱이 렌더링 엔진과 소통할 때마다 다리 건너 코드를 네이티브 코드로 컴파일 해야 한다. ","date":"2023-02-16","objectID":"/flutter/:2:2","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"플러터의 장점 ","date":"2023-02-16","objectID":"/flutter/:3:0","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"자바스크립트 다리가 없다. 크로스 플랫폼 기술로 앱을 개발할 때 자바스크립트 다리를 사용하는데 이에 필요한 비용이 상당히 높기에 앱의 최적화및 디버깅이 힘들다. 플러터는 자체 렌더링 엔진을 이용하기에 실제 네이티브 코드로 컴파일하여 크롬이 사용하는 렌더링 엔진(Skia)을 사용하기에 실행 시 다트를 변환하지 않는다. 그렇기에 앱의 최적화가 더 유리하다. ","date":"2023-02-16","objectID":"/flutter/:3:1","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"컴파일 시간 플러터의 전체 컴파일 시간은 30초에서 최대 1분을 넘기지 않는다. 핫 리로드를 제공해서 개발 주기를 높혀 높은 생산성을 보장한다. ","date":"2023-02-16","objectID":"/flutter/:3:2","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"한번에 여러 플랫폼에 배포가 가능하다. IOS와 안드로이드를 플러터와 다트를 사용해 한 번만 구현하면 동시에 배포가 가능하다. 다트와 플러터 모두 유닛 테스트 라이브러리를 제공한다. ","date":"2023-02-16","objectID":"/flutter/:3:3","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"코드 공유 및 유지보수 플러터 기술은 자바스크립트로도 가능하기 때문에 웹과 모바일 앱은 클라이언트 뷰를 제외하고 모든 코드 공유가 가능하다. DI를 사용하면 앵귤러 다트앱과 플러터 앱에 같은 모델과 컨트롤러를 사용할수도 있다. IOS와 안드로이드는 필연적으로 모든 코드를 공유한다. 덕분에 팀의 생산성을 극대화 할 수 있다. ","date":"2023-02-16","objectID":"/flutter/:3:4","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"플러터 동작 원리 넓은 의미로 플러터는 웹의 리액트처럼 리액티브, 선언형, 조합할 수 있는 뷰 계층 라이브러리이다. (플러터는 렌더링 엔진도 포함하므로 실제로는 리액트 + 브라우저) 플러터는 위젯이라는 작은 컴포넌트를 조합해 모바일 UI를 만든다. 플러터의 대부분의 것은 위젯이며 위젯 뷰를 묘사하는 것은 다트 클래스이다. 앱의 모든 UI들(리스트, 제품, 버튼, 이미지)은 위젯으로 구성되어있다. 위젯은 상태를 갖을 수 있다. 위젯의 상태가 변경되면 프레임워크가 이를 인지하고 새 트리를 기존 트리와 비교한 다음 갱신해야 하는 위젯을 처리하게 된다. ex 수량 위젯의 + 버튼을 누르면 내부 상태가 바뀌면서 갱신해야 하는 위젯(수량을 나타내는 텍스트 위젯)을 갱신한다. ","date":"2023-02-16","objectID":"/flutter/:4:0","tags":["Dart","Flutter"],"title":"[Flutter] Flutter 개념 및 동작 원리","uri":"/flutter/"},{"categories":["Flutter"],"content":"Widget Widget은 모두 불변의 법칙을 가지고 있다. 그러나 위젯의 값을 변경해야 할 경우가 생긴다. 변경이 필요할 경우 기존 위젯을 삭제해버리고 완전 새로운 위젯으로 대체한다. ","date":"2023-02-03","objectID":"/flutter-beginner/:1:0","tags":["Dart","Flutter"],"title":"[Flutter Beginner] StatefulWidget","uri":"/flutter-beginner/"},{"categories":["Flutter"],"content":"StatelessWidget Life Cycle Constructor로 생성이되고 생성이 되자마자 build 함수가 실행된다. 변경이 필요하면 새로운 위젯을 만든다. StatelessWidget은 라이프 사이클 동안 단 한번만 build 함수를 실행한다. StatefulWidget 생명주기 Construct createState : State를 생성 initState : State를 초기화. State가 생성될 때 단 한번만 호출된다. didChangeDependencies dirty 상태 : 변경이 필요한 상태를 의미한다. build : 위젯을 화면에 그려준다. clean : didUpdateWidget, setState deactivate : 거의 사용하지 않음 dispose 파라미터가 변경되었을 때 생명주기 기존 위젯은 삭제된다. 새로운 StatefulWidget이 생성되고 Constructor가 실행 기존 State 찾는다. didUpdateWidget : clean 상태인 상태에서 실행된다. dirty 상태로 변경한다. 변경된 값을 기반으로 build 실행 clean 상태로 변경된다. setState가 실행될 때 생명주기 clean인 상태에서 setState를 실행한다. dirty 상태로 변경되고 build가 재실행된다. clean 상태로 다시 변경 ","date":"2023-02-03","objectID":"/flutter-beginner/:1:1","tags":["Dart","Flutter"],"title":"[Flutter Beginner] StatefulWidget","uri":"/flutter-beginner/"},{"categories":["Flutter"],"content":"APP HTTP 접근 허용 설정하기 ","date":"2023-01-31","objectID":"/ios-allow/:1:0","tags":["Flutter","iOS","Android"],"title":"[iOS/Android] APP HTTP 접근 허용하기","uri":"/ios-allow/"},{"categories":["Flutter"],"content":"iOS ios/Runner/Info.plist \u003ckey\u003eNSAppTransportSecurity\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSAllowsLocalNetworking\u003c/key\u003e \u003ctrue/\u003e \u003ckey\u003eNSAllowsArbitraryLoadsInWebContent\u003c/key\u003e \u003ctrue/\u003e \u003c/dict\u003e \u003c/dict\u003e \u003c/plist\u003e ","date":"2023-01-31","objectID":"/ios-allow/:1:1","tags":["Flutter","iOS","Android"],"title":"[iOS/Android] APP HTTP 접근 허용하기","uri":"/ios-allow/"},{"categories":["Flutter"],"content":"Android android/app/src/main/AndroidManifest.xml \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.web_view\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e \u003c!-- 추가 --\u003e \u003capplication android:label=\"web_view\" android:name=\"${applicationName}\" android:icon=\"@mipmap/ic_launcher\" android:usesCleartextTraffic=\"true\"\u003e \u003c!-- 추가 --\u003e ","date":"2023-01-31","objectID":"/ios-allow/:1:2","tags":["Flutter","iOS","Android"],"title":"[iOS/Android] APP HTTP 접근 허용하기","uri":"/ios-allow/"},{"categories":["Flutter"],"content":" 😊 Dart 기본 문법의 헷갈리는 부분과 몰랐던 부분 정리! 🐸🐸 ","date":"2023-01-24","objectID":"/dart/:0:0","tags":["Dart","Flutter"],"title":"[Dart] Dart 문법 정리","uri":"/dart/"},{"categories":["Flutter"],"content":"Final 과 const final과 const 키워드를 사용하여 선언하면 할당한 값을 변경할 수 없다. 둘다 상수를 선언할 때 사용하지만 차이점은 const는 complie-time에 상수를 설정하며 final은 runtime시에 결정되는 값도 상수로 설정할 수 있다. // error const DateTime now1 = DateTime.now(); // error! const는 runtime시에 값이 결정되는 값은 설정할 수 없다. final DateTime now2 = DateTime.now(); // final은 runtime시에 결정되는 값도 설정 가능하다. Note Instance variables는 final 일 수 있지만 const는 사용할 수 없음 const는 complie-time에 사용할 상수를 선언한다. 만약 클래스 레벨에서 const를 사용할 때는 static const를 사용면 된다. const로 선언한 상수에 대한 산술연산 등의 결과 또한 const 상수여야 한다. const bar = 1000000; // Unit of pressure (dynes/cm2) const double atm = 1.01325 * bar; // Standard atmosphere const 키워드는 상수 변수를 선언하는 것 뿐만 아니라 상수 값을 생성하는 생성자 선언에도 사용할 수 있다. var foo = const []; final bar = const []; const baz = []; // Equivalent to `const []` final 키워드의 경우 개체는 수정할 수 없지만 해당 필드는 변경할 수 있다. 그러나 const의 경우 개체와 필드를 변경 할 수 없다. final List\u003cString\u003e cats = [\"개냥이\", \"물속성냥이\"]; cats.add(\"냥냥펀치냥이\"); print(cats); const List\u003cString\u003e dogs = [\"강형욱도 못 말리는 개\", \"강형욱도 무는 개\"]; dogs[0] = \"우리집개\"; // error! ","date":"2023-01-24","objectID":"/dart/:1:0","tags":["Dart","Flutter"],"title":"[Dart] Dart 문법 정리","uri":"/dart/"},{"categories":["Flutter"],"content":"Typedefs typedef는 타입에 대한 별칭을 나타내는 키워드이며 타입을 참조할 수 있는 방법이다. 아래는 IntList라는 타입 별칭을 선언하고 사용하는 예제이다. typedef IntList = List\u003cint\u003e; IntList il = [1, 2, 3]; 타입 별칭은 타입 파라미터와 함께 사용 할 수 있다. typedef ListMapper\u003cX\u003e = Map\u003cX, List\u003cX\u003e\u003e; ListMapper\u003cString\u003e m = {}; // Map\u003cString, List\u003cString\u003e\u003e 타입 별칭 대신 inline function types을 사용하는 것을 권장한다고 한다. typedef Compare\u003cT\u003e = int Function(T a, T b); int sort(int a, int b) =\u003e a - b; void main() { assert(sort is Compare\u003cint\u003e); // True! } ","date":"2023-01-24","objectID":"/dart/:2:0","tags":["Dart","Flutter"],"title":"[Dart] Dart 문법 정리","uri":"/dart/"},{"categories":["Flutter"],"content":"Asynchronous programming ","date":"2023-01-24","objectID":"/dart/:3:0","tags":["Dart","Flutter"],"title":"[Dart] Dart 문법 정리","uri":"/dart/"},{"categories":["Flutter"],"content":"Future Future는 비동기 작업의 결과를 나타내며 완료되지 않음 또는 완료됨의 두 가지 상태를 가질 수 있다. Future는 타입파라미터를 갖는 인스턴스를 생성한다. Future에서 리턴값이 없을 경우 타입은 Future\u003cvoid\u003e 이다. future의 상태 값은 uncompleted 또는 completed 두 가지 중 하나 이다. future 값을 반환하는 함수를 호출하면 수행할 작업을 대기열에 넣고 uncompleted 된 결과값을 반환한다. future 작업이 완료되면 future 혹은 오류와 함께 완료된다. void main() { addNumbers(1, 1); addNumbers(2, 2); } void addNumbers(int number1, int number2) { print('계산시작 : $number1 + $number2'); // 서버 시뮬레이션 Future.delayed(Duration(seconds: 2), (){ print('계산완료 : $number1 + $number2 = ${number1 + number2}'); }); print('함수 완료'); } Console 계산시작 : 1 + 1 함수 완료 계산시작 : 2 + 2 함수 완료 계산완료 : 1 + 1 = 2 계산완료 : 2 + 2 = 4 Working with futures: async and await async 함수는 첫 번째 await 키워드까지 동기적으로 실행된다. async 함수 내에 첫번째 await 키워드 앞의 모든 코드는 즉시 실행된다. async : 함수 앞에 async 키워드를 사용하여 비동기 함수로 표현할 수 있다. awiat : await 키워드를 사용하여 비동기 함수의 완료된 결과를 가져올 수 있다. await 키워드는 async 함수 내에서만 동작한다. void main() { addNumbers(1, 1); addNumbers(2, 2); } Future\u003cvoid\u003e addNumbers(int number1, int number2) async { print('계산시작 : $number1 + $number2'); // 서버 시뮬레이션 await Future.delayed(Duration(seconds: 2), (){ print('계산완료 : $number1 + $number2 = ${number1 + number2}'); }); print('함수 완료'); } Console 계산시작 : 1 + 1 계산시작 : 2 + 2 계산완료 : 1 + 1 = 2 함수 완료 계산완료 : 2 + 2 = 4 함수 완료 ","date":"2023-01-24","objectID":"/dart/:3:1","tags":["Dart","Flutter"],"title":"[Dart] Dart 문법 정리","uri":"/dart/"},{"categories":["Flutter"],"content":"Stream Dart에서는 비동기 프로그래밍을 위한 Future와 Stream 두 가지 클래스를 제공한다. stream은 비동기적으로 연속적인 데이터를 제공한다. Stream API에서 await for 또는 listen()을 사용하여 스트림을 처리 할 수 있다. 스트림에는 single subscription 과 broadcast 두가지 종류를 제공한다. import 'dart:async'; void main() { final controller = StreamController(); final stream = controller.stream.asBroadcastStream(); // 짝수만 출력하기 final streamListener1 = stream.where((val) =\u003e val % 2 == 0).listen((val) { print('Listener 1 : $val'); }); // 홀수만 출력하기 final streamListener2 = stream.where((val) =\u003e val % 2 == 1).listen((val){ print('Listener 2 : $val'); }); controller.sink.add(1); controller.sink.add(2); controller.sink.add(3); controller.sink.add(4); controller.sink.add(5); } Console Listener 2 : 1 Listener 1 : 2 Listener 2 : 3 Listener 1 : 4 Listener 2 : 5 import 'dart:async'; void main() { calculate(2).listen((val) { print('calculate(2) : $val'); }); calculate(4).listen((val) { print('calculate(4) : $val'); }); } Stream\u003cint\u003e calculate(int number) async* { for(int i = 0; i \u003c 5; i++) { yield i * number; await Future.delayed(Duration(seconds: 1)); } } Console calculate(2) : 0 calculate(4) : 0 calculate(2) : 2 calculate(4) : 4 calculate(2) : 4 calculate(4) : 8 calculate(2) : 6 calculate(4) : 12 calculate(2) : 8 calculate(4) : 16 ","date":"2023-01-24","objectID":"/dart/:3:2","tags":["Dart","Flutter"],"title":"[Dart] Dart 문법 정리","uri":"/dart/"},{"categories":["Flutter"],"content":"참고 코드팩토리 :: Dart 언어 4시간만에 완전정복 강의 Dart Document :: Asynchronous programming: futures, async, await Dart Document :: Asynchronous programming: Streams ","date":"2023-01-24","objectID":"/dart/:4:0","tags":["Dart","Flutter"],"title":"[Dart] Dart 문법 정리","uri":"/dart/"},{"categories":["Etc"],"content":"buf buf는 IDL(Interface description language) 중 하나인 protobuf를 사용하기 쉽게 여러가지 기능을 제공하고 있다. protobuf를 사용하면서 발생하는 문제는 다음과 같다. API 설계가 일관성이 없다. 의존성 관리가 중앙에서 이루어지지 않고 있다. protobuf의 버전관리가 잘 이루어지지 않는다. protoc를 통한 stub 배포 및 관리가 어렵다 mock 서버 생성, fuzz testing, 문서화 할 수 있는 툴들이 많이 존재하지 않는다. ","date":"2023-01-23","objectID":"/buf/:1:0","tags":["buf","Buf Schema Registry","protobuf"],"title":"[buf] buf로 protobuf 사용하기","uri":"/buf/"},{"categories":["Etc"],"content":"buf에서 제공하는 툴 ","date":"2023-01-23","objectID":"/buf/:2:0","tags":["buf","Buf Schema Registry","protobuf"],"title":"[buf] buf로 protobuf 사용하기","uri":"/buf/"},{"categories":["Etc"],"content":"buf cli 발전된 protobuf 컴파일러를 제공한다. 좋은 API 디자인과 구조를 lint 기능을 통해 선택할 수 있다. 소스 코드 및 wire 레벨에서 변경 감지를 통해 호환성 적용이 가능하다. 구성 파일을 통해 protoc 의존 관리를 쉽게 할 수 있다. ","date":"2023-01-23","objectID":"/buf/:2:1","tags":["buf","Buf Schema Registry","protobuf"],"title":"[buf] buf로 protobuf 사용하기","uri":"/buf/"},{"categories":["Etc"],"content":"Buf Schema Registry (BSR) BSR은 Protobuf API를 buf 에서 제공하는 SaaS 플랫폼을 통해 호스팅하여 관리할 수 있다. BSR를 통해 중앙에서 Protobuf API에 대한 호환성 및 의존성 관리가 가능해진다. Javascript의 npm, 파이썬의 pip이나 cargo 패키지 관리 툴처럼 Protobuf API의 종속성 관리를 BSR을 통해 관리할 수가 있다. ","date":"2023-01-23","objectID":"/buf/:2:2","tags":["buf","Buf Schema Registry","protobuf"],"title":"[buf] buf로 protobuf 사용하기","uri":"/buf/"},{"categories":["Etc"],"content":"buf 설치하기 buf 설치하기 # mac brew install bufbuild/buf/buf ","date":"2023-01-23","objectID":"/buf/:3:0","tags":["buf","Buf Schema Registry","protobuf"],"title":"[buf] buf로 protobuf 사용하기","uri":"/buf/"},{"categories":["Etc"],"content":"BSR 로그인하기 사용자 설정 페이지에서 저장소에 접근할 수 있는 개인 토큰을 발행하고 레지스트리에 로그인한다. 로그인을 완료하면 $HOME/.netrc 파일에 자격증명이 생성된다. buf registry login Log in with your Buf Schema Registry username. If you don't have a username, create one at https://buf.build. Username: riley Token: Credentials saved to /Users/riley/.netrc. ","date":"2023-01-23","objectID":"/buf/:4:0","tags":["buf","Buf Schema Registry","protobuf"],"title":"[buf] buf로 protobuf 사용하기","uri":"/buf/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"CIDR - IPv4 Classless Inter-Domain Routing : IP 주소 할당 방법 Security Groups : 규칙 및 AWS 네트워킹에 일반적으로 사용 Base IP : 범위에 포함된 IP를 나타냄 (e.g., 10.0.0.0, 192.168.0.0 …) Subnet Mask IP에서 변경할 수 있는 비트 수를 정의 (e.g., /0, /24, /32) /8 : 255.0.0.0 /16 : 255.255.0.0 /24 : 255.255.255.0 /32 : 255.255.255.255 Subnet Mask Subnet Mask 사용하면 기본적으로 기본IP에서 다음 값을 추가로 가져올 수 있다. IPLocationTools IP/Subnet Mask 192.168.0.0/32 allows for 1 IP(20) 192.168.0.0 192.168.0.0/31 allows for 2 IP(21) 192.168.0.0 ~ 192.168.0.1 192.168.0.0/30 allows for 4 IP(22) 192.168.0.0 ~ 192.168.0.3 192.168.0.0/29 allows for 8 IP(23) 192.168.0.0 ~ 192.168.0.7 192.168.0.0/28 allows for 16 IP(24) 192.168.0.0 ~ 192.168.0.15 192.168.0.0/27 allows for 32 IP(25) 192.168.0.0 ~ 192.168.0.31 192.168.0.0/26 allows for 64 IP(26) 192.168.0.0 ~ 192.168.0.65 192.168.0.0/25 allows for 128 IP(27) 192.168.0.0 ~ 192.168.0.127 192.168.0.0/24 allows for 256 IP(28) 192.168.0.0 ~ 192.168.0.255 192.168.0.0/16 allows for 65,536IP(216) 192.168.0.0 ~ 192.168.255.255 192.168.0.0/0 allows for All IP 0.0.0.0 ~ 255.255.255.255 ","date":"2022-08-15","objectID":"/aws-28-vpc/:1:0","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Public vs Private IP (IPv4) IANA(Internet Assigned Number Authority) 은 개인(LAN) 및 공용(Internet) 주소 사용을 위해 IPv4 주소의 특정 블록을 설정함 Private IP는 특정 값만 허용 가능 10.0.0.0 – 10.255.255.255 (10.0.0.0/8) : big networks 172.16.0.0 – 172.31.255.255 (172.16.0.0/12) : AWS defaultVPC in that range 192.168.0.0 – 192.168.255.255 (192.168.0.0/16) : e.g., home networks 인터넷에 있는 나머지 IP는 모두 public IP ","date":"2022-08-15","objectID":"/aws-28-vpc/:1:1","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Default VPC 모든 AWS 계정은 default VPC를 갖는다. 새로운 EC2 인스턴스는 subnet을 지정하지 않으면 기본 VPC로 시작한다. 기본 VPC는 인터넷에 연결되어 있고 public IPv4 주소를 가지고 있음 public 및 private IPv4 와 DNS 이름을 얻을 수 있음 ","date":"2022-08-15","objectID":"/aws-28-vpc/:2:0","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"VPC in AWS Virtual Private Cloud (VPC) AWS 리전에 여러 VPC를 만들 수 있다. (리전당 VPC는 최대 5개) VPC당 CIDR Min size /28 (16 IP Address) Max Size /16 (65,536 IP Address) VPC 비공개 전용이므로 Private IPv4 범위만 허용 10.0.0.0 – 10.255.255.255 (10.0.0.0/8) 172.16.0.0 – 172.31.255.255 (172.16.0.0/12) 192.168.0.0 – 192.168.255.255 (192.168.0.0/16) VPC CIDR는 다른 네트워크(e.g., corporate)와 겹치지 않아야 한다. ","date":"2022-08-15","objectID":"/aws-28-vpc/:3:0","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Subnet AWS는 각 서브넷에 5개의 IP 주소를 예약(처음 4개 \u0026 마지막 1개) 위 IP는 사용할 수 없으며 EC 인스턴스 할당 불가 서브넷 예약 IP 10.0.0.0 – Network Address 10.0.0.1 – AWS에 의해 VPC Router 용으로 예약 10.0.0.2 – Amazon가 제공하는 DNS에 매핑하기 위해 AWS에 의해 예약 10.0.0.3 – 나중에 사용을 위한 10.0.0.255 - Network Broadcast Address. AWS는 VPC에서 브로드캐스드를 지원하지 않으므로 해당 주소가 예약되어있음 Exam Tip: EC2 인스턴스에 29개의 IP 주소가 필요한 경우 크기가 /27인 서브넷은 선택할 수 없다 (/27 -\u003e 25=32 - 5 = 27 -\u003e 27 \u003c 29) 크기가 /26인 서브넷을 선택해야 한다. (/26 -\u003e 26=64 - 5 = 59 -\u003e 59 \u003e 29) ","date":"2022-08-15","objectID":"/aws-28-vpc/:3:1","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Internet Gateway (IGW) VPC 리소스(e.g., EC2 인스턴스)를 인터넷에 연결할 수 있다. 수평으로 확장 가능하며 높은 가용성과 이중화redundant 제공 VPC와 별도로 생성해야 한다. 하나의 VPC는 하나의 IGW에만 연결할 수 있다. (그 반대의 경우도 마찬가지) 인터넷 게이트 웨이 자체에서도 인터넷 액세스를 허용하지 않는다 - Route Tables을 반드시 수정해야 한다. ","date":"2022-08-15","objectID":"/aws-28-vpc/:3:2","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Bastion Hosts Bastion Host를 사용하여 Private EC2 인스턴스로 SSH 할 수 있다. Bastion은 public 서브넷에 위치하며 다른 모든 private 서브넷과 연결 된다. Bastion Host의 security group은 매우 엄격해야한다 Exam Tip 다른 EC2 인스턴스 Security Group이 아닌 사용자가 필요한 IP 주소의 포트 22만 Bastion host에서 가능한지 확인합니다. ","date":"2022-08-15","objectID":"/aws-28-vpc/:3:3","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"NAT Instance (outdated, 시험에는 나옴) NAT (Network Address Translation) private 서브넷의 EC2 인스턴스를 인터넷에 연결하게 할 수 있다. 반드시 public 서브넷에서 실행 반드시 NAT EC2 생성 시 해당 체크 해제 -\u003e Source/destination Elastic IP가 연결되어 있어야 한다. private 서브넷에서 NAT 인스턴스로 라우팅하도록 Route Tables 구성해야 한다. 미리 구성된 Amazon Linux AMI를 사용할 수 있음 2020년 12월 31일 지원 종료 가용성이 높지 않고 초기화 설정으로 복원 불가능 Multi AZ에 대한 ASG 생성 + 복원되는 사용자 데이터 스크립트 필요 인터넷 트래픽 대역폭은 EC2 인스턴스 유형에 따라 다름 Security Group \u0026 rules 관리 인바운드 HTTP/HTTPS: Private Subnet 허용 SSH: 홈 네트워크(Internet Gateway를 통해 액세스 제공) 아웃바운드 인터넷에 대한 모든 HTTP/HTTPS 트래픽 허용 ","date":"2022-08-15","objectID":"/aws-28-vpc/:3:4","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"NAT Gateway AWS에서 관리되며 높은 대역폭, 높은 가용성, 관리가 필요없음 사용량 및 대역폭에 따라 시간당 비용지불 NATGW는 특정 AZ에 생성되며 Elastic IP를 사용 동일한 서브넷의 EC2 인스턴스에서는 사용할 수 없음 (오직 다른 서브넷에서만) Internet Gateway가 필요 (Private subnet =\u003e NAT Gateway =\u003e Internet Gateway) 5Gpbs 대역폭 최대 45Gbps 까지 자동 확장 Security Groups 관리가 필요 없음 NAT Gateway with High Availability NAT Gateway는 단일 AZ내에서 탄력적임 fault-tolerance을 위해 multiple AZ에 multiple NAT Gateways를 구성 AZ가 중단될 경우 NAT가 필요하지 않으므로 AZ failover가 필요하지 않음 ","date":"2022-08-15","objectID":"/aws-28-vpc/:3:5","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"NAT Gateway vs NAT Instance NAT Gateway NAT Instance Availability가용성 AZ내 높은 가용성(다른 AZ생성) 스크립트를 사용하여 인스턴스간 failover 관리(가용성이 높진않음) Bandwidth Up to 45 Gbps EC2 타입에 의존 Maintenance AWS에서 관리 사용자가 관리 (e.g., software, OS patches …) Cost 시간 당 \u0026 전송된 데이터 양 시간 당, 인스턴스 타입에 따른 사이즈 + 네트워크 $ Public IPv4 O O Private IPv4 O O Security Groups X O Use as Bastion Host? X O ","date":"2022-08-15","objectID":"/aws-28-vpc/:3:6","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"DNS Resolution in VPC ","date":"2022-08-15","objectID":"/aws-28-vpc/:4:0","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"DNS Resolution (enableDnsSupport) VPC에 대해 Route 53 Resolver server의 DNS 확인(DNS Resolution)이 지원되는지 여부를 결정 기본값 : True Amazon이 제공하는 DNS 서버(169.254.169.253) 또는 VPC IPv4 reserved IP (x.x.x.2)를 쿼리하게 된다. ","date":"2022-08-15","objectID":"/aws-28-vpc/:4:1","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"DNS Hostname (enableDnsHostnames) 기본적으로 True : default VPC False : 새로 생성된 VPC enableDnsSupport=true : 아무것도 하지 않음 enableDnsHostnames=true : EC2 인스턴스에 공용 IPv4가 있는 경우 공용 호스트 이름을 할당 Tip Route 53의 Private Hosted Zone에서 사용자 지정 DNS 도메인 이름을 사용하는 경우 두모든 속성을 true로 지정 enableDnsSupport=true \u0026 enableDnsHostname=true ","date":"2022-08-15","objectID":"/aws-28-vpc/:4:2","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Security Groups \u0026 NACLs ","date":"2022-08-15","objectID":"/aws-28-vpc/:5:0","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Network Access Control List (NACL) NACL은 서브넷에서 송수신되는 트래픽을 제어하는 방화벽과 같다. 서브넷 당 하나의 NACL, 새로운 서브넷은 Default NACL에 할당된다. 새로 생성된 NACL은 모든 것을 거부 NACL은 서브넷 수준에서 특정 IP 주소를 차단하는 좋은 방법 NACL 규칙 규칙에는 숫자(1-32766). 낮은 숫자가 우선순위가 높다. Tip 10.0.0.10 해당 주소는 ALLOW #100 ALLOW 10.0.0.10/32 #200 DENY 10.0.0.10/32 마지막 규칙은 asterisk(*)이며 규칙이 매칭되지 않는 경우 요청을 거부 AWS는 100 단위로 규칙을 증가하는 것을 추천 Default NACL 연결된 서브넷과 함께 모든 인바운드/아웃바운드를 수락 절대 Default NACL을 수정하지 말고 사용자 정의 NACL을 작성할 것 Ephemeral Ports 두 endpoint 연결을 설정하려면 포트를 사용해야 한다. 클라이언트는 정의된 포트에 연결하고 ephemeral port로 응답값을 받기를 원한다. 운영체제에 따라 포트범위가 다르다 IANA \u0026 MSWindows10 : 49152 - 65535 Many Linux Kernels : 32768 - 60999 ","date":"2022-08-15","objectID":"/aws-28-vpc/:5:1","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Security Group vs. NACLs Security Group NACL 인스턴스 수준에서 작동 서브넷 수준에서 작동 허용 규칙만 지원 allow, deny 규칙 지원 Stateful:반환 트래픽은 규칙과 관계없이 자동으로 허용 Stateless:반환 트래픽은 규칙에 의해 병시적으로 허용 - think of ephemeral ports 트래픽을 허용할지 여부를 결정하기 전에 모든 규칙 평가 트래픽 허용 여부를 결정할 때 규칙을 순서대로 평가(우선순위가 높은 첫번째 일치가 적용) 다른 사용자가 지정한 경우 EC2 인스턴스에 적용 연결된 서브넷의 모든 EC2 인스턴스에 자동으로 적용 ","date":"2022-08-15","objectID":"/aws-28-vpc/:5:2","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"VPC – Reachability Analyzer VPC 두 endpoint 간 네트워크 연결 문제를 해결하는 네트워크 진단 도구 네트워크 구성의 모델을 만든 다음 이러한 구성을 기반으로 도달 가능성을 확인 (패킷 전송은 하지 않음) 사용 사례 : 연결문제 해결, 네트워크 구성이 의도대로인지 확인 등… 대상에 따른 분석 Reachable : 가상 네트워크 경로에 대한 hop-by-hop 세부 정보 생성 Not reachable : 차단 구성요소 (e.g., SG, NACL, Route Tables 구성 문제)를 식별 ","date":"2022-08-15","objectID":"/aws-28-vpc/:5:3","tags":["AWS","Virtual Private Cloud(VPC)"],"title":"28. AWS Virtual Private Cloud(VPC)","uri":"/aws-28-vpc/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"전송중 암호화 (SSL) 데이터를 전송하기 전에 암호화. 수신 후 복호화 SSL 인증서로 암호화 (HTTPS) 전송 중 암호화는 MITM(man in the middle attack)이 발생하지 않도록 보장 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:1:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Server side encryption at rest 데이터가 서버에 수신 된 후 암호화 데이터가 서버에 전송 전 복호화 데이터 키라고 불리우는 키 덕분에 데이터는 암호화 된 형태로 저장 암호화 및 복호화 키는 어딘가에 관리되어야 하며 서버는 이에 대한 액세스 권한이 있어야 한다. ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:2:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Client side encryption 데이터가 클라이언트에 의해 암호화되고 서버는 복호화할 수 없음 데이터는 수신 클라이언트에 의해 복호화 서버는 데이터의 암호를 복호화 할 수 없음 Envelop Encryption 암호화를 활용 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:3:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS KMS (Key Management Service) KMS 키를 사용하여 데이터에 액세스할 수 있는 사람과 대상을 쉽게 제어 인증을위한 IAM과 완벽하게 통합가능 CLI / SDK 사용 가능 다음의 서비스와 완벽하게 통합: Amazon EBS: 볼륨 암호화 Amazon S3 : Server side encryption of objects Amazon Redshift: encryption of data Amazon RDS: encryption of data Amazon SSM: Parameter store 그외… ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:4:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Customer Master Key (CMK) Types 대칭키 Symmetric (AES-256 Key) 암호화 및 복호화가 동일 AWS는 KMS와 통합된 Symmetric CMKs를 사용 envelope encryption에 필요 암호화되지 않은 키에 액세스 할 수 없음 - 사용하려면 KMS API 호출 필요 비대칭키 Asymmetric (RSA \u0026 ECC Key pairs) SSL 작동 원리 암호화 시 public key 복호화 시 private key 사용 암호화/복호화 및 Sing/Verify 작업에 사용 public key를 다운로드할 수 있지만 private key에는 액세스 할 수 없음 사용 사례 KMS API를 호출할 수 없는 사용자에 의한 AWS 외부 암호화 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:4:1","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"KMS 대칭키 KMS Symmetric Key 키 정책 생성정책 Rotation policies - 키 교체 정책 활성화 및 비활성화 CloudTrail을 사용하여 키 사용을 감사 Customer Master Keys(CMS) 유형 AWS Managed Service Default CMK: free User Keys created in KMS: $1 / month User Keys imported (must be 256-bit symmetric key): $1 / month Call KMS API ($0.03 / 10000 calls) ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:4:2","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS KMS 101 데이터베이스 패스워드 외부 서비스의 자격증명 SSL 인증서의 private key Tip KMS는 데이터를 암호화하거나 복호화하는 키를 볼 수 없기 때문에 AWS의 전체 보안이 가능 Secret 데이터는 플레인텍스트로 특히 코드로 저장하지 않는다. KMS 요청당 4KB의 데이터를 암호화하는데 효율 - 데이터가 4KB 큰 경우 envelop encryption 사용 다른 사용자에게 KMS 권한을 부여하려면 키 정책이 사용자를 허용하는지 확인한다. IAM 정책이 API를 호출을 허용하는지 확인한다. ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:4:3","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Copying Snapshots across regions KMS 키는 특정 리전에 바인딩 된다. 리전 A에서 KMS를 생성하면 리전 B로 전송 불가능 KMS로 암호화된 EBS 볼륨 동일한 키로 암호화 된 EBS 스냅샷 생성 다른 리전에 KMS 키로 재 암호화 새로운 리전에 새로운 키로 암호화 된 스냅샷생성 해당 스냅샷으로 볼륨을 재생성 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:4:4","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"KMS 키 정책 KMS 키에 대한 액세스 제어는 S3 Bucket 정책과 비슷 차이점 : 사용자 없이 액세스 제어 불가 기본 KMS 키 정책 Custom KMS 키 정책 - 특정 키 정책을 사용하지 않으면 기본으로 생성 - KMS 키에 액세스할 수 있는 사용자 및 role 정의 - 루트 사용자 = 전체 AWS 계정에 대한 전체 치 액세스 권한 - 키를 관리할 수 있는 사용자 정의 - KMS 키에 대한 IAM 정책에 대한 액세스 권한 부여 - KMS 키의 계정간 액세스에 유용 Copying Snapshots across accounts 사용자의 CMK로 암호화 된 스냅샷 생성 KMS 키 정책을 첨부하여 계정간 계정 액세스 권한 부여 암호화 된 스냅샷 공유 스냅샷 복사본 생성 계정의 KMS 키로 암호화 스냅샷 볼륨 생성 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:4:5","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"KMS Automatic Key Rotation Customer-managed(CMK)에서만 (not AWS managed CMK) 사용할 경우 1 년마다 키가 rotation 이전 데이터들이 복호화 될 수 있도록 이전키의 상태는 활성화 새 키의 CMK ID는 동일하다. (Backing Key만 변경) ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:4:6","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"KMS Manual Key Rotation 90일, 180일 등 원하는 간격으로 rotate 할 경우 새 키의 CMK ID가 다르다 이전 데이터들이 복호화 될 수 있도록 이전키의 상태는 활성화 UpdateAlias API를 사용하여 별칭을 사용하는 것이 좋다. 자동 키 로테이션 CMK(비대칭 CMK 같은)에 적합하지 않은 경우 좋은 대안 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:4:7","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"SSM Parameter Store 구성 및 기밀 데이터를 위한 안전한 스토리지 KMS를 사용한 원활한 암호화(옵션) Serverless, 확장성, 내구성, 손쉬운 SDK 버전 트래킹 path \u0026 IAM을 사용한 구성 관리 CloudWatch 이벤트 알림 CloudFormation과 통합 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:5:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"SSM Parameter Store Hierarchy ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:5:1","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Parameters Policies (for advanced parameters) 암호같은 중요한 데이터를 강제로 업데이트하거나 삭제하기 위해 만료일에 TTL을 적용 한번에 여러 정책을 할당 가능 파라미터 정책 Expiration(파라미터 삭제) { \"Type\": \"Expiration\", \"Version\" : \"1.0\", \"Attributes\": { \"Timestamp\" : \"2020-12-02T21:34:33.000Z\" } } 만료 알림(CloudWatch Events) { \"Type\": \"Expiration\", \"Version\" : \"1.0\", \"Attributes\": { \"Timestamp\" : \"2020-12-02T21:34:33.000Z\" } } NoChangeNotification(CloudWatch Events) { \"Type\": \"NoChangeNotification\", \"Version\" : \"1.0\", \"Attributes\": { \"After\": \"20\", \"Unit\": \"Days\" } } ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:5:2","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Secret Manager 기밀 저장을 위한 새로운 서비스 X 일마다 강제로 기밀을 로테이션 하는 기능 Amazon RDS (MySQL, PostgreSQL, Aurora) 통합 KMS을 사용한 암호화 대부분의 RDS 통합을 위함 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:6:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"CloudHSM KMS는 AWS에서 암호화를 위한 소프트웨어 관리 CloudHSM =\u003e AWS에서 암호화 하드웨어 프로비저닝 전용 하드웨어 (HSM = Hardware Security Module) AWS가 아닌 자신의 암호화 키를 전체적으로 관리해야 한다. HSM는 변조 방지, FIPS 140-2 레벨 3 준수 대칭 및 비대칭 암호화 (SSL/TLS 키)모두 지원 프리티어 아님 CloudHSM Client Software를 사용해야 함 Redshift는 데이터베이스의 암호화와 키 관리를 위해 CloudHSM를 지원 SSE-C 암호화와 함께 사용하기 좋은 옵션 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:7:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"CLoudHSM Diagram IAM Permissions CRUD an HSM Cluster CloudHSM software Manage the Keys Manage the Users ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:7:1","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"CLoudHSM - High Availability CloudHSM 클러스터는 Multi AZ(HA) 분산된다. 뛰어난 가용성 및 내구성을 갖는다. ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:7:2","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"CloudHSM vs. KMS 기능 AWS KMS AWS CloudHSM Tenancy Multi-Tenant Single-Tenant Standard FIPS 140-2 Level 2 FIPS 140-2 Level 3 Master Keys · AWS Owned CMK· AWS Manged CMK· Customer Managed CMK Customer Managed CMK Key Types · Symmetric· Asymmetric· Digital Signing · Symmetric· Asymmetric· Digital Signing \u0026 Hashing Key Accessibility 여러 AWS 리젼에서 액세스 가능 · VPC에서 배포 및 관리· VPC 간에 공유 가능(VPC 피어링) Cryptographic Acceleration None · SSL/TLS Acceleration• Oracle TDE Acceleration Access \u0026 Authentication AWS IAM 사용자를 생성하고 권한을 관리 High Availability AWS Managed Service 서로 다른 AZ에 여러 HSM 추가 Audit Capability · CloudTrail· CloudWatch • CloudWatch• CloudTrail• MFA support Free Tier Yes No ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:8:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Shield ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:9:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Shield Standard 무료 서비스 SYN/UDP Floods, Reflection, 네트워크 Layer3/Layer4 공격과 같은 기타 공격으로 부터 보호 제공 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:9:1","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Shield Advanced 선택적인 DDoS 완화 서비스 ($3,000 per month per organization) Amazon EC2, Elastic Load Balancing(ELB), Amazon CloudFront, AWS Global Accelerator 및 Route 53에 대한 보다 정교한 공격으로부터 보호 AWS DDoS 대응팀(DRP) 연중무휴 액세스 DDoS로 인해 사용량이 급증하는 동안 더 높은 수수료로부터 보호 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:9:2","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS WAF - Web Application Firewall 일반적인 웹 악용으로 부터 웹 응용 계층 보호 (Layer 7) Layer 7 is HTTP (vs Layer 4 is TCP) Deploy on Application Load Balancer, API Gateway, CloudFront ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:10:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Define Web ACL (Web Access Control List) 규칙에는 IP address, HTTP headers, HTTP body, URI strings 포함할 수 있다. 일반적인 공격으로 부터 보호 SQL injection Cross-Site Scripting (XSS) 크기 제약, 지리적 일치(블록 국가) DDoS 보호를 위한 속도기반 규칙 (이벤트 발생 횟수 계산) ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:10:1","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Firewall Manager AWS 조직의 모든 계정 규칙을 관리 공통 보안 규칙 집합 WAF 규칙 : (Application Load Balancer, API Gateways, CloudFront) AWS Shield Advanced (ALB, CLB, Elastic IP, CloudFront) VPC의 EC2 및 ENI 리소스에 대한 Security Group ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:10:2","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon GuardDuty AWS 계정 보호를 위한 지능형 위협 검색 머닝 러신 알고리즘, 이상 징후 감지, 3rd party 데이터 이용 클릭 한 번으로 활성화 (30일 평가판), 소프으웨서 설치 불필요 입력에는 다음과 같은 데이터가 포함 CloudTrail Events Logs : 비정상적인 API 호출, 무단 배포 CloudTrail Management Events : VPC 서브넷 생성, create trail 등 CloudTrail S3 Data Events : GetObject, ListObject, DeleteObject 등 VPC Flow : 비정상적인 내부 트래픽, 비정상적인 IP 주소 DNS Log : DNS 쿼리 내 암호화된 데이터를 전송하는 EC2 인스턴스의 손상 Kubernetes Audit Log : 의심스러운 활동과 EKS 클러스터 손상 가능성 발견 시 알림을 받을 CloudWatch Event rules 설정 가능 CloudWatch Events rule은 AWS Lambda or SNS를 대상으로 할 수 있다 CryptoCurrency Attacks 공격으로부터 보호할 수 있음 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:11:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon Inspector 자동화된 보안 평가 Tip For EC2 instance AWS System Manager(SSM) agent 활용 의도하지 않은 네트워크 액세스 가능성에 대한 분석 실행중인 OS의 알려진 취약성 분석 For Containers push to Amazon ECR ECR 컨테이너에 push에 대한 분석 AWS Security Hub와 보고 및 통합 Amazon Event Bridge 결과 전송 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:12:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Inspector가 평가하는 것들 EC2 인스턴스 및 컨테이너 infrastructure 만 해당 필요한 경우에만 인프라의 지속적인 검색 패키지 취약성 (EC2 \u0026 ECR) - CVE 데이터베이스 Network reachability (EC2) 위험 점수는 우선순위 지정에 대한 모든 취약성과 연결 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:12:1","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon Macie 머신러닝과 패턴 매칭을 활용해 AWS의 중요한 데이터를 검색 및 보호하는 완전 관리형 데이터 베이스 보안 및 프라이버시 서비스 개인 식별 가능 정보 (personally identifiable information-PII)와 같은 중요한 데이터를 식별하고 경고하도록 도와줌 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:13:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS 공유적 책임 모델 AWS의 책임 클라우드의 보안 모든 AWS 서비스를 실행하는 인프라(hardware, software, facilities, and networking) 보호 S3, DynamoDB, RDS 등과 같은 관리형 서비스 고객의 책임 클라우드 내 보안 EC2 인스턴스의 경우 고객은 게스트 OS(보안 패치 및 업데이트 포함), 방화벽 및 네트워크 구성, IAM을 관리해야 함 애플리케이션 데이터 암호화 공유 : 패치 관리, 구성 관리, 인식 및 교육 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:14:0","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS에서 책임모델 AWS의 책임 근본적인 EC2 인스턴스 관리 SSH 액세스 자동화된 DB 패치 자동화된 OS 패치 근본적인 인스턴스 및 디스크 감사 및 기능 보장 고객의 책임 DB Security Group의 포트 / IP / 인바운드 규칙 확인 데이터베이스 내의 사용자 생성 및 권한 공용 접근 권한 유무 관계없이 데이터베이스 작성 매개 변수 그룹 또는 DB가 SSL 연결만 허용하도록 구성되었는지 확인 데이터베이스 암호화 설정 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:14:1","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"S3에서 책임모델 AWS의 책임 무제한 스토리지의 제공을 보장 암호화 제공을 보장 서로 다른 고객간의 데이터 분리 보장 AWS 직원이 데이터에 액세스 할 수 없도록 보장 고객의 책임 Bucket의 구성 Bucket 정책 / 공용 설정 IAM 사용자 및 역할 암호화 사용 ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:14:2","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Shared Responsibility Model diagram https://aws.amazon.com/ko/compliance/shared-responsibility-model/ ","date":"2022-08-14","objectID":"/aws-27-security-encryption/:14:3","tags":["AWS","AWS Key Management Service","AWS System Manager"],"title":"27. AWS Security \u0026 Encryption","uri":"/aws-27-security-encryption/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Application communication ","date":"2022-08-02","objectID":"/aws-18-integration-messaging/:1:0","tags":["Amazon SQS","Amazon SNS","Kinesis"],"title":"18. AWS Integration \u0026 Messaging","uri":"/aws-18-integration-messaging/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Application communication 두 가지 패턴 Synchronous communications (application to application) Synchronous는 요청량이 급증하면 애플리케이션간 여러 문제를 유발시킬 수 있다. Asynchronous / Event based (application to queue to application) 애플리케이션 의존관계decouple를 낮추는 사례 아래 서비스들을 사용하여 즉각적으로 애플리케이션을 확장가능 하다. SQS 사용 : Queue 모델 SNS 사용 : pub/sub 모델 Kinesis : 실시간 스트리밍 모델 ","date":"2022-08-02","objectID":"/aws-18-integration-messaging/:1:1","tags":["Amazon SQS","Amazon SNS","Kinesis"],"title":"18. AWS Integration \u0026 Messaging","uri":"/aws-18-integration-messaging/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon SQS ","date":"2022-08-02","objectID":"/aws-18-integration-messaging/:2:0","tags":["Amazon SQS","Amazon SNS","Kinesis"],"title":"18. AWS Integration \u0026 Messaging","uri":"/aws-18-integration-messaging/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon SQS - Standard Queue AWS에서 가장 오래된 서비스. 애플리케이션을 decoupling하기 위해 서비스를 관리 중복 메세지를 갖을 수 있다. -\u003e 적어도 한번은 전송 된다. Can have out of order messages (best effort ordering) 특징 큐에 적재할 수 있는 메세지 및 처리량에 제한이 없다 unlimited throughput. 기본 4일에서 최대 14일까지 큐에 메세지를 보존할 수 있다. 낮은 지연 메세지의 크기는 256KB로 제한 Produing Message SDK의 SendMessage API를 통해 SQS 메세지를 생산 메세지는 consumer가 삭제하기 전까지 SQS에 유지된다. 메세지 보존기간 : 기본 4 days ~ 14 days example 예시) 주문정보를 전송한다. Order Id Customer Id 다른 속성 값들… Consuming Message consumers : 운용중인 EC2 인스턴스, 서버 또는 AWS 람다 서비스 등 Poll SQS for message : 매 10초마다 메세지를 폴링 한다. Process the message : ex) RDS 데이터베이스에 메세지를 저장 DeleteMessage API를 사용하여 처리가 완료되면 메세지를 삭제해야 한다. ","date":"2022-08-02","objectID":"/aws-18-integration-messaging/:2:1","tags":["Amazon SQS","Amazon SNS","Kinesis"],"title":"18. AWS Integration \u0026 Messaging","uri":"/aws-18-integration-messaging/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Multiple EC2 인스턴스 컨슈머 컨슈머들은 메세지를 수신 받고 병렬로 처리할 수 있다. 적어도 한번은 전송이 된다. 컨슈머는 처리가 완료되면 메세지를 삭제한다. 컨슈머를 병렬로 확장하여 프로세스 처리량을 증가시킬 수 있다. ","date":"2022-08-02","objectID":"/aws-18-integration-messaging/:2:2","tags":["Amazon SQS","Amazon SNS","Kinesis"],"title":"18. AWS Integration \u0026 Messaging","uri":"/aws-18-integration-messaging/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"SQS with Auto Scaling Group (ASG) ","date":"2022-08-02","objectID":"/aws-18-integration-messaging/:2:3","tags":["Amazon SQS","Amazon SNS","Kinesis"],"title":"18. AWS Integration \u0026 Messaging","uri":"/aws-18-integration-messaging/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"SQS to decouple between application tiers ","date":"2022-08-02","objectID":"/aws-18-integration-messaging/:2:4","tags":["Amazon SQS","Amazon SNS","Kinesis"],"title":"18. AWS Integration \u0026 Messaging","uri":"/aws-18-integration-messaging/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"SQS 보안 암호화 HTTPS API를 통한 전송중 암호화 KMS 키를 통한 At-rest 암호화 클라이언트 원하는대로 암/복호화를 클라이언트 측에서 가능 접근제한 IAM 정책을 ","date":"2022-08-02","objectID":"/aws-18-integration-messaging/:2:5","tags":["Amazon SQS","Amazon SNS","Kinesis"],"title":"18. AWS Integration \u0026 Messaging","uri":"/aws-18-integration-messaging/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon S3 Amazon S3은 AWS의 주요한 서비스 중 하나이다. 무한 확장infinitely scaling 가능한 storage 많은 웹사이트에서 Amazon S3을 backbone으로 사용한다. AWS의 다수의 서비스에서도 Amazon S3 통합하여 사용할 수 있다. ","date":"2022-08-01","objectID":"/aws-14-s3/:1:0","tags":["AWS","Amazon S3"],"title":"14. S3 Storage and Data Management","uri":"/aws-14-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon S3 Overview ","date":"2022-08-01","objectID":"/aws-14-s3/:2:0","tags":["AWS","Amazon S3"],"title":"14. S3 Storage and Data Management","uri":"/aws-14-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Buckets Amazon S3에서는 object(files) 을 buckets(directories) 에 저장할 수 있다. 버켓은 반드시 전역적으로 유일globally unique name 해야 한다. 버켓은 region level 정의된다. (S3는 전역서비스지만 버켓은 리전리소스) Naming convention 대문자 불가 _ 불가 길이는 3~63 자리 IP 주소가 아닐 것 반드시 소문자로 또는 숫자로 시작 ","date":"2022-08-01","objectID":"/aws-14-s3/:2:1","tags":["AWS","Amazon S3"],"title":"14. S3 Storage and Data Management","uri":"/aws-14-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Objects Object는 파일이며 키를 가짐 key는 전체경로full path를 나타낸다 s3://my-bucket/my_file.txt : my_file.txt이 키 값을 나타낸다. s3://my-bucket/my_folder1/another_folder/my_file.txt : my_folder1/another_folder/my_file.txt전체 경로가 키 값을 나타낸다. 키는 prefix + object name으로 구성되어있음. s3://my-bucket/my_folder1/another_folder/my_file.txt prefix : my_folder1/another_folder/ object name : my_file.txt 버켓에는 디렉토리 개념이 없다. (UI만 그럴뿐) 슬래시(\"/\")가 포함된 긴 이름만 키로 사용가능하다. Object의 값은 컨텐츠의 내용을 나타낸다. 최대 Object 크기는 5TB(5000GB) 5GB 이상 업로드하는 경우 Multi-part 업로드를 사용해야 한다. Metadata : 키/값 쌍으로 정의된 리스트. 시스템 또는 사용자 메타데이터로 사용 Tags : Unicode 키/값 쌍. 최대 10개까지 정의. 보안, lifecycle 정보를 지정시 유용 Version ID : versioning을 활성화 한 경우 Object의 버전별로 ID로 관리 ","date":"2022-08-01","objectID":"/aws-14-s3/:2:2","tags":["AWS","Amazon S3"],"title":"14. S3 Storage and Data Management","uri":"/aws-14-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Versioning Amazon S3은 파일에 버전을 설정할 수 있다. 버켓 수준에서 활성화 가능 같은 키로 object를 overwrite 했을 때 버전이 증가된다. 버켓에는 버전을 지정하는 것을 권장한다. 버켓에 버전을 지정해야 하는 이유 의도하지 않은 삭제로부터 보호. 버전 복원 가능 이전 버전으로 쉽게 롤백이 가능하다. Note versioning을 활성화하기 전 저장되어 버전이 지정되지 않은 파일의 경우 버전은 “null\"이다. 버전 관리를 일시 중단해도 이전 버전은 삭제되지 않음. ","date":"2022-08-01","objectID":"/aws-14-s3/:2:3","tags":["AWS","Amazon S3"],"title":"14. S3 Storage and Data Management","uri":"/aws-14-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"S3 Object의 암호화 ","date":"2022-08-01","objectID":"/aws-14-s3/:3:0","tags":["AWS","Amazon S3"],"title":"14. S3 Storage and Data Management","uri":"/aws-14-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"S3 Object 암호화 방식 Amazon S3에 업로드 된 object는 AWS 서버내에 존재하므로 객체로 접근이 불가능하게 보호해야 한다. object의 암호화를 통해 보안을 강화할 수 있다. 방법 설명 SSE-S3 AWS에서 objects에서 사용하는 키를 처리 및 관리 SSE-KMS AWS Key Management Service를 통해 암호화 키를 관리 SSE-C 사용자가 자신의 암호화 키를 관리 Client Side Encryption 클라이언트에서 암호화 처리 SSE-S3 Amazon S3가 암호화 시 사용할 키를 처리 및 관리 Object는 서버 측에서 암호화 된다. 유형은 AES-256 알고리즘을 사용 SSE-S3 암호화를 사용하려면 아래 헤더를 반드시 설정해야 한다. “x-amz-server-side-encryption\": “AES256” 암호화 키는 S3가 소유하고 S3가 관리한다. SSE-S3 암호화 과정 Object HTTP/S로 헤더값을 지정하여 업로드 헤더를 통해 Amazon S3가 관리하는 데이터키를 통해 object를 encryption하여 버켓에 저장 SSE-KMS AWS Key Management Service(KMS)가 암호화 시 사용할 키를 처리 및 관리한다. KMS에서 사용자 제어 및 감시를 추적한다. Object는 서버 측에서 암호화 된다. SSE-KMS 암호화를 사용하려면 아래 헤더를 반드시 설정해야 한다. “x-amz-server-side-encryption\": ”aws:kms\" SSE-KMS 암호화 과정 Object HTTP/S로 헤더값을 지정하여 업로드 헤더를 통해 Amazon S3에서는 KMS의 사용자의 마스터키를 사용 KMS에서 가져오느 사용자의 마스터키로 object를 encryption하여 버켓에 저장 SSE-C AWS 밖에서 고객이 관리하는 키를 사용하여 서버측에서 데이터를 암호화 고객이 제공하는 암호화 키를 Amazon S3에서는 저장하지 않음 HTTPS를 반드시 사용 암호화 키는 매 요청시 마다 HTTP 헤더에 반드시 추가하여 전송 SSE-C 암호화 과정 Object는 반드시 HTTPS 만 가능하며 헤더에는 고객이 관리하는 암호화 키를 포함 사용자가 제공한 암호화 키로 Object를 암호화 하여 버켓에 저장 버켓에서 obejct를 가져올 때에는 저장당시 암호화 했던 키를 제공 Client Side Encryption Amazon S3 Encryption Client와 같은 라이브러리를 사용하여 클라이언트 측에서 암호화. S3로 전송하기 전에 클라이언트가 직접 데이터를 암호화해야 한다. 데이터를 검색할 때 클라이언트가 직접 데이터를 복호화해야 한다. 고객은 모든 키와 암호화 싸이클은 직접 관리 해야한다. ","date":"2022-08-01","objectID":"/aws-14-s3/:3:1","tags":["AWS","Amazon S3"],"title":"14. S3 Storage and Data Management","uri":"/aws-14-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"전송 암호화 Encryption in transit (SSL/TLS) Amazon S3 endpoint HTTP endpoint : 암호화되지 않음 HTTPS endpoint : encryption in flight 원하는 endpoint를 자유롭게 선택할 수 있지만 HTTPS를 사용하는 것을 권장 대부분의 클라이언트는 HTTPS endpoint를 기본으로 사용한다. SSE-C 방식에서는 반드시 HTTPS가 필수사항 전송계층 상의 암호화를 SSL/TLS 라고 한다. ","date":"2022-08-01","objectID":"/aws-14-s3/:4:0","tags":["AWS","Amazon S3"],"title":"14. S3 Storage and Data Management","uri":"/aws-14-s3/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS RDS RDS는 관계형 데이터 베이스 서비스 Relational Database Service 를 나타내며 SQL 쿼리 언어를 사용하는 데이터베이스를 위한 서비스이다. RDS에서 제공하는 데이터베이스 Postgres MySQL MariaDB Oracle Microsoft SQL Server Aurora - AWS Proprietary database ","date":"2022-08-01","objectID":"/aws-09-rds/:1:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS RDS 사용시 이점 RDS는 다음과 같은 서비스를 관리한다. 프로비저닝 및 OS 패치 자동화 지속적 백업과 특정 timestamp 기준 복구 (Point Time Restore) 대시보드 모니터링 읽기 성능 향상을 위한 읽기 전용 복제본 재해복구 DZ(Disaster Recovery)를 위한 Multi AZ 셋업 가능 업그레이드를 위한 유지보수 확장성 (vertical and horizontal) EBS 스토리지 백업 (gp2 or io1) 그러나 인스턴스에 SSH를 따로 가질 수는 없다. ","date":"2022-08-01","objectID":"/aws-09-rds/:1:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS Backup RDS에서는 자동으로 백업이 실행된다. ","date":"2022-08-01","objectID":"/aws-09-rds/:2:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS 자동백업 매일 수행되는 데이터베이스 전체에 대한 백업(유지 관리 기간 중) RDS에 의해 트랜잭션 로그가 5분 마다 백업된다. → 원하는 시점으로 복원할 수 있는 기능 (가장 오래된 백업의 5분 전으로) 보존기간은 7일 (최대 35일까지 늘릴 수 있다.) ","date":"2022-08-01","objectID":"/aws-09-rds/:2:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"DB 스냅샷 사용자에 의해 수동으로 트리거 된다. 원하는 기간 동안 백업을 보존할 수 있다. ","date":"2022-08-01","objectID":"/aws-09-rds/:2:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS Storage Auto Scaling RDS DB 인스턴스의 스토리지를 동적으로 늘릴 수 있도록 지원한다. RDS가 사용 가능한 데이터베이스 스토리지가 부족함을 감지하면 자동으로 확장 데이터베이스의 스토리지를 수동 확장 방지 Maximum Storage Threshold 최대 스토리지 임계값(최대 제한) 을 설정해야 한다. 예측할 수 없는 워크로드 unpredictable workloads 가 있는 애플리케이션에 적합 모든 RDS 데이터베이스 엔진을 지원 (MariaDB, MySQL, PostgreSQL, SQL Server, Oracle) 자동으로 스토리지가 변경되는 경우 사용가능한 스토리지가 할당된 스토리지의 10% 미만임 최소 5분 이상 지속됨 마지막 수정 후 6시간이 지남 ","date":"2022-08-01","objectID":"/aws-09-rds/:3:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"읽기 확장성을 위한 RDS 읽기 복제본(Read Replicas) 최대 5개 까지 가능 AZ 내, AZ 교차, 리전 교차 읽기 복제본의 복제는 ASYNC이며 읽기 결과는 일관된다. 읽기 복제본은 자체 DB로 승격가능 애플리케이션에서는 읽기 복제본을 활용하기 위해서는 연결 문자열을 업데이트 해야 한다. ","date":"2022-08-01","objectID":"/aws-09-rds/:4:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS 읽기 복제본 사용 사례 애플리케이션 분석을 실행하기 위한 애플리케이션을 실행하려는 경우 읽기 복제본을 생성 후 새로운 워크로드에서 실행하려는 경우 프로덕션의 응용프로그램은 영향받지 않음 읽기 복제본은 SELECT 유형의 문에만 사용 (INSERT, UPDATE, DELETE는 사용불가능) ","date":"2022-08-01","objectID":"/aws-09-rds/:4:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"네트워크 비용 AZ간 데이터가 이동할 때 네트워크 비용이 발생한다. RDS 읽기 복제본를 사용하면 같은 리전이면 복제본의 수수료를 지불하지 않는다. ","date":"2022-08-01","objectID":"/aws-09-rds/:4:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS Multi AZ(Disaster Recovery) 동기식SYNC 으로 복제 하나의 DNS 이름을 가지고 자동으로 standby 데이베이스에 복구 가용성 증가 가용영역의 네트워크가 손실되는 경우 스토리지를 복구한다. 애플리케이션에 수동 개입이 없음 Multi-AZ 복제본은 비용이 발생하지 않음 읽기 복제본은 재해 복구를 위해 다중 AZ로 설정된다. ","date":"2022-08-01","objectID":"/aws-09-rds/:5:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"단일 AZ에서 다중 AZ로 zero downtime operation (DB 중지가 불필요하다) 데이터베이스의 modify 버튼만 클릭하면 된다. 내부적으로 발생하는 절차 스냅샷이 생성 스냅샷에서 새로운 데이터베이스가 AZ에 복원 두 데이터베이스간 동기화 설정 ","date":"2022-08-01","objectID":"/aws-09-rds/:5:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS 보안 - Encryption ","date":"2022-08-01","objectID":"/aws-09-rds/:6:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"At rest 암호화 AWS KMS의 AES-256 암호화를 사용하여 마스터 및 읽기 전용 암호화 가능 암호화 실행 시간을 정의 해야 한다. 마스터 데이터베이스를 암호화하지 않으면 읽기 전용 데이터베이스도 암호화 할 수 없다 Oracle 및 SQL Server에서 TED(Transparent Data Encryption) 사용 가능하다. -\u003e 데이터 암호화의 대안 제안 ","date":"2022-08-01","objectID":"/aws-09-rds/:6:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"In-flight 암호화 SSL 인증서를 통한 데이터 전송중 암호화 데이터베이스를 연결 할 때 신뢰할 수 있는 인증서로 SSL 옵션을 제공하여 SSL을 제공할 수 있다. 모든 클라이언트가 SSL 사용하게 하려면 PostgreSQL AWS RDS Console (Parameter Groups) rds.force_ssl=1 MySQL 데이터베이스 내부에서 실행 GRANT USAGE ON *.* TO 'mysqluser'@'%' REQUIRE SSL; ","date":"2022-08-01","objectID":"/aws-09-rds/:6:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"암호화 옵션 RDS 백업 암호화 암호화되지 않은 RDS 데이터베이스의 스냅샷은 암호화되지 않음. 암호화 된 RDS 데이터베이스만 스냅샷이 암호화 됨 스냅샷을 암호화 된 스냅샷으로 복사할 수 있음 암호화되지 않은 RDS 데이터베이스 암호화 암호화되지 않은 데이터베이스의 스냅샷을 생성한다. 생성한 스냅샷을 복사하고 복사한 스냅샷에 대한 암호화를 활성화 한다. 암호화 된 스냅샷에서 데이터베이스를 복원한다. 응용프로그램에서 새 데이터베이스로 마이그레이션 후 이전 데이터베이스는 삭제한다. ","date":"2022-08-01","objectID":"/aws-09-rds/:6:3","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS 보안 : Network \u0026 IAM ","date":"2022-08-01","objectID":"/aws-09-rds/:7:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"네트워크 보안 RDS는 일반적으로 public 서브넷이 아닌 private 서브넷에 구축된다. RDS 보안은 보안 그룹을 활용하여 작동하며, RDS와 통신할 수 있는 IP와 보안 그룹을 제어한다. ","date":"2022-08-01","objectID":"/aws-09-rds/:7:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"접근 제어 관리 IAM 정책을 통해(RDS API를 통해) AWS RDS를 관리할 수 있는 사용자를 제어할 수 있다. 기존 사용자 및 암호화를 사용하여 데이터베이스에 로그인 할 수 있다. IAM 기반 인증을 사용하여 RDS MySQL 및 PostgreSQL에 로그인할 수 있다. ","date":"2022-08-01","objectID":"/aws-09-rds/:7:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS IAM Authentication IAM 데이터베이스 인증은 MySQL 및 PostgreSQL과 함께 작동한다. 비밀번호는 필요하지 않고 IAM \u0026 RDS API 호출을 통해 획득한 인증 토큰만 필요하다. 인증토큰은 15분의 lifetime을 갖는다. 장점 네트워크의 in/out은 SSL을 통해 암호화된다. IAM에서 DB 대신에 사용자를 관리 IAM 역할 및 EC2 인스턴스 프로파일을 활용하여 손쉽게 통합 가능하다. ","date":"2022-08-01","objectID":"/aws-09-rds/:7:3","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"RDS 보안 요약 ","date":"2022-08-01","objectID":"/aws-09-rds/:8:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Encryption at rest DB 인스턴스를 처음 생성할 때만 수행 암호화 되지 않은 DB -\u003e 스냅샷 생성 -\u003e 스냅샷을 암호화된 것으로 복사 -\u003e 스냅샷에서 DB 생성 ","date":"2022-08-01","objectID":"/aws-09-rds/:8:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"사용자가 해야할 일 데이터베이스 보안그룹의 ports/ip/security group 인바운드 규칙 확인한다. 데이터베이스 내 모든 사용자 생성 및 권한을 관리 (IAM을 통한) public 액세스가 없는 데이터베이스를 생성 파라미터 그룹과 데이터베이스가 SSL 연결만 허용하도록 구성하여 암호화되는지 확인 ","date":"2022-08-01","objectID":"/aws-09-rds/:8:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS 하는일 SSH 액세스가 발생하지 않게 함 사용자가 수동으로 DB 패치를 하지 않아도 됨 사용자가 수동으로 OS 패치를 하지 않아도 됨 사용자가 기본 인스턴스를 확인하지 않아도 됨 ","date":"2022-08-01","objectID":"/aws-09-rds/:8:3","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon Aurora Aurora는 AWS의 독점 기술 (그러나 오픈소스는 아니다.) Postgres 그리고 MySQL은 모두 Aurora DB로 지원된다. 드라이버가 Postgres, mysql 데이터베이스인 것처럼 작동하는 것을 의미 Aurora는 AWS 클라우드에 최적화되어 있으며, RDS의 MySQL 보다 5배, RDS의 Postgres 보다 3배 향상된 성능을 제공한다. 스토리지는 자동으로 10GB, 최대 128 TB 까지 증가 MySQL을 5개의 복제본만 가질 수 있는 반면 Aurora는 15개의 복제본을 가질 수 있다. 복제 프로세스가 더 빠르다 즉각적인 장애 복구. native high availability (HA) RDS에 비해 비용이 20% 높지만 규모가 클 경우 더 효율적 ","date":"2022-08-01","objectID":"/aws-09-rds/:9:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Aurora의 고가용성과 읽기 확장성 6개의 데이터 복제본이 3개의 AZ에 걸쳐 저장 쓰기의 경우 4개의 복제본만 있으면 된다. 읽기 시 3개의 복제본만 있으면 된다. peer-to-peer 복제를 통해 자가 복구한다. 수백개의 볼륨을 걸쳐 스토리지를 스트리핑 쓰기 가능 마스터 하나이다. 30초 이내에 자동으로 마스터 장애 복구 실행 마스터 + 최대 15개의 읽기 전용 제공 리전 간 읽기 전용 복제 지원 ","date":"2022-08-01","objectID":"/aws-09-rds/:9:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora DB Cluster Writer Endpoint : 항상 마스터를 가리킴 Reader Endpoint : 오토 스케일링 된 읽기 전용 복제본 로드 밸런싱 ","date":"2022-08-01","objectID":"/aws-09-rds/:9:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora의 기능 장애복구 자동화 백업과 복원 격리 및 보안 업계 규정 준수 푸시 버튼 스케일링 자동화 된 무중단 패치 향상된 모니터링 정기 유지보수 Backtrack : 백업을 사용하지 않고 언제든지 데이터를 복원 ","date":"2022-08-01","objectID":"/aws-09-rds/:10:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora 보안 RDS와 비슷한 수준의 보안 (같은 엔진을 사용) KMS 사용한 at rest 암호화 자동화된 백업, 스냅샷 그리고 암호화된 복제본 SSL을 사용한 전송중 암호화 (MySQL, Postgres와 같은) IAM 토큰을 사용한 인증이 가능 (RDS와 같은 방식) 사용자는 보안그룹을 통해 인스턴스를 보호해야 한다. SSH에 접근할 수 없다. ","date":"2022-08-01","objectID":"/aws-09-rds/:11:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora Replicas ","date":"2022-08-01","objectID":"/aws-09-rds/:12:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora Auto Scaling Aurora auto scaling Aurora 인스턴스 3개가 있다고 가정 Writer Endpoint : 1개 Reader Endpoint : 2개 많은 읽기 요청으로 CPU사용량 증가 Aurora 복제본이 추가되고 자동으로 Reader Endpoint가 새 복제본을 포함하도록 확장 CPU 사용량을 낮추기 위해 분산된 방식으로 새로운 복제본이 트래픽 수신 ","date":"2022-08-01","objectID":"/aws-09-rds/:12:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora Custom Endpoints 사용자 지정 Endpoints로 Aurora 인스턴스의 하위 집합을 정의 예시) 특정 복제본에 대한 분석 쿼리를 실행할 때 일반적으로 사용자 정의 Endpoints를 정의한 후 Reader Endpoint는 정의하지 않는다. Aurora custom endpoints Aurora 두 종류 복제본이 있다고 가정 복제본 db.r3.large : 2개 복제본 db.r5.xlarge : 2개 - 용량이 더 큼 특정 읽기전용 데이터베이스에 분석 쿼리 실행 용량이 더 큰 인스턴스 서브셋을 사용자 endpoint로 정의 ","date":"2022-08-01","objectID":"/aws-09-rds/:12:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora Serverless 자동화 된 데이터베이스 인스턴스 및 실제 사용량을 기반으로 한 오토 스케일링 제공 간헐적이거나 예측할 수 없는 워크로드에 적합 용량 측정이 필요 없다 초당 비용 지불. 비용측면에서는 효과적 Aurora Serverless Aurora에서 관리하는 Proxy Fleet과 통신 백엔드에서는 서버리스 방식으로 워크로드를 기반으로 한 Aurora 인스턴스 생성 ","date":"2022-08-01","objectID":"/aws-09-rds/:12:3","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Multi-Master 쓰기 전용 마스터에 즉각적인 장애 조치가 필요한 경우.(Writer 노드에 고가용성이 필요한 경우) 모든 노드가 읽기와 쓰기 작업을 진행 쓰기 노드가 다운될경우 읽기 본제본을 새로운 마스터로 승격 ","date":"2022-08-01","objectID":"/aws-09-rds/:12:4","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"글로벌 Aurora Aurora 리전 간 읽기 복제 재해복구에 유용 간단하게 구현 Aurora Global Database(추천) 하나의 읽기/쓰기 기본 리전 Primary Region 5개까지 보조 리전 설정 가능 : 읽기 전용이며, 보조 리전당 랙은 1초 미만 리전당 최대 16개의 읽기 전용 복제본을 가질 수 있다. 대기 시간 단축에 도움 RTO가 있으므로 복구 시간 목표는 1분 미만 ","date":"2022-08-01","objectID":"/aws-09-rds/:12:5","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Aurora Machine Learning SQL을 통해 ML 기반의 예측을 애플리케이션에 추가 Aurora와 AWS ML 서비스를 쉽고, 최적화, 안전하게 통합할 수 있다. 지원되는 서비스 Amazon SageMaker (use with any ML model) Amazon Comprehend (for sentiment analysis) ML 경험이 없어도 된다. 사용사례 사기탐지, 광고 타게팅, 감정분석, 제품 추천 Amazon ElastiCache 캐시는 높은 성능과 낮은 지연 시간을 가진 in-memory 데이터베이스를 의미한다. RDS 동일한 방식으로 관계형 데이터베이스를 관리 Redis와 Memcached와 같은 캐시 기술 관리 읽기 집약적인 워크로드 부하를 줄일 수 있다. 애플리케이션에서 상태를 관리하지 않아도 된다. OS 운영, 패치, 최적화, 설치, 구성, 모니터링, 장애복구, 백업등의 기능을 AWS에서 주관한다. ElasticCache를 사용하면 애플리케이션 코드를 향상시킬 수 있다. ","date":"2022-08-01","objectID":"/aws-09-rds/:12:6","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"ElastiCache Solution Architecture ","date":"2022-08-01","objectID":"/aws-09-rds/:13:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"DB Cache 애플리케이션은 ElasticCache에서 쿼리 할 수 없는 경우 RDS에서 가져와 ElasticCache에 저장한다. RDS에 부하 완화 지원 캐시에는 최신 데이터만 사용 할 수 있도록 무효화 전략 필요 ","date":"2022-08-01","objectID":"/aws-09-rds/:13:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"사용자 세션 저장 사용자의 세션 데이터를 ElasticCache에 저장 애플리케이션은 ElasticCache에서 직접 사용자의 세션캐시를 검색 다른 인스턴스로 접근시에도 사용자 재로그인이 필요 없음 ","date":"2022-08-01","objectID":"/aws-09-rds/:13:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Redis vs Memcached ","date":"2022-08-01","objectID":"/aws-09-rds/:14:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Redis 자동화 된 재해 복구 + 다중 AZ 읽기 복제본을 통한 읽기 확장 및 고 가용성 AOP 지속성을 이용한 내구성 백업 및 복원 기능 ","date":"2022-08-01","objectID":"/aws-09-rds/:14:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Memcached 데이터를 파티셔닝 한 다중 노드 (sharding) 가용성이 낮음 복제 X. 지속성 X 백업 및 복원 기능 없음 다중 스레드 설계 분산 캐시 ","date":"2022-08-01","objectID":"/aws-09-rds/:14:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Cache Security IAM authentication 지원하지 않음 ElasticCache는 AWS API 수준 보안에서만 사용 ","date":"2022-08-01","objectID":"/aws-09-rds/:15:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Redis Auth 레디스 클러스터를 생성할 때 비밀번호나 토큰을 설정할 수 있다. 이는 security group에 대한 추가적인 수준의 보안 SSL 전송 중 암호화 지원 ","date":"2022-08-01","objectID":"/aws-09-rds/:15:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Memcached SASL 기반 인증 지원 ","date":"2022-08-01","objectID":"/aws-09-rds/:15:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"데이터 로드 패턴 ","date":"2022-08-01","objectID":"/aws-09-rds/:16:0","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Lazy Loading 모든 데이터를 읽은 후 캐시한 데이터를 로딩 할 수 있다. ","date":"2022-08-01","objectID":"/aws-09-rds/:16:1","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Write Through DB에 데이터를 쓸 때 캐시 데이터 추가 및 업데이트 요청 ","date":"2022-08-01","objectID":"/aws-09-rds/:16:2","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Session Store 임시 세션 데이터를 캐시에 저장 (TTL 기능 사용) ","date":"2022-08-01","objectID":"/aws-09-rds/:16:3","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Redis Use Case 게이밍 리더보드 계산 Redis Sorted set은 고유성과 순서 모두를 보장한다. 새 요소가 추가 될 때마다 실시간으로 순위 책정 ","date":"2022-08-01","objectID":"/aws-09-rds/:16:4","tags":["Amazon RDS","Aurora","ElastiCache"],"title":"9. Amazon RDS, Aurora \u0026 ElastiCache","uri":"/aws-09-rds/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"확장성(Scalability) 및 고가용성(High Availability) 확장성은 애플리케이션/시스템이 더 큰 부하를 처리할 수 있게 적용되는 것을 의미 확장성 종류 Vertical Scalability Horizontal Scalability (= 탄력성elasticity) 확장성은 고 가용성(HA)과 연결되어 있지만 서로다르다. ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:1:0","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Vertical Scalability 수직적 확장은 인스턴스 크기를 증가 시키는 것을 의미 예시) t2.micro -\u003e t2.large로 확장 수직적 확장성은 데이터베이스와 같은 비분산 시스템에서 매우 일반적 RDS, ElastiCache는 수직 확장이 가능한 서비스 일반적으로 수직확장에는 제한이 있음(하드웨어 제한) ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:1:1","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Horizontal Scalability 수평적 확장은 애플리케이션의 인스턴스 혹은 시스템 수 증가 분산 시스템을 의미 웹 애플리케이션/현대 애플리케이션에서 매우 일반적 Amazon EC2와 같은 클라우드 제품 덕분에 수평확장 용이 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:1:2","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"High Availability 고가용성(HA)은 일반적으로 수평 확장과 함께 제공 최소 두 개의 데이터 센터(=AZ)에서 애플리케이션 및 시스템을 실행하는 것을 의미 고가용성의 목표는 데이터 센터 손실에서 살아 남는 것 고가용성은 수동적일 수 있음 (RDS Multi AZ의 경우) 고가용성은 활성화 할 수 있음 (수평적 확장을 위해) ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:1:3","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2를 위한 고가용성 및 확장성 Vertical Scaling : 인스턴스 사이즈를 늘린다.(=scale up/down) Horizontal Scaling : 인스턴스 갯수를 늘린다. (=scale out/in) High Availability : 여러 AZ에서 동일한 애플리케이션에 대한 인스턴스를 실행 Auto Scaling Group multi AZ Load Balancer multi AZ ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:1:4","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Load balancing 로드 밸런싱은 트래픽을 여러 서버(e.g., EC2 인스턴스) 다운스트림으로 전달하는 서버를 의미 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:2:0","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Load balancer를 사용하는 이유 여러 다운스트림을 인스턴스에 로드 분산 애플리케이션에 단일 액세스 지점(DNS) 노출 다운스트림 인스턴스의 장애를 원할하게 처리 인스턴스의 정기적인 상태 검사 수행 웹 사이트에 대한 SSL termination (HTTPS) 제공 Enforce stickiness with cookies 영역간 고가용성 공용 트래픽과 사설 트래픽 분리 Elastic Load Balancer를 사용하는 이유 Elastic Load Balancer는 AWS에 의해 관리되는 로드 밸런서 AWS에 의해 동작이 보장된다. AWS가 업그레이드, 유지보수, 고가용성 관리 AWS는 몇 가지 구성 노브만 제공 자체 로드 밸런서를 설정하는 것은 비용이 덜 들지만 훨씬 더 많은 수고가 필요하다. AWS의 많은 제품/서비스와 통합 가능 EC2, EC2 Auto Scaling Groups, Amazon ECS AWS Certificate Manager(ACM), CloudWatch Route 53, AWS WAF, AWS Global Accelerator ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:2:1","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Health Checks 상태체크(Health Checks)는 로드 밸런싱 장치에서 매우 중요하다. 로드 밸런서는 트래픽을 전달하는 인스턴스가 요청에 응답할 수 있는지 여부를 알 수 있도록 한다. 상태 점검은 포트 및 route에서 수행한다. (/health 는 공통임) 200 응답이 아닌경우 인스턴스는 상태가 올바르지 못하다. ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:2:2","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS 로드 밸런서 종류 AWS는 4가지 로드밸런스가 존재한다. Load balancer 종류 Classic Load Balancer CLB v1(2009) HTTP, HTTPS, TCP, SSL(Secure TCP) Application Load Balancer ALB v2(2016) HTTP, HTTPS, WebSocket Network Load BalancerNLB v2(2017) TCP, TLS(secure TCP), UDP Gateway Load BalancerGWLB(2020) Operates at layer3 (Network layer) - IP Protocol 전반적으로 새로운 세대의 로드 밸런서는 더 많은 기능을 제공하므로 사용하는 것이 좋다. 일부 로드 밸런서는 내부(private), 외부(public) ELB로 설정가능 Classic Load Balancers (v1) TCP(Layer 4), HTTP \u0026 HTTPS(Layer 7) 지원 상태 검사는 TCP 또는 HTTP 기반 고정 hostname : http://xxx.region.elb.amazonaws.com/ Application Load Balancer (v2) Layer 7 (HTTP) 여러 시스템(target groups)에서 여러 HTTP 애플리케이션에 대한 로드 밸런싱 동일한 시스템의 여러 애플리케이션에 대한 로드 밸런싱(example: containers) HTTP/2 및 웹 소켓 지원 redirects 지원 (예: HTTP -\u003e HTTPS) 다른 대상 그룹으로 라우팅 URL 기반 라우팅 example.com/users example.com/post URL hostname 기반 라우팅 one.example.com other.example.com Query string, 헤더 기반 라우팅 example.com/users?id=123\u0026order=false ALB는 마이크로 서비스와 컨테이너 기반 애플리케이션에 매우 적합 (example : Docker \u0026 Amazon ECS) ECS의 동적 포트로 리디렉션하는 포트 매핑 기능 있음 그에 비해, 애플리케이션 당 여러 Classic Load Balancer 가 필요 ALB Target Group(대상 그룹) EC2 인스턴스(Auto Scaling Group에 의해 관리할 수 있는) - HTTP ECS(ECS 자체 관리) Task - HTTP 람다 함수: HTTP 요청이 JSON 이벤트로 변환 IP 주소: 반드시 사설 IP 요청 ALB는 여러 대상 그룹으로 라우팅 할 수 있음 대상 그룹 수준에서 상태 체크가 가능하다. ALB 알아야할 내용 고정 호스트이름 : XXX.region.elb.amazonaws.com 응용 프로그램 서버가 클라이언트 IP를 직접 확인하지 않음 클라이언트 실제 IP가 X-Forwarded-For 헤더에 삽입 포트와 X-Forwarded-Port와 프로토 X-Forwarded-Proto도 가져올 수 있음 Network Load Balancer (v2) Network load balancer(Layer 4)를 통해: TCP, UDP 트래픽을 인스턴스로 전달 초당 수백만 건의 요청 처리 지연 시간 최대 ~100ms(vs 400ms for ALB) 단축 NLB는 AZ당 하나의 정적 IP를 가지며 Elastic IP 할당을 지원(특정 IP 화이트 리스트에 도움이 됨.) TCP 또는 UDP 트래픽의 최고의 성능을 위해 사용 AWS 프리티어에는 포함되지 않음 NLB Target Groups(대상그룹) EC2 인스턴스 IP 주소 : 반드시 사설망 IP Application Load Balancer Gateway Load Balancer AWS에서 써드파티 네트워크 가상 어플라이언스 구축, 확장 및 관리 예시) 방화벽, 침입 탐지 및 차단 시스템, 심층 패킷 검사 시스템, 페이로드 조작 등 Layer 3 (네트워크 Layer)에서 작동 - IP Packets 아래 기능들과 통합할 수 있다. Transparent Network Gateway: 모든 트래픽에 대한 단일 입력 수신 Load Balancer : 가상 어플라이언스로 트래픽 분산 GENEVE protocol 6081 포트로 사용할 수 있다. Gateway Load Balancer - Target Groups EC2 instances IP Addresses : 반드시 private IP ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:2:3","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Stick Sessions (Session Affinity) 동일한 클라이언트가 항상 로드밸런서 뒤에 있는 동일한 인스턴스로 리다이렉션 되도록 고정하는 기능을 구현 CLB \u0026 ALB에서 동작한다. 고정 cookie에는 사용자가 제어하는 만료일자가 있음 사용 사례 : 사용자가 세션 데이터를 잃지 않게 하기 stickiness를 사용하도록 설정하면 백엔드 EC2 인스턴스에 대한 로드가 불균형해질 수 있다. ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:3:0","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Cookie Names Cookie Names description Application-based Cookies Custom cookie · 애플리케이션에 의해 사용자가 지정하는 모든 특성을 포함 가능 · 쿠키 이름은 각 대상 그룹target group에 대해 개별적으로 지정해야 함 · AWSALB, AWSALBAPP,AWSALBTG 등 ELB 예약어는 사용하지 말것Application cookie · 로드밸런서에의해 생성 · 쿠키의 이름은 AWSALBAPP Duration-based Cookies · 로드밸런서에 의해 생성되는 쿠기· ALB의 경우 AWSALB, CLB의 경우 AWSCLB ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:3:1","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Cross-Zone 로드 밸런싱 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:4:0","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Cross-Zone 로드 밸런싱 사용 각 로드 밸런서 인스턴스는 모든 AZ에 등록된 모든 인스턴스에 고르게 분산 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:4:1","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Cross-Zone 로드 밸런싱을 사용하지 않음 요청이 Elastic Load Balancer 노드의 인스턴스에 분산 Load balancer Cross-Zone Load Balancing Application Load Balancer · 항상 동작(비활성화 불가능)· AZ간 요금 없음 Network Load Balancer · 기본적으로 사용 안함· 활성화 된 경우 AZ간 요금 지불 Classic Load Balancer · 기본적으로 사용 안함· 활성화 된 경우 AZ간 데이터 요금 없음 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:4:2","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"SSL/TLS SSL 인증서를 통해 클라이언트와 로드 밸런서 간 트래픽을 전송 중 암호화를 할 수 있다. SSL : 암호화 하는데에 Secure Socket Layer를 사용 TLS : 최신 버전인 전송 보안 계층을 나타낸다. 요즘에는 TLS 인증서가 주로 사용되며 여전히 SSL이라고 부른다. 공용 SSL 인증서는 CA(Certificate Authorities)에 의해 발급된다. SSL 인증서는 만료 날짜가 있으므로 갱신해야 한다. ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:5:0","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Load Balancer - SSL Certificates 로드 밸런서는 X.509 인증서 (SSL/TLS 서버 인증서)를 사용 ACM(AWS Certificate Manager)을 사용하여 인증서를 관리할 수 있음 자신의 인증서를 만들어 업로드도 가능 Http listener 기본 인증서를 지정해야 한다. 여러 도메인을 지원하기 위해 선택적으로 인증 목록을 추가 가능 클라이언트는 SNI(Server Name Indication)를 사용하여 도달하는 호스트 이름을 지정할 수 있다 이전 버전의 SSL/TLS(레거시 클라이언트)를 지원하는 정책 지정 가능 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:5:1","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"SSL - Server Name Indication (SNI) SNI는 여러 개의 SSL 인증서를 하나의 웹 서버에 로드하는 문제를 해결(여러 웹사이트를 서비스하기 위해) 새로운 프로토콜이며 클라이언트가 초기 SSL 핸드쉐이크 대상 서버의 호스트 이름을 표시해야한다. -\u003e 그러면 서버가 올바른 인증서를 찾거나 기본 인증서를 반환 Note 오직 ALB, NLB, CloudFront 에서만 동작 CLB에서는 동작하지 않음 Load balancer SSL 인증서 Classic Load Balancer · 하나의 SSL 인증서만 지원· 여러 SSL을 갖는 여러 호스트 이름에는 여러 CLB를 사용 Application Load Balancer · 여러 SSL 인증서를 가진 리스너 지원· SNI를 사용하여 작동 Network Load Balancer · 여러 SSL 인증서를 가진 리스너 지원· SNI를 사용하여 작동 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:5:2","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Connection Draining 각 ELB 타입마다 이름이 다름 CLB : Connection Draining ALB \u0026 NLB : Deregistration Delay(등록 취소 지연) 인스턴스가 등록 취소 중이거나 정상 상태가 아닌 동안 인스턴스에 어느 정도 시간을 주어 in-flight requests을 완료할 수 있도록 만들어 주는 기능 등록취소de-registering되면 등록 취소 중인 EC2 인스턴스로는 새로운 요청을 보내지 않는다. 1 ~ 3,600초 (기본값 : 300초) 비활성화 가능 (값을 0으로 설정) 요청이 짧은 경우 낮은 값으로 설정 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:6:0","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Auto Scaling Group ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:7:0","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Auto Scaling Group(ASG) 목표 증가하는 로드에 맞게 Scale Out : EC2 인스턴스 추가 감소하는 로드에 맞게 Scale In : EC2 인스턴스 제거 AGS에서 실행되는 최소 및 최대 EC2 인스턴스 수를 보장 새 인스턴스를 자동으로 로드 밸런서에 등록 이전 인스턴스가 비정상 혹은 종료된 경우 EC2 인스턴스 다시 생성 ASG는 무료 (기본 EC2 인스턴스에 대해서만 지불) ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:7:1","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Auto Scaling Group 속성 Launch Template (이전 버전 Launch configurations는 더이상 사용되지 않음) AMI + Instance Type EC2 User Data EBS Volumes Security Groups SSH Key PAir IAM Roles for your EC2 Instance Network + Subnets Information Load Balancer Information Min Size / Max Size / Initial Capacity Scaling 정책 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:7:2","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Auto Scaling - CloudWatch Alarms \u0026 Scaling CloudWatch 알람을 기반으로 AGS를 확장 가능 alarm이 메트릭 등을(CPU 평균 또는 사용자 지정 메트릭) 모니터링 전체 ASG 인스턴스에 대해 평균 CPU와 같은 메트릭이 계산 경보 기준 스케일 아웃 정책 생성 (인스턴스 수 증가) 스케일 인 정책 생성(인스턴스 수 감소) Dynamic Scaling Policies Dynamic Scaling Policies description Target Tracking Scaling(대상추적 스케일링) · 가장 간단하고 쉽게 설정· 예시) 나는 ASG 평균 CPU가 약 40%를 유지하기를 원한다. Simple / Step Scaling · CloudWatch 경보가 트리거되면(CPU \u003e 70%), 2대 추가· CloudWatch 경보가 트리거 되었을 때(CPU \u003c 30%), 1대를 삭제한다. Scheduled Actions · 알려진 사용 패턴을 기반으로 확장 예상 · 예시) 금요일 오후 5시에 최소 용량을 10으로 늘린다. Predictive Scaling 예측 스케일링 : 지속적으로 로드 예측 및 스케줄 확장을 미리 계획한다. ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:7:3","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"확장에 적합한 측정 기준 CPUUtilization(CPU 사용률) : 인스턴스 전체의 평균 CPU 활용률 RequestCountPerTarget(대상당 요청 수) : EC2 인스턴스 당 요청 수가 안정적인지 확인 Average Network In/Out(평균 네트워크 입출력) : 애플리케이션이 네트워크영역인 경우 Any custom metric : CloudWatch를 사용하여 푸시 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:7:4","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Scaling Cooldowns 스케일링 작업이 발생한 후 쿨 다운 타임이 발생(기본값 300초) 쿨 다운 타임동안 ASG는 추가 인스턴스를 시작 혹은 종료하지 않는다. (측정지표가 안정화되도록 허용) Tip 즉시 사용할 수 있는 AMI를 사용하여 요청 시간을 단축하고 쿨 다운 타임을 단축한다. ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:7:5","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"ASG for Solutions Architects ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:8:0","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"ASG 기본 종료 정책 (simplified version) 인스턴스 수가 가장 많은 AZ를 찾는다. AZ에 선택할 인스턴스가 여러 개 있는 경우 가장 오래된 launch configuration을 갖는 인스턴스를 삭제 ASG는 기본적으로 AZ 전체에서 인스턴스 수 균형을 시도 ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:8:1","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"ASG Lifecycle Hooks 기본적으로 ASG에서 인스턴스가 실행되자마자 서비스가 시작된다. Pending state : 인스턴스가 서비스 상태가 되기 전에 추가 단계를 수행할 수 있음 Terminating state : 인스턴스가 종료 되기 전에 일부 작업을 수행할 수 있다. ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:8:2","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Launch Template vs Launch Configuration Launch Template(newer) Launch Configuration(legacy) · 여러 버전을 가질 수 있음 · 매개 변수 하위 집합 생성(재사용성 및 상속을 위한 부분 구성) · On-Demand 및 스팟 인스턴스를 모두 사용하여 프로비저닝 · T2 무제한 버스트 기능 사용 · 향후 AWS에서 권장 매번 다시 만들어야 한다. · Amazon Machine Image(AMI) ID, 인스턴스 유형, Key pair, 보안 그룹, EC2 인스턴스를 사용하는 기타 매개변수(tags, EC2 user-data …) ","date":"2022-07-22","objectID":"/aws-08-fundamentals/:8:3","tags":["Load Balancer","Auto Scaling Groups","Amazon Elastic Block Store(EBS)"],"title":"8. AWS Fundamentals - Load Balancing, Auto Scaling Groups and EBS Volumes","uri":"/aws-08-fundamentals/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EBS Volume EBS(Elastic Block Store) Volume은 볼륨 인스턴스가 실행되는 동안 인스턴스에 연결할 수 있는 네트워크 드라이브이다. 인스턴스가 종료된 후에도 데이터를 유지할 수 있다. 한 번에 하나의 인스턴스에만 마운트 할 수 있다. (CCP 레벨) CCP 레벨 : 하나의 EBS는 하나의 EC2 인스턴스에만 마운트 가능 Associate Level: 일부 EBS 다중 연결 특정 가용 영역에바 바인딩 되어 있다. 네트워크 USB 스틱과 유사하다. 프리티어는 한 달 30GB의 일반 용도 (SSD) 또는 마그네틱 유형으로 제공 ","date":"2022-07-20","objectID":"/aws-07-ebs/:1:0","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EBS Volume 특징 네트워크 드라이브이다.(즉, 물리적인 드라이브가 아님) 네트워크를 사용하여 인스턴스를 통신. 약간의 지연이 있을 수 있다. EC2 인스턴스에 분리하여 다른 인스턴스에 빠르게 연결 가능 AZ에 묶여있다. us-east-1a의 EBS 볼륨을 us-east-1b에 연결할 수 없다. 볼륨을 이동하려면 먼저 스냅샷을 생성해야 한다. 프로비저닝 된 용량(GB 및 IOPS 단위) 프로비저닝 된 모든 용량에 대해 청구 시간이 지남에 따라 드라이브 용량을 늘릴 수 있다. ","date":"2022-07-20","objectID":"/aws-07-ebs/:1:1","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Delete on Termination attribute EC2 인스턴스가 종료될 때 EBS 동작을 제어할 수 있다. 기본적으로 루트 EBS 볼륨은 삭제된다. Delete on Termination : checked(default) 기본적으로 연결된 다른 EBS 볼륨은 삭제되지 않는다.Delete on Termination : unchecked AWS 콘솔 및 CLI에서 설정 가능하다. 인스턴스 종료 시 루트 볼륨을 유지하고 싶으면 체크를 해제한다. ","date":"2022-07-20","objectID":"/aws-07-ebs/:1:2","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EBS 스냅샷 특정 시점에 EBS 볼륨의 백업(Snapshot)을 만들 수 있다. 스냅샷을 위해 볼륨을 분리할 필요는 없지만 권장 AZ 또는 리전 간 스냅샷 복사 가능 ","date":"2022-07-20","objectID":"/aws-07-ebs/:2:0","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EBS 스냅샷 기능 스냅샷 기능 설명 EBS Snapshot Archive · 75% 더 저렴한 비용으로 archive tier로 스냅샷을 전송한다.· 아카이브를 복원하는데 24 ~ 72 시간 소요 Recycle Bin for EBS Snapshot · 실수로 삭제한 후 복구할 수 있도록 삭제된 스냅샷을 보존하는 규칙을 설정· 보존 기간은 1일 ~ 1년 ","date":"2022-07-20","objectID":"/aws-07-ebs/:2:1","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AMI Amazon Machine Image AMI는 EC2 인스턴스를 커스터마이징 한 것 소프트웨어, 구성, 운영체제, 모니터링 등 모든 소프트웨어가 사전 패키지화되어 있어 부팅 및 구성 시간 단축 AMI는 특정 리전만을 위해 구축되며 여러 리전간 복사 가능 다음 위치에서 EC2 인스턴스 시작 A Public AMI : AWS 제공 Your own AMI : 사용자가 직접 만들고 관리 AWS Marketplace AMI : 다른 사용자가 AMI를 만듬 (잠재적으로 판매) ","date":"2022-07-20","objectID":"/aws-07-ebs/:3:0","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AMI 프로세스 (EC2 인스턴스) EC2 인스턴스를 시작하고 커스터마이징 한다. 인스턴스를 중단한다. (데이터 무결성을 위해) AMI 빌드 한다. - EBS 스냅샷도 생성 다른 인스턴스에서 AMI를 실행 ","date":"2022-07-20","objectID":"/aws-07-ebs/:3:1","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 Instance Store EBS 볼륨은 좋지만 제한적인 성능을 갖는 네트워크 드라이브임 고성능의 하드웨어 디스크가 필요할 경우 EC2 Instance Store를 사용 I/O 성능 향상 EC2 Instance Store가 중지되면 스토리지가 손실 (ephemeral) buffer / cache / scratch data / temporary content 에 적합 하드웨어 장애 시 데이터 손실의 위험 백업 및 복제는 사용자의 책임 ","date":"2022-07-20","objectID":"/aws-07-ebs/:4:0","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EBS 볼륨 유형 EBS 볼륨은 6가지 유형으로 제공 EBS 볼륨 유형 특징 gp2/gp3 (SSD) 다양한 워크로드에 대하 가격과 성능을 맞추는 범용 SSD 볼륨 io1/io2 (SSD) mission-critical, 짧은 대기 시간 또는 높은 처리량 워크로드를 위한 최고성능 SSD 볼륨 st1(HDD) 자주 액세스하는 throughput-intensive 워크로드를 위해 설계된 저비용 HDD 볼륨 sc1(HDD) 액세스 빈도가 낮은 워크로드에 맞게 설계된 최저 비용 HDD 볼륨 EBS 볼륨은 Size | Throughput | IOPS(I/O Ops Per Sec) 으로 구분할 수 있다. 오직 gp2/gp3,io1/io2 만 부팅 볼륨으로 사용 가능 ","date":"2022-07-20","objectID":"/aws-07-ebs/:5:0","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"General Purpose SSD General Purpose SSD Volume type gp3 gp2 Durability 99.8% - 99.9% durability (0.1% - 0.2% annual failure rate) Use cases 대기시간이 짧은 대화형 애플리케이션 개발 또는 테스트 환경 가상 데스크톱 Medium-sized single-instance databases Boot volumes Volume size 1 GiB - 16 TiB Max IOPS per volume (16 KiB I/O) ** 16,000 Max throughput per volume ** 1,000 MiB/s 250 MiB/s * Amazon EBS Multi-attach Not supported Boot volume Supported ","date":"2022-07-20","objectID":"/aws-07-ebs/:5:1","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Provisioned IOPS(PIOPS) SSD 지속적인 IOPS 성능을 제공하는 비즈니스 애플리케이션 또는 16,000 이상의 IOPS가 필요한 애플리케이션 데이터베이스 워크로드에 적합 (스토리지 성능 및 일관성 민감한) Multi-attach EBS 지원 Provisioned IOPS SSD Volume type io2 Block Express * io2 io1 Durability 99.999% durability (0.001% annual failure rate) 99.999% durability (0.001% annual failure rate) 99.8% - 99.9% durability (0.1% - 0.2% annual failure rate) Use cases Workloads that require: Sub-millisecond latency 지속적인 IOPS 성능 More than 64,000 IOPS or 1,000 MiB/s of throughput Workloads that require sustained IOPS performance or more than 16,000 IOPS I/O-intensive database workloads Volume size 4 GiB - 64 TiB 4 GiB - 16 TiB Max IOPS per volume (16 KiB I/O) 256,000 64,000 † Max throughput per volume 4,000 MiB/s 1,000 MiB/s † Amazon EBS Multi-attach Supported Boot volume Supported ","date":"2022-07-20","objectID":"/aws-07-ebs/:5:2","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Hard Disk Drives(HDD) 부팅 볼륨으로 사용할 수 없음 Throughput Optimized HDD Cold HDD Volume type st1 sc1 Durability 99.8% - 99.9% durability (0.1% - 0.2% annual failure rate) 99.8% - 99.9% durability (0.1% - 0.2% annual failure rate) Use cases Big data Data warehouses Log processing 액세스 빈도가 낮은 데이터를 처리하기 위한 throughput-oriented 스토리지 가장 낮은 스토리지 비용이 중요한 시나리오 Volume size 125 GiB - 16 TiB 125 GiB - 16 TiB Max IOPS per volume (1 MiB I/O) 500 250 Max throughput per volume 500 MiB/s 250 MiB/s Amazon EBS Multi-attach Not supported Not supported Boot volume Not supported Not supported ","date":"2022-07-20","objectID":"/aws-07-ebs/:5:3","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EBS Multi-Attach – io1/io2 family 동일한 AZ의 여러 EC2 인스턴스에 동일한 EBS 볼륨 연결 각 인스턴스에는 볼륨에 대한 전체 읽기 및 쓰기 권한 있음 파일 시스템은 반드시 cluster-aware 사용해야 함(XFS, EX4는 사용할 수 없음) Use case 클러스터링 된 리눅스 애플리케이션에서 애플리케이션 가용성 향상 (example: Teradata) 애플리케이션의 동시 쓰기 작업을 관리해야 하는 경우 ","date":"2022-07-20","objectID":"/aws-07-ebs/:6:0","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EBS Encryption 암호화 된 EBS 볼륨을 생성하면 다음이 표시된다. 저장된 데이터는 볼륨 내부에서 암호화 된다. 인스턴스와 볼륨 사이를 이동하는 이동중인 모든 데이터가 암호화 된다. 모든 스냅샷이 암호화 된다. 스냅샷에서 생성된 모든 볼륨이 암호화 된다. 암호화 및 복호화가 알아서 처리된다. (사용자는 할일이 없음) 암호화는 대기 시간에 미치는 영향을 최소화 한다. EBS 암호화는 KMS의 키를 활용한다. (AES-256) 암호화되지 않은 스냅샷은 복사하면 암호화가 가능 암호화된 불륨의 스냅샷은 암호화되어 있다. ","date":"2022-07-20","objectID":"/aws-07-ebs/:7:0","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"암호화되지 않은 EBS 볼륨을 암호화하기 EBS 볼륨의 스냅샷을 생성한다. EBS 스냅샷을 암호화한다. (using copy) 생성한 스냅샷에서 새로운 EBS 볼륨을 만든다. (만든 볼륨은 암호화) 암호화된 볼륨을 원래 인스턴스에 연결 ","date":"2022-07-20","objectID":"/aws-07-ebs/:7:1","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon EFS – Elastic File System 여러 EC2에 마운트 할 수 있는 관리형 NFS(network file system) EFS는 다중 AZ의 EC2 인스턴스와 함께 작용한다. 고 가용성, 확장성, expensive(3x gp2), 사용당 지불 사용 사례 : 컨텐츠 관리, Web 서비스 제공, 데이터 쉐어링, 워드 프레스 등 NFSv4.1 protocol 사용 보안 그룹을 통해 EFS 액세스를 컨트롤 Linux 기반 AMI 호환 (윈도우즈 아님) KMS를 사용한 at-rest 암호화 표준 파일 API가 있는 Linux POSIX 파일 시스템 파일 시스템 자동 확장, 사용량별 지불, 용량 계획 없음 ","date":"2022-07-20","objectID":"/aws-07-ebs/:8:0","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EFS 성능 및 스토리지 Classes Performance \u0026 Storage Classes EFS Scale · 1,000대의 NFS 동시 클라이언트 : 10 GB+/s 처리량· 페타바이트 규모의 네트워크 파일 시스템으로 자동 확장 Performance mode (set at EFS creation time) · 범용 목적 (기본) : 지연 시간에 민감한 사용 사례 (웹서버, CMS 등)· MAX I/O : 지연 시간, 처리량, 병렬 처리(빅데이터, 미디어 프로세싱등) Throughput mode · Bursting(1TB=50MiB/s + 최대 100MiB/s 버스트) · 프로비저닝 : 스토리지 크기에 상관없이 처리량 설정(ex: 1 GiB/s for 1 TB 스토리지) ","date":"2022-07-20","objectID":"/aws-07-ebs/:8:1","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EFS - Storage Classes Storage Tiers (라이프 사이클 관리 기능 - N일 후 파일 이동) Standard : 자주 액세스 하는 파일용 Infrequent access (EFS-IA) : 파일 검색 비용, 저장 비용 절감 라이프 사이클 정책을 사용하여 EFS-IA 사용 가용성 및 내구성 Regional : Multi-AZ, 프로덕션 환경에 최적 One Zone : 개발 환경에 적합한 단일 환경, 기본적으로 백업 지원 IA(EFS One Zone-IA)와의 호환성 90% 이상의 비용 절감 ","date":"2022-07-20","objectID":"/aws-07-ebs/:8:2","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EBS vs EFS EBS EFS • 한 번에 하나의 인스턴스만 연결• AZ 수준에서 묶임• gp2 : 디스크 크기가 증가하면 IO가 증가한다.• io1 : 독립적으로 IO 증가 가능 • AZ 전체에 수백 개의 인스턴스 마운트 가능• EFS는 웹사이트의 파일을 공유할 때 사용할 수 있다.(워드 프레스)• 오직 POSIX만 지원• EFS는 EBS 보다 높은 가격대를 가지고 있다.• EFS-IA를 활용하여 비용 절감 가능 • AZ에서 EBS 볼륨을 마이그레이션하려면 • 스냅샷을 생성한다. • 다른 가용영역으로 스냅샷을 복구한다. • EBS 백업은 IO를 사용하므로 응용프로그램이 많은 트래픽을 처리하는 동안 실행해서는 안된다. • 루트 EBS는 EC2 인스턴스가 종료되면 인스턴스 볼륨이 기본적으로 종료된다. (비활성화 가능) ","date":"2022-07-20","objectID":"/aws-07-ebs/:9:0","tags":["AWS","Amazone EC2","Amazon Elastic Block Store(EBS)","Amazon Elastic File System(EFS)"],"title":"7. AWS EC2 Instance Storage","uri":"/aws-07-ebs/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Global Infrastructure Note AWS Regions AWS Availability Zones AWS Data Centers AWS Edge Locations / Points of Presence ","date":"2022-07-17","objectID":"/aws-00-regions-az/:0:0","tags":["AWS"],"title":"AWS Overview","uri":"/aws-00-regions-az/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Regions 데이터 센터의 집합 cluster of data centers 대부분의 AWS 서비스들은 특정 리전에 국한region-scoped되어 있다. 각 Region은 최소 두 개 이상의 개별 가용 영역Availability Zones로 구성 ","date":"2022-07-17","objectID":"/aws-00-regions-az/:1:0","tags":["AWS"],"title":"AWS Overview","uri":"/aws-00-regions-az/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Region을 선택하는 방법 Compliance with data governance and legal requirements : 데이터의 법률 준수 및 요구사항 Proximity to customers: : 고객과의 접근성. 대기시간 단축 Available services within a Region : 특정 리전에서만 가능한 AWS 서비인지 확인 Pricing : 비용은 지역에 따라 가격이 다르다. ","date":"2022-07-17","objectID":"/aws-00-regions-az/:1:1","tags":["AWS"],"title":"AWS Overview","uri":"/aws-00-regions-az/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Availability Zones 각각의 리전은 많은 가용영역으로 구성 (보통은 3개 최소 2개 최대 6개로 구성) ap-southeast-2a ap-southeast-2b ap-southeast-2c 다른 가용영역(AZ)의 장애로부터 격리되어 있다. 고대역폭, 초저지연 네트워킹으로 서로 연결되어 리전을 형성. ","date":"2022-07-17","objectID":"/aws-00-regions-az/:2:0","tags":["AWS"],"title":"AWS Overview","uri":"/aws-00-regions-az/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Points of Presence (Edge Locations) Amazon CloudFront에서는 현재 410개 넘는 상호 접속위치(POP)(엣지 로케이션 400개 이상, 리전별 중간 티어 캐시 13개)로 구성된 글로벌 네트워크를 사용 최종 사용자에게 짧은 지연 시간과 높은 처리량의 컨텐츠를 제공할 수 있다. [출처] https://aws.amazon.com/ko/cloudfront/features/ ","date":"2022-07-17","objectID":"/aws-00-regions-az/:3:0","tags":["AWS"],"title":"AWS Overview","uri":"/aws-00-regions-az/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"STS - Security Token Service AWS 리소스에 대한 제한적이고 일시적인 액세스 권한을 허용 토큰은 1 시간까지 유효 (새로고침 필요) ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:1:0","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"STS API STS API 설명 AssumeRole - 개인 계정 내에서: 보안을 강화하기 위해 사용 - 계정 간 : 대상 계정에 역할을 수임하여 작업을 수행 AssumeRoleWithSAML - SAML으로 로그인한 사용자의 자격증명을 반환 AssumeRoleWithWebIdentity - IdP(Identity Provider - Facebook Login, Google Login, OIDC Compatible…) 로그인 사용자의 자격증명을 반환 - 이것보다는 AWS Cognito 추천함 GetSessionToken - AWS 루트 계정 또는 사용자에 대한 MFA 인증 ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:1:1","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"STS를 통해 역할을 수임받기 IAM 계정 내 혹은 계정 간 IAM 역할(Role)을 정의한다. 사용자, 역할 등이 액세스 할 수 있는 IAM Role 원칙(Principal)을 정의한다. AWS STS(Security Token Service) 사용하여 IAM 역할을 가장할 수 있는 임시자격증명을 조회할 수 있다. (AssumeRole API) 그림 임시자격증명 정보는 15분 ~ 1시간사이의 유효시간을 갖는다. ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:1:2","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"계정 간 STS https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_common-scenarios_aws-accounts.html 프로덕션 계정의 관리자는 개발계정의 사용자들이 productionapp 버켓의 읽기/쓰기 IAM 역할을 얻을 수 있는 UpdateApp을 생성 개발계정의 관리자는 Developer 그룹의 멤버들을 UpdateApp 역할의 STS AssumeRole API를 호출 할 수 있는 권한을 부여 개발계정의 사용자는 역할 전환을 요청 AWS STS는 역할 임시자격증명을 반환 임시 자격 증명은 AWS 리소스에 대한 액세스를 허용 ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:1:3","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Identity Federation in AWS Federation을 통해 AWS 외부의 사용자가 AWS 리소스에 액세스하는 임시 역할을 수행 ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:2:0","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Federations의 종류 SAML 2.0 Custom Identity Broker Web Identity Federation with Amazon Cognito Web Identity Federation without Amazon Cognito Single Sign On Non-SAML with AWS Microsoft AD federation을 사용하면 IAM 사용자를 생성할 필요 없다. (사용자 관리는 AWS 외부에 있다.) 그림 SAML 2.0 Federation Active Directory ADFS(Active Directory Federation Service) AWS 콘솔 또는 CLI로 액세스 제공 (임시 보안 인증 이용) 직원별로 IAM 사용자를 생성할 필요 없다. AWS IAM과 SAML 사이에 신뢰 설정이 필요하다. SAML 2.0을 통해 웹 기반 크로스 도메인을 지원한다(SSO) STS API : AssumeRoleWithSAML SAML을 통한 federation 방식은 오래된 방식이다. -\u003e Amazon Single Sign On(SSO) 을 통한 federation은 심플하고 새로운 방식 Using SAML-based federation for API access to AWS https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html 조직의 사용자가 클라이언트 앱을 사용하여 조직의 IdP에서 인증을 요청 IdP는 조직의 ID 저장소에 대한 사용자 인증 IdP는 사용자에 대한 정보로 SAML assertion 구성 -\u003e 클라이언트 앱으로 전송 클라이언트 앱은 AWS STS AssumeRoleWithSAML API 호출 SAML 공급자 ARN, 수임할 역할의 ARN 및 IdP의 SAML assertion 전달 클라이언트 앱에 대한 API 응답에 임시 자격 증명 포함 클라이언트 앱은 임시 자격 증명을 사용하여 Amazon S3 API 호출 AWS Management Console을 사용하여 SAML 2.0 federation 활성화 SAML 2.0 Assertion는 자격증명과 호환되며 STS 리소스나 콘솔에 액세스 할 수 있게 해준다. https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-saml.html Active Directory FS ADFS가 SAML 2.0과 호환된다면 과정은 동일하다. https://aws.amazon.com/ko/blogs/security/aws-federated-authentication-with-active-directory-federation-services-ad-fs/ 브라우저 인터페이스로 ADFS 로그인 ADFS는 사용자가 제대로 인증되었는지 Identity Store를 통해 확인 ADFS는 SAML Assertion을 반환 SAML Assertion을 AWS STS 통해 역할과 교환 (Sign-in) 임시 자격 증명은 STS AssumeRoleWithSAML을 사용하여 반환 사용자가 인증되고 AWS 관리 콘솔에 대한 액세스 권한이 제공 Custom Identity Broker Application IdP가 SAML 2.0과 호화되지 않는 경우에 사용 identity 브로커가 적절한 IAM 정책을 결정해야 한다. 사용 STS API : AssumeRole or GetFederationToken https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_common-scenarios_federated-users.html 자격 증명 브로커는 IAM STS API AssumeRole과 GetFederationToken API를 이용하여 클라이언트가 AWS 콘솔과 API 등에 액세스 할 수 있게 한다. Web Identity Federation - AssumeRoleWithWebIdentity Client-Side에서 AWS에 액세스 하기위해서는 -\u003e AWS Cognito를 사용하기를 권장한다. ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:2:1","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Cognito 목적 : Client Side(모바일, 웹)에서 AWS 리소스를 직접 액세스 제공 사용예시 : 페이스북 로그인하여 S3 쓰기 작업을 할 수 있는 임시 권한을 제공하고 싶은 경우 문제 : 그때마다 IAM 사용자를 생성해야 한다. 어떻게 federated IdP로 로그인 또는 익명 아이디 Federated Identity Pool로부터 AWS 임시 자격증명을 얻는다. 이러한 자격증명은 사용 권한을 명시하는 미리 정의된 IAM 정책과 함께 제공 ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:2:2","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Microsoft Active Directory (AD) Found on any Windows Server with AD Domain Services Database of objects: User Accounts, Computers, Printers, File Shares, Security Groups 중앙 집중식 보안 관리, 계정 생성, 권한 할당 Objects는 trees로 구성되어 있다. trees의 그룹은 forest라고 한다. ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:2:3","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Directory Services AWS Directory Services AWS Managed Microsoft AD - AWS에서 자신만의 AD를 만들고 로컬에서 사용자를 관리 - MFA 지원 - Establish “trust” connections with your on-premises AD AD Connector - on-premises AD로 리다이렉션 Directory Gateway(proxy) - MFA 지원- 사용자는 온프레미스 AD에서 관리 Simple AD - AD 호환 관리 디렉토리 - on-premises AD와 결합할 수 없다. ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:2:4","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Organizations 글로벌 서비스 여러 AWS 계정 관리 기본 계정이 마스터 계정이므로 변경할 수 없다. (기타 계정은 회원 계정) 회원 계정은 한 조직의 일부만 될 수 있다. 모든 계정읜 통합 청구 - 단일 지불 방법 EC2, S3 할인 등 가격 책정 이점 API를 사용하여 AWS 계정 생성 자동화 ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:3:0","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"다중 계정 전략 부서별 비용 센터별, dev/test/prod 등 규제 제한 사항(SCP 이용) 또는 리소스 격라 수준에 따라 계정을 생성한다. 계정당 서비스 제한이 별도로 있고, 로깅을 위해 격리한다. ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:3:1","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Organizational Units (OU) ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:3:2","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Service Control Policies (SCP) IAM 역할에 Whitelist 또는 Blacklist OU 또는 Account 레벨에만 적용 가능 마스터 계정에는 적용되지 않음 SCP는 루트 사용자를 포함한 모든 계정의 사용자와 Role에 적용된다. SCP는 Service-linked 역할에 영향을 주지 않는다. Service-linked 역할은 다른 AWS 서비스를 AWS 조직과 통합할 수 있도록 SCP에 의해 제한될 수 없다. SCP에는 명시적으로 Allow (허용)이 있어야 한다. (기본적으로 아무것도 허용하지 않음) 사용 사례 특정 서비스에 대한 액세스 제한 서비스를 명시적으로 사용하지 않도록 설정하여 PCI 규정 준수 적용 SCP Hierarchy Blacklist \u0026 Whitelist 전략 특정 유형의 서비스를 블랙리스트로 등록 { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"AllowsAllActions\", \"Effect\": \"Allow\", \"Action\": \"*\", \"Resource\": \"*\" }, { \"Sid\": \"DenyDynamoDB\", \"Effect\": \"Deny\", \"Action\": \"dynamodb:*\", \"Resource\": \"*\" } ] } 특정 유형의 서비스만 화이트리스트에 추가 { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"ec2:*\", \"cloudwatch:*\", ], } ] } ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:3:3","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"조직 이동 계정 마이그레이션 이전 조직에서 구성원 계정 제거 새 조직에서 초대정 보내기 회원 계정에서 새 조직에 대한 초대 수락 마스터 계정의 마이그레이션 조직에서 구성원 계정 제거 이전 조직 삭제 위의 과정 반복 이전 마스터 계정을 새 조직으로 초대 ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:3:4","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Conditions aws:SourceIP: API 호출하는 곳으로부터 클라이언트 IP를 제한 아래 예시는 해당 아이피 범위가 아닌 곳에서는 요청을 허용하지 않음 (NotIpAddress) { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Deny\", \"Action\": \"*\", \"Resource\": \"*\", \"Condition\": { \"NotIpAddress\": { \"aws:SourceIp\" [ \"192.0.2.0/24\" \"203.0.113.0/24\" ] }, //... aws:RequestedRegion: API 호출이 이루어지는 리젼을 제한 요청리전이 eu-central-1, eu-west-1 다른 리전에서 온 것은 수락하지 않음. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"AllowOnlyInsideEU\", \"Effect\": \"Allow\", \"Action\": [ \"ec2:*\", \"rds:*\", \"dynamodb:*\", ], \"Resource\": \"*\", \"Condition\": { \"SingleEquals\": { \"aws:RequestedRegion\" [ \"eu-central-1\", \"eu-west-1\" ] }, //... Restrict based on tags 태그가 DataAnalytics이면서 부서가 Data일 때만 ec2의 해당 작업이 허용 { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"StartStopIfTags\", \"Effect\": \"Allow\", \"Action\": [ \"ec2:StartInstances\", \"ec2:StopInstances\", \"ec2:DescribeTags\" ], \"Resource\": \"arn:aws:ec2:regin:account-id:instance/*\", \"Condition\": { \"StringEquals\": { \"ec2:ResourceTag/Project\" : \"DataAnalytics\", \"aws:PrincipalTag/Department\": \"Data\" } } } ] } 다요소 인증 강제 { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"AllowAllActionsForEC2\", \"Effect\": \"Allow\", \"Action\": \"ec2:*\" \"Resource\": \"*\" } { \"Sid\": \"DenyStopAndTerminateWhenMFAIsNotPresent\", \"Effect\": \"Deny\", \"Action\": [ \"ec2:StopInstances\", \"ec2:TerminateInstances\" ], \"Resource\": \"*\", \"Condition\" : { \"BoolIfExists\" : { \"aws:MultiFactorAuthPresent\" : false } } } ] } ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:4:0","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM for S3 IAM for S3 ListBucket : Bucket 레벨의 permission \"arn:aws:s3:::test\" GetObject, PutObject, DeleteObject : Object 레벨의 permission arn:aws:s3:::test/* { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [\"s3:ListBucket\"], \"Resource\": [\"arn:aws:s3:::test\"], }, { \"Effect\": \"Allow\", \"Action\": [ \"s3:GetObject\", \"s3:PutObject\", \"s3:DeleteObject\" ], \"Resource\": [\"arn:aws:s3:::test/*\"], } ] } ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:5:0","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Role과 리소스 기반의 정책 계정 A에서 계정 B에 존재하는 S3 버킷을 프록시로 사용하여 연결하는 대신 리소스 기반 정책으로 연결했을 때 역할을 수임받을 때 계정 A의 원래 권한을 포기하고 Role에 할당된 권한을 갖게 된다. 리소스 기반 정책을 사용할 때 주체가 권한을 포기할 필요가 있다. example: 계정 A는 DynamoDB 테이블을 스캔하여 B계정의 S3 덤프 Supported by: Amazon S3 buckets, SNS topics, SQS queues, etc… ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:5:1","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Permission Boundaries IAM permission boundaries는 사용자와 역할에 대해 지원 (그룹은 지원하지 않음) 관리 정책을 사용하여 IAM 엔티티가 얻을 수 있는 최대 권한을 설정하는 고급 기능이다. https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/access_policies_boundaries.html Permission Boundaries 사용 사례 권한 범위 내에서 비관리자에게 책임 위임 개발자가 자신의 권한을 관리할 수 없도록 하고 자체 정책 및 사용 권한을 관리할 수 있도록 허용 조직 및 SCP를 사용하는 전체 계정 대신 특정 사용자 한명을 제한할 때 유용 IAM Policy Evaluation Logic https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:5:2","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Resource Access Manager (RAM) 소유한 AWS 리소스를 다른 AWS 계정과 공유 모든 계정 또는 조직 내에서 공유 리소스 중복 방지 VPC 서브넷 모든 리소스를 동일한 서브넷에서 시작할 수 있도록 허용 동일한 AWS 조직 사용자여야 한다. Security Group 및 기본 VPC 공유 할 수 없음 참가자는 자신의 리소스를 관리할 수 있음 참가자는 다른 참가자 또는 소유자의 리소스를 보거나 수정 및 삭제할 수 없음 AWS Transit Gateway Route53 Resolver Rules License Manager Configurations ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:6:0","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Resource Access Manager - VPC 예시 각각의 계정 자체 자원에 대한 책임이 존재 다른 계정의 리소스를 보거나 수정 또는 삭제 불가 네트워크는 공유된다. VPC에 구현된 모든 리소스는 VPC의 다른 리소스와 통신 가능 개인 IP를 사용하여 여러 계정에서 애플리케이션에 쉽게 액세스 최대 보안을 위해 다른 계정의 보안 그룹 참조 ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:6:1","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS Single Sign-On (SSO) Singe sign-on을 중앙에서 관리하여 여러 계정 및 3rd-party 비즈니스 애플리케이션에 액세스한다. AWS 조직과 통합 SAML 2.0 마크업 지원 on-premises로 통합된 Active Directory와 통합 중앙 집중식 관리 CloudTrail을 통한 중앙 집중식 감사 ","date":"2022-07-16","objectID":"/aws-26-iam-advanced/:7:0","tags":["AWS","AWS IAM"],"title":"26. AWS Identity and Access Management - Advanced","uri":"/aws-26-iam-advanced/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Private vs Public IP (IPv4) 네트워크는 IPv4, IPv6 두 가지로 분류 할 수 있다. IPv4 : 1.160.10.240 IPv6 : 3ffe:1900:4545:3:200:f8ff:fe21:67cf 대부분의 온라인에서는 IPv4를 범용적으로 사용 IPv6 사물인터넷(IoT) 문제를 해결하기 위해 새로 등장함 IPv4는 퍼블릭 영역에서 37억개의 서로 다른 주소를 허용 IPv4:[0-255].[0-255].[0-255].[0-255] ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:1:0","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Private vs Public IP 차이점 Public IP Public IP는 컴퓨터가 인터넷상(WWW)에서 식별될 수 있음을 의미 전체 웹에서 고유해야 한다. (두 개의 머신이 같은 public IP를 갖을 수 없다) 쉽게 지리적 위치를 찾을 수 있음 Private IP Private IP는 컴퓨터가 사설 네트워크망에서만 식별될 수 있음을 의미 IP는 사설 네트워크에서 고유해야 한다. 그러나 두 개의 다른 사설 네트워크망(두 개의 회사)에서는 같은 IP를 갖을 수 있음. 컴퓨터는 WWW를 연결하기 위해서 NAT + Internet gateway(a proxy)를 사용 Private IP를 사용할 수 있는 IP 범위가 정해져 있음 ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:1:1","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Elastic IP EC2 인스턴스는 재시작시 Public IP가 변경되는데 이것을 고정하고 싶으면 Elasitc IP를 사용하면 된다. Elastic IP는 IPv4이며 한번에 하나의 인스턴스에만 설정 가능 Elastic IP를 사용하면 사용자의 계정의 다른 인스턴스에 빠르게 매핑하여 인스턴스 또는 오류를 마스킹할 수 있음. 계정 당 5개까지 (증가 가능) 전반적으로는 Elastic IP를 사용하지 않는 것이 좋다. 종종 잘못된 아키텍처를 반영하는 경우가 발생 대신 임의의 public IP를 사용하고 DNS 이름을 등록 또는 로드밸런스를 사용하고 Elastic IP를 사용하지 않는다. ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:1:2","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Placement Groups - 배치 그룹 EC2 인스턴스가 AWS 인프라에 배치되는 방식을 배치 그룹(Placement Groups) 전략을 통해 제어할 수 있다. 배치 그룹 전략 전략 Cluster 단일 AZ에서 지연시간이 짧은 그룹으로 인스턴스를 클러스터링 Spread 기본 하드웨어 전체에 인스턴스 분산(AZ 그룹당 최대 7개 인스턴스) Partition AZ 내 여러 파티션(다양한 racks 세트 의존)에 인스턴스를 분산. 그룹당 100개의 EC2 인스턴스로 확장(Hadoop, Cassandera, Kafka) ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:2:0","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Cluster 배치 그룹 장점 : 뛰어난 네트워크(향상된 네트워크 활성화된 인스턴스간 10Gbps 대역폭 - 권장) 단점 : 랙이 실패하면 모든 인스턴스가 동시에 실패 사용사례 : 빠른 처리가 필요한 빅데이터 업무 매우 짧은 지연시간과 높은 네트워크 처리량이 필요한 애플리케이션 ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:2:1","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Spread 배치 그룹 장점 AZ 걸쳐 확장 가능 동시 장애로 인한 위험 감소 EC2 인스턴스가 다른 물리적 하드웨어있음 단점 : 배치 그룹 AZ 당 7개의 인스턴스 제한 사용사례: 고가용성을 극대화해야 하는 애플리케이션 각 인스턴스가 서로의 장애로부터 격리되어야 하는 중요 애플리케이션 ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:2:2","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Partition 배치 그룹 AZ 당 최대 7개의 파디션 같은 리젼에서 여러 AZ를 걸쳐 확장가능 최대 100개의 EC2 인스턴스 파티션 내 인스턴스는 다른 파디션 내 인스턴스와 랙을 공유하지 않는다. 파티션 오류는 많은 EC2에게 영향을 줄 수있으나 다른 파티션에는 영향을 미치지 않음 EC2 인스턴스는 파티션 정보에 메타데이터로 액세스 가능 사용사례 : HDFS, HBase, Cassandra, Kafka ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:2:3","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Elastic Network Interfaces (ENI) 가상 네트워크 카드(virtual network card) 를 나타내는 VPC의 논리적 구성요소 ENI를 독립적으로 생성하고 장애조치를 위해 EC2 인스턴스에서 즉이 연결(이동) 가능 특정 AZ에 바인딩 ENI 구성요소 기본 private IPv4, 하나 이상의 secondary IPv4 private IPv4 당 하나의 Elastic IP(IPv4) 하나의 Public IPv4 하나 이상의 보안 그룹 MAC Address ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:3:0","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 Hibernate 인스턴스 중지 및 종료 Stop(중지) : 데이터 디스크(EBS)는 다음 인스턴스 재시작까지 유지 Terminate(종료) : EBS 볼륨(루트)이 삭제되게 설정했다면 삭제 인스턴스 시작시 다음과 같은 일이 발생한다. First start : OS boots \u0026 EC2 인스턴스 Data script 실행 Following starts : OS boots up 애플리케이션 시작 및 캐시 준비 ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:4:0","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 Hibernate 소개 in-memory(RAM) 상태가 유지된다. 인스턴스 부팅이 더 빠르다. (OS가 중지/재시작 되지 않음) Under the hood: RAM 상태가 루트 EBS 볼륨 파일에 기록된다. 루트 EBS 볼륨을 암호화 해야 한다. EC2 Hibernate Use cases 오래 실행되는 프로세스 RAM의 상태를 저장하고 싶을 때 서비스 초기화 시간에 이용 주요 사항 지원 되는 인스턴스 제품군 : C3, C4, C5, I3, M3, M4, R3, R4,T2,T3, … 인스턴스 RAM Size : 반드시 150 GB 미만 인스턴스 Size : bare metal 인스턴스에는 적용 불가 AMI : Amazon Linux 2, Linux AMI, Ubuntu, RHEL, CentOS \u0026 Windows… Root Volume : EBS만 가능. 암호화가 필요. 충분한 용량이어야 하며 instance store 사용할 수 없음. On-Demand, Reserved, Spot 인스턴스 가능 인스턴스는 60일 이상 최대 절전모드로 전환 불가 ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:4:1","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 Nitro 차세대 EC2 인스턴스를 위한 기본 플랫폼 새로운 가상화 기술 성능 향상 향상된 네트워킹 옵션(향상된 네트워킹, HPC, IPv6) 고속 EBS(Nitro는 64,000 EBS IOPS 필요 - Nitro가 아닌 경우 최대 32,000) 기본 보안 향상 인스턴스 유형 Virtualized : A1,C5,C5a,C5ad,C5d,C5n,C6g,C6gd,C6gn,D3,D3en,G4,I3en,Inf1,M5, M5a, M5ad, M5d, M5dn, M5n, …. Bare metal : a1.metal, c5.metal, c5d.metal, c5n.metal, c6g.metal, c6gd.metal… ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:5:0","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"vCPU 이해하기 다중 스레드를 CPU에서 실행할 수 있다. multithreading 각 스레드는 가상 CPU(vCPU)로 표시 m5.2xlarge : 4 CPU, 2 Thread per CPU =\u003e 8 vCPU in total EC2 Optimizing CPU 옵션 EC2 인스턴스는 RAM과 vCPU의 조합으로 함께 제공 경우에 따라 사용자가 원하는대로 vCPU 옵션을 변경 할 수 있다. options of CPU cores · 높은 RAM과 적은 수의 CPU가 필요한 경우 유용· 라이센스 비용 절감 of threads per core · CPU 당 스레드 수가 1 개인 멀티스레딩 비활성화 - HPC 워크로드에 유용 인스턴스 실행 중에만 지정 ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:5:1","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 Capacity Reservations 용량 예약을 통해 필요할 때 EC2 용량 확보 수동 또는 종료 일자를 지정할 수 있다. 1년 또는 3년 약정 불필요 Capacity 액세스는 즉시 이루어지며 시작하자마자 청구 예약된 인스턴스 및 절감 계획과 결합하여 비용 절감 지정 사항 용량을 예약할 AZ(한개만) 용량을 예약할 인스턴스 수 인스턴스 유형, tenancy 및 플랫폼/OS를 포함한 인스턴스의 특성 ","date":"2022-07-14","objectID":"/aws-06-ec2-associate/:5:2","tags":["AWS","Amazone EC2","Amazone Elastic Network Interfaces(ENI)"],"title":"6. AWS Elastic Compute Cloud (EC2) - Associate","uri":"/aws-06-ec2-associate/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Amazon EC2 EC2는 AWS의 가장 인기있는 서비스이다. Elastic Compute Cloud = Infrastructure as a service 클라우드의 작동 방식을 이해하기 위해서는 EC2를 이해하는 것이 중요하다. 구성할 수 있는 기능 가상 머신 임대 (EC2) 가상 드라이브에 데이터를 저장 (EBS) 시스템 간 부하 분산 (ELB) auto-scaling group(ASG)를 사용하여 서비스 확장 ","date":"2022-07-13","objectID":"/aws-05-ec2/:1:0","tags":["AWS","Amazone EC2"],"title":"5. AWS EC2 Basics","uri":"/aws-05-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 sizing \u0026 configuration options Operating System(OS) : Linux, Windows or Mac OS 컴퓨터 성능과 코어양 선택 가능 (CPU) random-access memory (RAM) 스토리지 용량 Network-attached (EBS \u0026 EFS) hardware (EC2 Instance Store) Network card: 네트워크 카드 속도, 공용 IP 주소 방화벽 규칙 : security group Bootstrap script (configure at first launch): EC2 User Data EC2 User Data EC2 사용자 데이터 스크립트를 사용하여 인스턴스를 부트스트랩 할 수 있다. 부트스트래핑은 기계가 시작될 때 명령을 시작하는 것을 의미한다. 스크립트는 처음 시작 할 때 한번만 실행된다. EC2 User Data Script는 루트 계정으로 실행 EC2 사용자 데이터는 다음과 같은 부팅 작업을 자동화 할 수 있다. 소프트웨어 및 업데이트 설치 인터넷으로 부터 공용파일 다운로드 등 ","date":"2022-07-13","objectID":"/aws-05-ec2/:1:1","tags":["AWS","Amazone EC2"],"title":"5. AWS EC2 Basics","uri":"/aws-05-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 인스턴스 종류 Amazon EC2 인스턴스 유형 AWS는 다음과 같은 네이밍 규칙을 따른다. AWS 네이밍 규칙 m5.2xlarge m : 인스턴스 class 5 : 세대generation (AWS는 시간이 지남에 따라 개선 ) 2xlarge : 인스턴스 클래스 사이즈 인스턴스 종류 Instance Type General Purpose · 웹 서버 또는 코드 저장소와같은 다양한 워크로드에 적합 · Compute, Memory, Networking 사이 밸런싱 Compute Optimized · 높은 성능을 요구하는 계산집약적인 업무에 적합· 배치 프로세스 워크로드· Media transcoding· 높은 성능의 웹서버· High performance computing(HPC)· scientific model \u0026 machine learning· 게임 전용 서버 Memory Optimized · 메모리안에서 큰 데이터셋을 빠르게 처리하는 워크로드에 적합· 높은 성능을 요구하는 relation/non-relational databases· Distributed web scale cahce stores· BI(business intelligence)에 최적화된 in-memory databases· 크기가 큰 비정형화 데이터를 실시간으로 처리하는 애플리케이션 성능 Storage Optimized · 로컬 스토리지의 큰 데이터의 읽고, 쓰기 접근이 요구되는 스토리지 집약 업무에 적합· Online transaction processing(OLTP) 시스템의 잦은 접근· 관계형 \u0026 NoSQL 데이터베이스· in-memory 데이터 캐시 (Redis)· Data warehousing applications· 분산 파일 시스템 ","date":"2022-07-13","objectID":"/aws-05-ec2/:1:2","tags":["AWS","Amazone EC2"],"title":"5. AWS EC2 Basics","uri":"/aws-05-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Security Groups 보안그룹(Security Groups)은 AWS의 네트워크 보안의 기본이다. EC2 인스턴스의 in/out 트래픽을 허용 제어하는 것 보안그룹은 오직 allow 규칙만 포함한다. 보안그룹의 규칙은 IP 또는 보안그룹을 참조할 수 있음 They regulate: Access to Ports 허가된 IP 범위 - IPv4 and IPv6 인바운드 네트워크 제어 (다른 인스턴스로부터) 아웃바운드 네트워크 제어 (다른 인스턴스로부터) ","date":"2022-07-13","objectID":"/aws-05-ec2/:2:0","tags":["AWS","Amazone EC2"],"title":"5. AWS EC2 Basics","uri":"/aws-05-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"보안그룹에서 알아야 할 사항 보안그룹은 EC2 인스턴스에서 firewall 역할을 하고 있다. 규제 사항 포트 접근 제어 허가된 IP 범위 (IPv4, IPv6) 인바운드 네트워크 제어 (다른 네트워크에서 인스턴스로) 아웃바운드 네트워크 제어 (인스턴스에서 다른 네트워크로) 여러 인스턴스에 연결할 수 있다. 리젼/VPC 결합으로 통제 할 수 있다. EC2 외부에 있는 경우 트래픽이 차단되면 EC2 인스턴스는 해당 트래픽을 인식하지 못한다. SSH 접근을 위해 별도의 보안 그룹을 유지하는 것이 좋다 응용 프로그램이 액세스할 수 없는경우time out는 보안 그룹의 문제이다. 응용 프로르램에서 connection refused 오류가 표시되면 프로그램 오류이거나 실행되지 않은 것이다. 기본적으로 모든 인바운드 트래픽은 차단된다. (blocked) 기본적으로 모든 아웃바운드의 트래픽은 승인된다. 알아야 할 클래식 포트 22 = SSH (Secure Shell) - 리눅스 인스턴스 로그인 21 = FTP (File Transfer Protocol) - 파일 공유를 위한 파일 업로드 22 = SFTP (Secure File Transfer Protocol) - SSH를 사용한 파일 업로드 80 = HTTP - 보안되지 않은 웹사이트 접근 443 = HTTPS - 보안 웹사이트 접근 3389 = RDP(Remote Desktop Protocol) - 윈도우 인스턴스 로그인 ","date":"2022-07-13","objectID":"/aws-05-ec2/:2:1","tags":["AWS","Amazone EC2"],"title":"5. AWS EC2 Basics","uri":"/aws-05-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 인스턴스 구매 옵션 options 설명 On-Demand Instances · 애플리케이션 동작을 예측할 수 없는 단기적이고 중단 없는 워크로드 적합 · 사용한 만큼만 지불 · Linux or Windows : 초당 과금, 최초 1분 · 다른 OS: 시간당 지불 · 비용은 가장 높지만 선급금 및 계약기간 없음 Reserved Instances(예약 인스턴스) · On-demand에 대비 72% 할인 · 특정 인스턴스 속성을 예약가능(인스턴스 타입, 지역, Tenancy, OS) · 예약 기간 1년 또는 3년 · 지불 옵션 : No Upfront, Partial Upfront, All Upfront · 예약인스턴스 범위 : Regional or Zonal (reserve capacity in an AZ) · 정상 상태 사용 애플리케이션에 권장 · 예약된 인스턴스 마켓플레이스에서 구매 및 판매 Convertible Reserved Instances · 사용량에 대한 지불, 긴 워크로드 · 유연한 인스턴스를 통한 긴 워크로드(인스턴스 유형, 제품군, OS, 범위 및 tenancy 변경 가능) · 최대 66% 할인 Savings Plans · 장기 사용량에 따른 할인(최대 72%) · 1년 또는 3년 동안 시간당 $10 · Saving plan을 초과하는 경우 on-demand 가격으로 청구 · 특정 인스턴스 제품 군 및 AWS 영역에서는 사용불가 · Flexible across: · 인스턴스 크기(예: m5.xlarge, m5.2xlarge) · OS (e.g., Linux, Windows) · Tenancy (Host, Dedicated, Default) Spot Instance · 짧은 워크로드, 저렴한 비용으로 인스턴스 손실 가능 (신뢰성 저하) · on-demand 대비 최대 90% 할인 · 최대 가격이 현재 가격보다 작을 경우 언제든지 잃어버릴 수 있는 인스턴스 · AWS에서 가장 비용 효율적인 인스턴스 · 장애에 대한 유연한 워크로드에 유용: · Batch jobs · Data analysis · Image processing · 분산 워크로드 · 시작 및 종료 시간이 유연한 워크로드 · 중요한 작업 또는 데이터베이스에는 적합하지 않음 Dedicated Host · 사용자 전용 물리 서버, 인스턴스 배치 제어 · 준수 요구사항 해결 및 기존 서버 라이센스(per-socket, per-core, per-VM software licenses) · 구매옵션 · On-demand : 활성화 된 Dedicated host 초당 지불 · Reserved : 1 또는 3년(No Upfront,Partial Upfront,All Upfront) · 복잡한 라이선스 모델(BYOL - Bring Your Own License)을 사용하는 소프트웨어 유용 · 강력한 규제 또는 규정 준수 요구사항이 있는 기업 Dedicated Instances · 다른 고객과 하드웨어를 공유하지 않음 · 동일한 계정의 다른 인스턴스와 하드웨어를 공유할 수 있음 · 인스턴스 배치를 제어할 수 없음(Start/Stop 후 이동 가능) Capacity Reservations · 특정 AZ에서 모든 기간 동안 용량 예약 · 필요할 때 언제든지 EC2 용량 액세스 · No time commitment(언제든지 생성/취소), no billing discounts · Regional Reserved Instances 와 Savings plans를 결합하여 청구 할인 혜택을 얻을 수 있음 · 인스턴스 실행 여부에 관계없이 on-demand로 청구 · 특정 AZ에 있어야 하는 중단 없는 워크로드에 적합 ","date":"2022-07-13","objectID":"/aws-05-ec2/:3:0","tags":["AWS","Amazone EC2"],"title":"5. AWS EC2 Basics","uri":"/aws-05-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"EC2 Spot Instance Requests on-demand 대비 90% 할인 가능 max spot price를 지정하고 current spot price \u003c max 동안 사용 시간당 스팟 가격은 제품 및 용량에 따라 다름 현재 스팟 가격이 최대 가격보다 높을 경우 2분 유예 기간 동안 인스턴스를 중지 혹은 종료 가능 장애에 대한 탄력적인 배치작업, 데이터 분석 등의 워크로드에 사용 중요한 작업 또는 데이터베이스에 적합 하지 않음 다른 전략 - Spot Block block 스팟 인스턴스는 지정된 시간 범위 (1~6시간)동안 중단 없이 사용 가능 드문 경우이나 인스턴스 회수 가능 How to terminate Spot Instances? open, active 또는 disabled 상태의 인스턴스만 요청 취소 할 수 있다. 스팟 요청을 취소해도 인스턴스는 종료되지 않는다. 스팟 요청을 취소한 다음 관련 스팟 인스턴스를 종료해야 한다. one-time : Spot Request가 이행되는 즉시 인스턴스가 시작 persistent : Spot Request Valid from ~ Valid until 까지 유효기간 동안 요청한 개수의 인스턴스가 계속 유효. 스팟 인스턴스가 중단되어도 요청이 활성화 되어있으면 자동적으로 인스턴스를 재시작 ","date":"2022-07-13","objectID":"/aws-05-ec2/:3:1","tags":["AWS","Amazone EC2"],"title":"5. AWS EC2 Basics","uri":"/aws-05-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Spot Fleets Spot Fleets = set of Spot Instances + (optional) On-Demand Instances Spot Fleet은 가격 제약으로 목표 용량을 충족 가능한 실행 풀 정의 : 인스턴스 유형(m5.large), OS, 가용성 영역 fleet을 선택할 수 있도록 여러개의 실행 풀을 가질 수 있다. 용량 또는 최대 비용에 도달하면 Spot Fleets 인스턴스가 종료 Spot Fleets를 사용하면 최저가격으로 Spot Instance를 자동으로 요청할 수 있다. Spot Instances 할당 전략 lowestPrice(최저가격) : 최저 가격을 가진 pool로부터 (비용 최적화, 짧은 워크로드) diversified(다양화) : 모든 pool 분산(가용성과 긴 워크로드 적합) capacityOptimized(용량 최적화) : 인스턴스 수에 맞는 최적의 용량을 가진 풀 ","date":"2022-07-13","objectID":"/aws-05-ec2/:3:2","tags":["AWS","Amazone EC2"],"title":"5. AWS EC2 Basics","uri":"/aws-05-ec2/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Users \u0026 Groups IAM = Identity and Access Management → Global 서비스 Root 계정은 기본으로 생성되며 사용하거나 공유해서는 안된다. Users 는 조직의 사용자이며 그룹으로 묶을 수 있다. Groups는 user를 포함할 수 있고 다른 그룹은 포함할 수 없다. 사용자는 그룹에 속할 필요는 없고 user는 여러 그룹에 속할 수 있다. ","date":"2022-07-12","objectID":"/aws-01-iam/:1:0","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Permissions 사용자나 그룹은 정책은 JSON 문서를 통해 할당할 수 있다. 정책(polices)은 사용자의 권한(permissions)을 정의한다. AWS에서는 최소 권한 원칙을 적용한다 → 사용자가 필요로 하는 것보다 더 많은 권한을 부여하지 않는다. ","date":"2022-07-12","objectID":"/aws-01-iam/:2:0","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Policies inheritance 인라인 정책 : 그룹에 속해있지 않아도 정책을 바로 사용자에게 연결 가능 ","date":"2022-07-12","objectID":"/aws-01-iam/:3:0","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Policies Structure { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"ec2:Describe*\", \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": \"elasticloadbalancing:Describe*\", \"Resource\": \"* }, { \"Effect\": \"Allow\", \"Action\": [ \"cloudwatch:ListMetrics\", \"cloudwatch:GetMetricStatistics\", \"cloudwatch:Describe*\" ], \"Resource\": \"*\" } ] } ","date":"2022-07-12","objectID":"/aws-01-iam/:4:0","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"요소 Version : 정책 버전 Id : 정책을 식별할 수 있는 식별자 (옵션) Statement : 하나 혹은 여러개 (필수사항) ","date":"2022-07-12","objectID":"/aws-01-iam/:4:1","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Statements 요소 Sid : statement 의 식별자 (옵션) Effect : 특정 statement에 접근은 허용 여부 (Allow 또는 Deny)를 나타냄 Principal : 정책이 적용 될 대상 (계정, 사용자, 역할) Action : 정책의 허용 또는 거부되는 호출 리스트 목록 Resource : 정책이 적용될 리소스 목록 Condition : statement가 언제적용될지 결정 (옵션) ","date":"2022-07-12","objectID":"/aws-01-iam/:4:2","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Password Policy 강력한 비밀번호 → 계정에 대한 높은 보안 AWS에서 설정가능한 패스워드 정책 패스워드 최소 길이 특수문자 포함 필수 입력 : 대소문자, 숫자, 특수문자 IAM 계정 사용자들의 패스워드 변경 허용 또는 금지 패스워드 만료 지정 패스워드 재사용 금지 ","date":"2022-07-12","objectID":"/aws-01-iam/:5:0","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"MFA - Multi Factor Authentication 사용자는 계정에 액세스 할 수 있으며 구성을 변경하거나 AWS 계정의 리소스를 삭제할 수 있다. MFA는 루트 계정 및 IAM 사용자를 보호하려는 경우 사용할 수 있다. 비밀번호가 도난당하거나 해킹당해도 계정에 손상을 입지 않는다. MFA = 패스워드(사용자만 알고있는) + 보안 장비(사용자가 소유하고 있는) ","date":"2022-07-12","objectID":"/aws-01-iam/:6:0","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"MFA devices options in AWS MFA devices Virtual MFA device - 하나의 디바이스에 멀티 토큰을 지원 - Google Authenticator(phone only)- Authy(multi-device) Universal 2nd Factor (U2F) Security Key - 단일 보안 키를 사용하여 여러 루트 및 IAM 사용자 지원- YubiKey by Yubico (3rd party) Hardware Key Fob MFA Device - Provided by Gemalto (3rd party) Hardware Key Fob MFA Device for AWS GovCloud (US) - Provided by SurePassID (3rd party) ","date":"2022-07-12","objectID":"/aws-01-iam/:6:1","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS에 액세스 하는 방법 AWS 액세스하기 위한 세 가지 방법 AWS Management Console : 비밀번호 + MFA로 보호 AWS Command Line Interface (CLI) : access key로 보호 AWS Software Developer Kit (SDK) : 코드의 경우 access key로 보호 액세스키는 AWS 콘솔을 통해 생성할 수 있다. 사용자가 자신의 액세스키를 관리한다. 액세스 키는 패스워드와 마찬가지로 기밀이므로 공유하지 않는다. Access Key ID ~= username Secret Access Key ~= password ","date":"2022-07-12","objectID":"/aws-01-iam/:7:0","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS CLI 커맨드라인 쉘에서 명령어를 사용하여 AWS 서비스와 상호작용 할 수 있도록 해주는 도구 CLI를 사용하면 AWS의 공용 API로 직접 액세스 가능 리소소를 자동화하여 관리할 수 있다. 오픈소스이다. https://github.com/aws/aws-cli AWS 관리 콘솔 대신 사용 가능 ","date":"2022-07-12","objectID":"/aws-01-iam/:7:1","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"AWS SDK(AWS Software Development Kit) 특정 언어로 된 라이브러리 집합 프로그래밍으로 AWS에 액세스를 액세스하고 관리 응용 프로그램에 포함 Supports SDKs (Javascript, Python, PHP, .NET, Ruby, Java, Go, Node.js, C++) Mobile SDKs (Android, iOS…) IoT Device SDKs (Embedded C, Arduino…) ","date":"2022-07-12","objectID":"/aws-01-iam/:7:2","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Roles for Service 일부 AWS 서비스는 사용자를 대신하여 작업을 수행 IAM 역할을 사용하여 AWS 서비스에 사용 권한을 할당 공통 역할 EC2 인스턴스 Roles Lambda Function Roles Roles for CloudFormation ","date":"2022-07-12","objectID":"/aws-01-iam/:8:0","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM Security Tools IAM Security Tools 설명 IAM Credentials Report (account-level) 계정의 모든 사용자와 해당 사용자의 다양한 자격 증명 상태를 나열하는 보고서 IAM Access Advisor (user-level) - 사용자에게 부여된 서비스 권한과 해당 서비스에 마지막으로 액세스한 시간을 표시- 이 정보를 사용하여 정책을 수정 ","date":"2022-07-12","objectID":"/aws-01-iam/:8:1","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"IAM 가이드라인 \u0026 모범 사례 루트 계정은 AWS 계정을 설정할 때를 제외하고 사용하지 않는다. 실제 유저 한명 = 하나의 AWS 유저 사용자를 그룹에 할당하고 그룹에 권한을 할당 강력한 패스워드 정책 사용 MFA(Multi Factor Authentication) 인증 사용 및 적용 AWS 서비스에 대한 사용 권한을 부여하는 역할 Roles 을 생성 및 사용 프로그래밍 방식의 액세스 키 사용 (CLI / SDK) IAM 자격증명 보고서를 사용한 계정 감사 IAM 유저와 액세스키 공유는 절대 하지 않는다 ","date":"2022-07-12","objectID":"/aws-01-iam/:8:2","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["AWS Certified SAA-C02 시험준비"],"content":"Summary 설명 Users AWS 콘솔에 대한 비밀번호를 갖는 실제사용자와 매핑 Groups 오직 사용자만 그룹에 포함할 수 있다.다른 그룹은 포함할 수 없다. Policies 사용자나 그룹이 할 수 있는 권한을 알려주는 문서이다.JSON 형태로 되어있다. Roles EC2와 같은 AWS 서비스에서 무언가를 할 수 있게 하는 권한을 주려고 할때 IAM Role을 만들어야 한다. Security MFA + Password Access Keys AWS의 CLI, SDK 접근하기 위해 사용하는 자격증명 값이다. Audit(회계 감사) IAM Credential Reports(IAM 자격증명 보고서) : 사용자 자격증명 내역 확인IAM Access Advisor(IAM 액세스 관리자) : 최근 권한 사용내역 확인 ","date":"2022-07-12","objectID":"/aws-01-iam/:9:0","tags":["AWS","Amazone EC2"],"title":"1. AWS Identity and Access Management","uri":"/aws-01-iam/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:0:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"인그레스 Ingress 클러스터 내의 서비스에 대한 외부 요청을 어떻게 처리할 것인지 네트워크 7계층 레벨에서 정의하는 쿠버네티스 오브젝트이다. 인그레스 오브젝트의 기본 기능은 다음과 같다. 외부 요청의 라우팅 : 특정 경로로 들어온 요청을 어떤 서비스로 전달할지 정의하는 라우터 규칙 설정 가상 호스트 기반의 요청 처리 : 같은 IP에 대해 다른 도메인 이름으로 요청했을 때 어떻게 처리할 것인지 정의 SSL/TLS 보안 연결 처리 : 요청을 라우팅 할 때, 보안 연결을 위한 인증서 적용 ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:1:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"인그레스를 사용하는 이유 쿠버네티스 서비스 타입 중 NodePort 혹은 LoadBalancer 타입의 서비스를 사용해도 외부로 노출할 수 있지만, 인그레스 없이 서비스를 사용할 경우 SSL/TLS 보안 연결 등의 상세 옵션을 각각의 서비스와 디플로이먼트에 대해 일일이 설정을 해야 한다. ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:1:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"인그레스 컨트롤러 인그레스는 요청을 처리하는 규칙을 정의하는 선언적 오브젝트이며 이런 인그레스 컨트롤러(Ingress Controller) 라는 서버에 적용해야만 그 규칙을 사용할 수 있다. 따라서 쿠버네티스의 인그레스는 반드시 인그레스 컨트롤러와 함께 사용해야 한다. kube-controller-manager의 일부로 실행되는 다른 컨트롤러와 달리 인그레스 컨트롤러는 클러스터와 함께 생성되지 않으므로, 직접 구현해야 한다. [출처] https://kubernetes.io/ko/docs/concepts/services-networking/ingress/ ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:2:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Load Balancer 컨트롤러 만들기 쿠버네티스 프로젝트에서는 AWS Load Balancer, GCE, Nginx Ingress 등의 인그레스 컨트롤러 프로젝트를 지원하고 있다. 워크샵 실습에는 AWS Load Balancer로 인그레스 컨트롤러를 생성했다. 사실 머선말인지는 잘 모르겠다… 조금 더 공부를 해야겠다능 🫠🫠🫠 AWS Load Balancer 컨트롤러는 쿠버네티스 ingress를 생성할 때 ALB(Application Load Balancer)와 NLB(Network Load Balancer)를 생성하고 관리한다. 쿠버네티스 Ingress를 생성할 때 Application Load Balancer으로 프로비저닝된다. 쿠버네티스 로드 밸런스 타입의 Service를 생성할 때, Network Load Balancer으로 프로비저닝된다. [출처] https://aws.amazon.com/blogs/opensource/kubernetes-ingress-aws-alb-ingress-controller/ Ingress 리소스가 kubernetes API에서 생성될 때 alb-ingress-controller는 변경 사항을 관찰한다. alb-ingress-controller는 ingress 리소스에 추가된 어노테이션을 기반으로 AWS ALB를 생성한다. 대상 그룹은 ingress 리소스에 지정된 각 back-end에 대해 생성된다. ALB URL은 경로 또는 쿼리 매개변수를 사용하여 액세스한다. Ingress 리소스에 구성된 규칙에 따라 요청은 특정 대상 그룹으로 리다이렉션되고 ClustIP 또는 NodePort를 사용하여 Pod 서비스에 도달한다. ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:3:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"ALB(Application Load Balancer) OSI 모델 Layer7에서 부하분산을 지원한다. HTTP, HTTPS 트래픽을 로드밸런싱해서 내부 인스턴스에 전달한다. IP주소 + 포트번호 + 패킷내용을 보고 로드밸런서 스위칭이 일어난다. 여러 도메인, 호스트, 경로 기반의 라우팅이 가능하다. ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:3:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"NLB(Network Load Balancer) OSI 모델 Layer4에서 부하분산을 지원한다. TCP/UDP 트래픽을 로드밸런싱해서 내부 인스턴스에 전달한다. 내부로 들어온 트래픽을 처리하고, 내부의 인스턴스로 트래픽을 전송한다. IP주소 + 포트번호로 로드밸런서 스위칭이 일어난다. ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:3:2","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"IAM OIDC(OpenID Connect) Identity Provider 생성 OpenID Connect Tokens 나중에 알아보자… AWS Load Balancer 컨트롤러가 워커 노드 위에서 동작하기 때문에 IAM permission을 통해 AWS ALB/NLB 리소스에 접근 가능한 OIDC를 먼저 생성해야 한다. ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:4:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"1. IAM OIDC(OpenID Connect) Identity Provider 생성 eksctl utils associate-iam-oidc-provider --region ap-northeast-2 \\ --cluster eks-demo \\ --approve 2022-05-08 22:46:25 [ℹ] eksctl version 0.95.0 2022-05-08 22:46:25 [ℹ] using region ap-northeast-2 2022-05-08 22:46:26 [ℹ] will create IAM Open ID Connect provider for cluster \"eks-demo\" in \"ap-northeast-2\" 2022-05-08 22:46:27 [✔] created IAM Open ID Connect provider for cluster \"eks-demo\" in \"ap-northeast-2\" ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:4:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"생성한 IAM OIDC Identity Provider 확인하기 (IAM 콘솔) IAM 자격 증명 공급자 콘솔(Identity Providers in IAM Console) 에서 클러스터에 대한 OIDC 자격증명 공급자를 확인할 수 있다. ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:4:2","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"2. AWS Load Balancer Controller에 부여할 IAM Policy 생성 IAM 정책은 AWS Load Balancer Controller가 사용자를 대신하여 AWS API를 호출하도록 허용한다. AWS 로드밸런서 컨트롤러의 IAM 정책 다운로드 curl -o /Users/riley/environment/manifests/alb-ingress-controller/iam_policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/main/docs/install/iam_policy.json AWSLoadBalancerControllerIAMPolicy라는 IAM Policy 생성 aws iam create-policy \\ --policy-name AWSLoadBalancerControllerIAMPolicy \\ --policy-document file:///Users/riley/environment/manifests/alb-ingress-controller/iam_policy.json ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:4:3","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"3. AWS Load Balancer Controller를 위한 Service Account 생성 AWS Load Balancer Controller에 쿠버네티스 서비스 계정에 대한 IAM 역할을 연결한다. - --attach-policy-arn=arn:aws:iam::$ACCOUNT_ID:role/$IAM_ROLE_NAME 자세한 내용은 문서를 참고 : IAM 역할을 서비스 계정에 연결 eksctl create iamserviceaccount \\ --cluster eks-demo \\ --namespace kube-system \\ --name aws-load-balancer-controller \\ --attach-policy-arn arn:aws:iam::$ACCOUNT_ID:policy/AWSLoadBalancerControllerIAMPolicy \\ --override-existing-serviceaccounts \\ --approve AWSLoadBalancerControllerIAMPolicy의 IAM Role을 갖는 EKS ServiceAccount 생성하고 Ingress와 Service에 ALB와 NLB를 각각 생성하고 관리할 수 있게 되었다. ","date":"2022-05-08","objectID":"/aws-5-ingress-controller/:4:4","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 5. 인그레스 컨트롤러 만들기","uri":"/aws-5-ingress-controller/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. ","date":"2022-05-07","objectID":"/aws-4-ecr/:0:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/aws-4-ecr/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"Amazon ECR 리포지토리 생성 및 이미지 올리기 Amazon ECR(Elastic Container Registry) 은 도커 컨테이너의 이미지를 저장하는 Repository 서비스이다. Docker hub의 기능과 동일하다. ","date":"2022-05-07","objectID":"/aws-4-ecr/:1:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/aws-4-ecr/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS CLI로 이미지 리포지토리 생성 aws ecr create-repository \\ --repository-name demo-flask-backend \\ --image-scanning-configuration scanOnPush=true \\ --region ap-northeast-2 명령어가 수행되면 리포지토리에 대한 정보가 출력되며 Amazon ECR 콘솔창에서도 생성된 리포지토리를 확인할 수 있다. ","date":"2022-05-07","objectID":"/aws-4-ecr/:1:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/aws-4-ecr/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"이미지를 리포지토리로 푸시 이미지를 푸시하려는 리포지토리 선택 후 오른쪽 상단에 푸시 명령 보기(View push commands) 버튼을 클릭하면 푸시 명령어를 확인 할 수 있다. AWS 인증정보를 검색하여 도커 클라이언트를 인증한다. 아래 파라미터는 환경 변수로 지정하거나 직접 입력한다. ${AWS_REGION} : 사용 리전 $ACCOUNT_ID : IAM 계정 ID(숫자 12자리) aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com 도커 이미지 빌드 (AWS 워크샵 샘플 이미지 이용) cd ~/environment/amazon-eks-flask docker build -t demo-flask-backend . 이미지 빌드 완료 후 docker tag 태그 지정 docker tag demo-flask-backend:latest $ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/demo-flask-backend:latest 이미지를 리포지토리에 푸시 docker push $ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/demo-flask-backend:latest ","date":"2022-05-07","objectID":"/aws-4-ecr/:1:2","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/aws-4-ecr/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"푸시 된 리포지토리 확인 Amazon ECR \u003e 해당 리포지토리 클릭 하면 빌드된 이미지를 확인 할 수 있다. ","date":"2022-05-07","objectID":"/aws-4-ecr/:1:3","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 4. Amazon ECR 에 이미지 올리기","uri":"/aws-4-ecr/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. Amazon EKS 클러스터는 다양한 방식으로 배포할 수 있다. AWS 콘솔 창으로 배포 AWS CloudFormation 혹은 AWS CDK 와 같은 IaC(Infrastructure as Code) 도구를 사용해 배포 EKS의 공식 CLI인 eksctl 로 배포 Terraform, Pulumi, Rancher 등으로 배포 ","date":"2022-05-06","objectID":"/aws-3-eks-cluster/:0:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"eksctl로 Cluster 생성하기 아무 옵션없이 eksctl create cluster 실행하면 default parameter로 클러스터가 배포된다. 그러나 yaml 파일로 작성한 구성 파일을 작성하여 배포하면 구성파일에 명시한 오브젝트들의 바라는 상태(desired state)를 쉽게 파악하고 관리할 수 있는 이점이 있다. ","date":"2022-05-06","objectID":"/aws-3-eks-cluster/:1:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"1. Cluster 구성파일 작성 ~/environment/eks-demo-cluster.yaml apiVersion: eksctl.io/v1alpha5 kind: ClusterConfig metadata: name: eks-demo # 생성할 EKS 클러스터명 region: ap-northeast-2 # 클러스터를 생성할 리전 version: \"1.21\" vpc: cidr: \"192.168.0.0/16\" # 클러스터에서 사용할 VPC의 CIDR managedNodeGroups: - name: node-group # 클러스터의 노드 그룹명 instanceType: m5.large # 클러스터 워커 노드의 인스턴스 타입 desiredCapacity: 3 # 클러스터 워커 노드의 갯수 volumeSize: 10 # 클러스터 워커 노드의 EBS 용량 (단위: GiB) iam: withAddonPolicies: imageBuilder: true # Amazon ECR에 대한 권한 추가 # albIngress: true # albIngress에 대한 권한 추가 cloudWatch: true # cloudWatch에 대한 권한 추가 autoScaler: true # auto scaling에 대한 권한 추가 cloudWatch: clusterLogging: enableTypes: [\"*\"] ","date":"2022-05-06","objectID":"/aws-3-eks-cluster/:1:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"2. 명령어를 통해 클러스터를 배포한다. eksctl 클러스터 생성 관리 설정 참고 eksctl create cluster -f eks-demo-cluster.yaml 클러스터가 완전히 배포되는데까지는 약 15~20분이 소요된다. AWS CloudFormation 콘솔창에서도 진행사항을 파악할 수 있다. 생성한 클러스터 정보 확인 $ AWS_PROFILE=riley-admin eksctl get clusters 2022-05-07 22:52:40 [ℹ] eksctl version 0.95.0 2022-05-07 22:52:40 [ℹ] using region ap-northeast-2 NAME REGION EKSCTL CREATED eks-demo ap-northeast-2 True ","date":"2022-05-06","objectID":"/aws-3-eks-cluster/:1:2","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"3. kubectl 인증 정보 설정 컨텍스트 리스트 출력하기 $ kubectl config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE * eks-demo-cluster eks-demo.ap-northeast-2.eksctl.io Administrator@eks-demo.ap-northeast-2.eksctl.io kubectl 인증정보 alias 지정 $ kubectx eks-demo-cluster=Administrator@eks-demo.ap-northeast-2.eksctl.io Context \"Administrator@eks-demo.ap-northeast-2.eksctl.io\" renamed to \"eks-demo-cluster\". 컨텍스트 스위칭 # switch context kubectl config use-context eks-demo-cluster # kubectx로 switch context kubectx eks-demo-cluster 배포된 노드 확인 $ kubectx eks-demo-cluster Switched to context \"eks-demo-cluster\". $ kubectl get nodes NAME STATUS ROLES AGE VERSION ip-192-168-22-34.ap-northeast-2.compute.internal Ready \u003cnone\u003e 29m v1.21.5-eks-9017834 ip-192-168-58-247.ap-northeast-2.compute.internal Ready \u003cnone\u003e 29m v1.21.5-eks-9017834 ip-192-168-81-71.ap-northeast-2.compute.internal Ready \u003cnone\u003e 29m v1.21.5-eks-9017834 ","date":"2022-05-06","objectID":"/aws-3-eks-cluster/:1:3","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 3. EKS Cluster 생성하기","uri":"/aws-3-eks-cluster/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. ☁️ 워크샵에는 Cloud9을 구축했지만 나는 따로 구축하지는 않았다. ","date":"2022-05-05","objectID":"/aws-2-cli/:0:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS CLI ","date":"2022-05-05","objectID":"/aws-2-cli/:1:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS CLI 설치하기 (Mac OS) AWS Command Line Interface는 command-line shell 명령어를 사용하여 AWS 서비스의 EC2, VPC 등과 같은 AWS의 리소스를 프로비저닝 할 수 있다. Mac OS는 pkg 파일을 다운로드 하여 설치한다. Mac OS : https://awscli.amazonaws.com/AWSCLIV2.pkg 다른 OS에서 AWS CLI 설치하기 $ aws --version aws-cli/2.6.1 Python/3.9.11 Darwin/21.4.0 exe/x86_64 prompt/o ","date":"2022-05-05","objectID":"/aws-2-cli/:1:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Credential Configure AWS CLI에서 자주 사용되는 구성 설정과 자격 증명을 저장할 수 있다. aws configure 명령어를 통해 자주 사용하는 자격증명 정보를 저장 할 수 있다. 자세한 설명은 여기를 참고한다. aws configure --profile 명령어를 통해 여러 AWS 계정에 접근하도록 관리할 수 있다. –profile 옵션에 계정 이름을 할당한다. aws configure --profile riley-admin 19:05:42 › aws configure AWS Access Key ID [None]: ****************SUIB # IAM 계정 Access Key ID 입력 AWS Secret Access Key [None]: ****************1eOn # IAM 계정 Secret Access Key 입력 Default region name [None]: ap-northeast-2 # 리전 입력 Default output format [None]: json # json 인증 설정 확인하기 인증설정은 cat ~/.aws/config, cat ~/.aws/credentials에 나누어 저장된다. cat ~/.aws/config [profile riley-admin] region = ap-northeast-2 output = json 23:36:50 › cat ~/.aws/credentials [riley-admin] aws_access_key_id = ~~~~~~ aws_secret_access_key = ~~~~~ 테스트 # ec2 인스턴스 조회 aws ec2 describe-instances --profile riley-admin aws sts get-caller-identity # default aws sts get-caller-identity --profile riley-admin ","date":"2022-05-05","objectID":"/aws-2-cli/:1:2","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"kubectl 설치 ","date":"2022-05-05","objectID":"/aws-2-cli/:2:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"kubectl 설치하기 kubectl은 쿠버네티스 클러스터에 명령을 내리는 CLI이다. 쿠버네티스는 오브젝트 생성, 수정, 삭제와 관련한 동작을 수행하기 위해 쿠버네티스 API를 사용한다. 이때 kubectl CLI을 사용하여 해당 명령어가 쿠버네티스 API를 호출하여 관련 동작을 수행한다. Installing kubectl에 접속하여 배포할 Amazon EKS 버전과 상응하는 kubectl를 설치한다. # To install kubectl on macOS $ curl -o kubectl https://s3.us-west-2.amazonaws.com/amazon-eks/1.22.6/2022-03-09/bin/darwin/amd64/kubectl $ chmod +x ./kubectl $ mkdir -p $HOME/bin \u0026\u0026 cp ./kubectl $HOME/bin/kubectl \u0026\u0026 export PATH=$HOME/bin:$PATH kubectl 설치 후 버전 명령어를 통해 잘 설치되었는지 확인한다. $ kubectl version --short --client Client Version: v1.21.2-13+d2965f0db10712 ","date":"2022-05-05","objectID":"/aws-2-cli/:2:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"Kubectl 인증 정보 설정 Kubernetes context 관리 ","date":"2022-05-05","objectID":"/aws-2-cli/:2:2","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"eksctl 설치하기 ","date":"2022-05-05","objectID":"/aws-2-cli/:3:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"eksctl 설치하기 eksctl이란 EKS 클러스터를 쉽게 생성 및 관리하는 CLI 툴 이다. 아래 링크를 통해 해당 OS에 최신 eksctl 바이너리를 직접 다운로드 하거나 해당 명령어를 통해 다운로드 한다. https://github.com/weaveworks/eksctl/releases # To install eksctl on macOS (intel) $ curl --silent --location \"https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz\" | tar xz -C ~/tmp $ sudo mv -v ~/tmp/eksctl /usr/local/bin $ eksctl version ","date":"2022-05-05","objectID":"/aws-2-cli/:3:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"EKS IAM 계정 연결 …(정리중) ","date":"2022-05-05","objectID":"/aws-2-cli/:4:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 2. AWS CLI, eksctl, kubectl 설치 및 설정","uri":"/aws-2-cli/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. \\ ","date":"2022-05-05","objectID":"/aws-eks-cloud9/:0:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Cloud9 AWS Cloud9 은 브라우저만으로 코드를 작성, 실행 및 디버깅할 수 있는 IDE(통합개발환경)이다. 코드 편집기, 디버거 및 터미널 기능을 포함하고 있고 프로그래밍 언어를 위한 필수 도구가 사전에 패키징 되어 제공된다. ","date":"2022-05-05","objectID":"/aws-eks-cloud9/:1:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Cloud9 시작하기 ","date":"2022-05-05","objectID":"/aws-eks-cloud9/:2:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"AWS Cloud9 IDE 구성 AWS Cloud9 콘솔 접속 후 Create environment 버튼 클릭한다. IDE의 Environment 이름 및 설명을 작성한다. 인스턴스 타입을 t3.medium으로, 플랫폼의 경우 Amazon Linux 2 (recommended) 설정 Next Step을 클릭하여 지정한 속성 확인 후 Create environment 클릭하여 environment 생성한다. 생성 완료 ","date":"2022-05-05","objectID":"/aws-eks-cloud9/:2:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"IAM Role 생성하기 IAM Role은 특정 권한을 가진 IAM 자격 증명이다. 서비스에 IAM Role을 부여할 경우 서비스가 사용자를 대신하여 수임받은 역할을 수행할 수 있다. 아래는 Administrator access 정책을 가진 IAM Role을 생성하고 AWS Cloud9에 연결한다. ","date":"2022-05-05","objectID":"/aws-eks-cloud9/:3:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"IAM Role 생성 IAM 대시보드로 접속 후 액세스 관리 \u003e 역할 \u003e 역할 만들기 를 클릭한다. 역할 이름(Role name)에는 eksworkspace-admin 입력 후 권한에는 AdministratorAccess 관리형 정책을 추가하고 역할 생성 버튼을 클릭한다. 실제 환경에서는 AdministratorAccess 정책보다는 환경을 구동할 최소 권한만 부여하는 것이 좋다. ","date":"2022-05-05","objectID":"/aws-eks-cloud9/:3:1","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"IDE(AWS Cloud9 인스턴스)에 IAM Role 부여 EC2 대시보드로 접속한다. 앞에서 생성한 Cloud9 EC2 인스턴스를 선택한다. 작업 \u003e 인스턴스 설정 \u003e IAM 역할 연결/바꾸기를 클릭하여 EC2 콘솔에서 AWS Cloud9 인스턴스에 위에서 생성한 IAM Role을 부여한다. IAM Role에서 eksworkspace-admin 선택 후 저장 ","date":"2022-05-05","objectID":"/aws-eks-cloud9/:3:2","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"Cloud9 IDE에서 IAM 설정 업데이트 AWS Cloud9은 IAM Credentials를 동적으로 관리한다. 생성한 credentials는 EKS IAM authentication과 호환되지 않기에 이를 비활성화하고 IAM Role을 붙인다. (🤔 머선말인지 잘 모르겠지만…) ","date":"2022-05-05","objectID":"/aws-eks-cloud9/:3:3","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] (Optional) AWS Cloud9으로 실습 환경 구축하기","uri":"/aws-eks-cloud9/"},{"categories":["Building Web Applications with Amazon EKS"],"content":" ☁️ Amazon EKS 웹 애플리케이션 구축하기 워크샵을 실습한 내용입니다. ","date":"2022-05-05","objectID":"/aws-1-eks-iam/:0:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 1. IAM 계정 생성","uri":"/aws-1-eks-iam/"},{"categories":["Building Web Applications with Amazon EKS"],"content":"IAM 계정 생성 AWS 계정의 루트사용자로 로그인한다. IAM 대시보드에서 액세스 관리 \u003e 사용자 \u003e 사용자 추가를 선택한다. 사용자 이름을 입력 후 Access type에서 암호-AWS 관리 콘솔 액세스 선택 사용자 지정 비밀번호로 비밀번호 생성한다. 기존 정책 직접 연결(Attach existing policies directly) 선택 후 부여하려는 정책을 선택하여 다음:태그(Next:Tags) 버튼을 클릭. 태그 추가(선택 사항) 단계 후 최종 생성 정보를 확인하고 사용자 만들기(Create User) 클릭하여 생성한다. 사용자가 추가되면 로그인 URL이 생성된다! https://\u003cyour_aws_account_id\u003e.signin.aws.amazon.com/console 루트 사용자에서 로그아웃 후, IAM 계정 URL로 접속하여 로그인 한다. ","date":"2022-05-05","objectID":"/aws-1-eks-iam/:1:0","tags":["AWS","Amazon EKS","Kubernetes","Amazon ECR","AWS Cloud9"],"title":"[AWS EKS] 1. IAM 계정 생성","uri":"/aws-1-eks-iam/"},{"categories":["Tucker의 Go 프로그래밍"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 정리하였습니다. 슬라이스는 Go에서 제공하는 동적 배열 타입이다. 동적 배열은 실행 도중 배열의 사이즈가 계속 바뀔 수 있다. ","date":"2022-04-26","objectID":"/chapter18-slice/:0:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"정적, 동적 상수와 변수의 차이를 생각하면 간단하다. 정적(static) : compile time, build time 시 값이 결정된다. 실행 도중에 절대 바뀔 수 없다. 동적(dynamic) : Runtime. 프로그램 실행 도중에 계속 값이 바뀔 수 있다. 다른언어에서 slice와 비슷한 개념 (동일하지는 않다.) C++ : Vector\u003cint\u003e Java : ArrayList Python : slice Javascript : 기본적으로 동적 배열 ","date":"2022-04-26","objectID":"/chapter18-slice/:1:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"1. 슬라이스 배열과 비슷하지만 []에 배열의 개수를 적지 않고 선언한다. ","date":"2022-04-26","objectID":"/chapter18-slice/:2:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"1.1 슬라이스 선언 var slice []int { } 를 이용해 초기화하기 var slice1 = []int{1, 2, 3} // 대괄호 안에 길이를 넣지 않는 것을 주의 var slice2 = []int{1, 5:2, 10:3} // [1 0 0 0 0 2 0 0 0 0 3] var array = [...]int{1, 2, 3} // 배열 선언 var slice = []int{1, 2, 3} // 슬라이스 선언 make()를 이용한 초기화 내장함수인 make()를 사용하여 초기화 할 수 있다. var slice = make([]int, 3) // 3개의 길이를 갖는 int 슬라이스 // 결과 [0 0 0] ","date":"2022-04-26","objectID":"/chapter18-slice/:2:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"1.2 슬라이스 요소 접근 슬라이스 요소에 접근하는 방법은 배열과 동일하다. 대괄호 사이에 인덱스를 써서 요소에 접근한다. var slice = make([]int, 3) slice[1] = 5 ","date":"2022-04-26","objectID":"/chapter18-slice/:2:2","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"1.3 슬라이스 순회 방법 var slice = []int{1, 2, 3} // for loop for i := 0; i \u003c len(slice); i++ {} // for range for i, v := range slice {} ","date":"2022-04-26","objectID":"/chapter18-slice/:2:3","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"1.4 슬라이스 요소 추가 - append() append()는 첫 번째 인수로 들어온 슬라이스에 요소가 추가된 새로운 슬라이스를 반환한다. var slice = []int{1, 2, 3} slice := append(slice, 4) 하나 이상 값도 추가가 가능하다. slice = append(slice, 3, 4, 5, 6, 7) ","date":"2022-04-26","objectID":"/chapter18-slice/:2:4","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"2. 슬라이스의 동작 원리 슬라이스는 내장 타입으로 내부 구현이 감추어져있지만 reflect 패키지의 SliceHeader 구조체를 사용해 내부 구현을 볼 수 있다. type SliceHeader struct { Data uintptr // 실제 배열을 가리키는 포인터 Len int // 요소 개수 Cap int // 실제 배열의 길이0 } [그림] SliceHeader 구조체 ","date":"2022-04-26","objectID":"/chapter18-slice/:3:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"2.1 Make() 함수를 사용해서 선언 make() 함수로 슬라이스를 생성할 때 인수값에 따라 배열길이와 배열의 최대 크기를 지정할 수 있다. var slice = make([]int 3) // len:3, cap:3 (요소개수 3, 최대길이 3) var slice2 = make([]int, 3, 5) // len:3, cap:5 (요소개수 3, 최대길이 5) ","date":"2022-04-26","objectID":"/chapter18-slice/:3:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"2.2 슬라이스와 배열의 동작 차이 SliceHeader 구조체에서 Data는 실제 배열을 참조하고 있다. 그렇기 때문에 배열과 동작에서 차이가 있으며 사용법이 비슷하다고 해서 똑같이 사용했을 경우 예기치 못한 버그를 만날 수 있다. package main import \"fmt\" func changeArray(arr [5]int) { arr[2] = 200 // 서로 다른 메모리 공간 } func changeSlice(slice []int) { slice[2] = 200 } func main() { arr := [5]int{1, 2, 3, 4, 5} slice := []int{1, 2, 3, 4, 5} changeArray(arr) changeSlice(slice) fmt.Println(\"배열 : \", arr) fmt.Println(\"슬라이스 : \", slice) } 결과 배열 : [1 2 3 4 5] 슬라이스 : [1 2 200 4 5] ","date":"2022-04-26","objectID":"/chapter18-slice/:3:2","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"2.3 동작 차이의 원인 Go 언어에서 대입연산은 값을 복사하는 것이다. 포인터는 포인터의 값이 메모리값 주소가 복사, 구조체는 구조체의 모든 필드 값이 복사된다. 함수의 매개변수는 값 복사가 발생한다. changeArray(arr [5]int) 함수의 매개변수 arr은 배열이므로 int 5개짜리 배열의 값이 복사되어 main() 함수의 arr와는 별개의 인스턴스가 된다. (총 8byte * 5= 40 byte) changeSlice(slice []int) 함수의 매개변수 slice []int는 실제 배열을 가리키는 포인터, len, cap 세 개의 필드로 구성된 구조체이다. 구조체의 값이 그대로 복사되므로 실제 배열을 가리키는 포인터의 메모리 주소도 함께 복사되어 사용된다. (8byte * 3 = 24 byte) ","date":"2022-04-26","objectID":"/chapter18-slice/:3:3","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"2.4 append()를 사용할 때 발생할 수 있는 예기치 못한 문제 - 1 빈 공간이 충분할 때 append() 함수가 호출되면 먼저 슬라이스에 값을 추가할 수 있는 빈공간이 있는지 확인한다. 남은공간은 실제 배열 길이 cap에서 슬라이스 요소개수 len을 뺀 값을 의미한다. 남은공간 = cap - len package main import \"fmt\" func main() { slice1 := make([]int, 3, 5) // 1) slice2 := append(slice1, 4, 5) // 2) fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) slice1[1] = 100 // 3) fmt.Println(\"After change second element\") fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) slice1 = append(slice1, 500) // 4) fmt.Println(\"After change second element\") fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) } 결과 slice1 : [0 0 0] 3 5 slice2 : [0 0 0 4 5] 5 5 After change second element slice1 : [0 100 0] 3 5 slice2 : [0 100 0 4 5] 5 5 After change second element slice1 : [0 100 0 500] 4 5 slice2 : [0 100 0 500 5] 5 5 1) 요소개수 3, 최대길이 5의 슬라이스 구조체가 생성된다. 이때 남은 길이는 5-3 = 2개이다. 2) append() 함수가 호출되면 slice1의 배열에 빈공간이 있는지 확인한다. 두 개의 빈공간이 있으므로 4, 5를 추가할 수 있다. append()는 빈 공간에 값을 추가하고 요소 값이 2개 증가 된 슬라이스 구조체 (slice2)를 반환한다. 같은 구조체 값이 복사되었으므로 slice1과 slice2가 참조하는 배열의 주소값은 같다. 3) 같은 배열 주소를 참조하므로 변경된 값이 동일하게 적용되었다. 4) append() 함수를 통해 slice1에 빈공간이 있는지 확인하고 slice1[len] 자리에 500을 쓰고 len 값을 1 증가 시킨다. ","date":"2022-04-26","objectID":"/chapter18-slice/:3:4","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"2.5 append()를 사용할 때 발생할 수 있는 예기치 못한 문제 - 2 빈 공간이 충분하지 않을 때 append() 함수 실행시 빈 공간이 충분하지 않으면 더 큰 새 배열을 생성 한다. (일반적으로 두배 크기로 마련한다.) 그 다음 기존의 배열의 모든 요소를 새로운 배열에 복사한다. cap은 새로운 배열의 길, len은 기존 길이에 추구한 요소 개수만큼 더한 값이 된다. 포인터는 새로 생성한 배열을 가리키는 슬라이스 구조를 갖는다. package main import \"fmt\" func main() { slice1 := []int{1, 2, 3} // 1) slice2 := append(slice1, 4, 5) // 2) fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) slice1[1] = 100 // 3) fmt.Println(\"After change second element\") fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) slice1 = append(slice1, 500) // 4) fmt.Println(\"After change second element\") fmt.Println(\"slice1 : \", slice1, len(slice1), cap(slice1)) fmt.Println(\"slice2 : \", slice2, len(slice2), cap(slice2)) } 결과 slice1 : [1 2 3] 3 3 slice2 : [1 2 3 4 5] 5 6 After change second element slice1 : [1 100 3] 3 3 slice2 : [1 2 3 4 5] 5 6 After change second element slice1 : [1 100 3 500] 4 6 slice2 : [1 2 3 4 5] 5 6 1) 1,2,3 len:3 cap:3인 슬라이스가 생성 2) append() 함수가 호출 되었을 때 4,5를 추가할 빈공간이 없으므로 새료운 배열을 생성하고 4,5를 추가 후 len:5, cap:6을 갖는 새로운 슬라이스를 반환한다. 3), 4) slice2의 경우 capacity가 늘어난 새로운 배열을 참조하므로 slice1만 변경된다. 정리 append()는 슬라이스가 가리키고 있는 배열의 capacity가 충분하면 값을 추가하고 그 배열을 참조값을 갖는 슬라이스 구조체를 리턴한다. capacity가 충분하지 않으면 더 큰 배열을 생성하고 생성된 새로운 배열을 참조하는 슬라이스 구조체를 리턴한다. ","date":"2022-04-26","objectID":"/chapter18-slice/:3:5","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"3. 슬라이싱 slicing 슬라이싱은 배열의 일부를 집어내는 기능이다. 슬라이싱하면 그 결과로 배열 일부를 가리키는 슬라이스를 반환한다. 새로운 배열이 만들어지는게 아니라 배열의 일부를 포인터로 가리키는 슬라이스를 반환하게 된다. array[startIndex:endIndex] ","date":"2022-04-26","objectID":"/chapter18-slice/:4:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"3.1 슬라이싱으로 배열 일부를 가르키는 슬라이스 만들기 package main import \"fmt\" func main() { arr := [5]int{1, 2, 3, 4, 5} slice := arr[1:2] // 1) fmt.Println(\"array : \", arr) fmt.Println(\"slice : \", slice, len(slice), cap(slice)) arr[1] = 100 // 2) fmt.Println(\"After change second element\") fmt.Println(\"array : \", arr) fmt.Println(\"slice : \", slice, len(slice), cap(slice)) slice = append(slice, 500) // 3) fmt.Println(\"After append 500\") fmt.Println(\"array : \", arr) fmt.Println(\"slice : \", slice, len(slice), cap(slice)) } 결과 array : [1 2 3 4 5] slice : [2] 1 4 After change second element array : [1 100 3 4 5] slice : [100] 1 4 After append 500 array : [1 100 500 4 5] slice : [100 500] 2 4 1) array 배열의 시작 인덱스 1 끝 인덱스 이전 인덱스 범위의만 집어낸다. (len:1, capacity:4) 2) slice가 array의 두번째 값을 가리키기 때문에 array의 값이 바뀌면 slice값도 바뀐다. 3) slice의 capacity가 4이므로 새로운 배열을 만들지 않고 array의 인덱스 2의 값을 변경하게 된다. ","date":"2022-04-26","objectID":"/chapter18-slice/:4:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"3.2 슬라이스를 슬라이싱 하기 슬라이싱 기능은 배열 뿐만 아니라 슬라이스 일부를 집어낼 때도 사용할 수 있다. func main() { arr := [100]int{1: 1, 2: 2, 99: 100} slice1 := arr[1:10] slice2 := slice1[2:99] fmt.Println(slice1) fmt.Println(slice2) } 결과 [1 2 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 100] 처음부터 슬라이싱 slice1 := []int{1, 2, 3, 4, 5} slice2 := slice[0:3] // 생략 가능 slice2 := slice[:3] 끝까지 슬라이싱 slice1 := []int{1, 2, 3, 4, 5} slice2 := slice1[2:len(slice1)] // [3, 4, 5] // 생략 가능 slice2 := slice1[2:] // [3, 4, 5] 전체 슬라이싱 array := [5]int{1, 2, 3, 4, 5} slice := array[:] 인덱스 3개로 슬라이싱하여 cap 크기를 조절 인덱스를 2개만 사용할 경우 cap은 배열의 전체 길이 - 시작인덱스를 뺀 값이 된다. 인덱스 3개를 사용하면 cap 값을 조절할 수 있다. slice[시작인덱스 : 끝인덱스 : 최대인덱스] slice1 := []int{1, 2, 3, 4, 5} slice2 := slice1[1:3:4] ","date":"2022-04-26","objectID":"/chapter18-slice/:4:2","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"4. 유용한 슬라이싱 기능 활용 ","date":"2022-04-26","objectID":"/chapter18-slice/:5:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"4.1 슬라이스 복제 슬라이스를 그대로 복사해서 새로운 슬라이스를 만들면 두 슬라이스가 서로 영향을 주지 않는다. 슬라이스를 복제하는 방법은 여러가지 이며 성능상 차이는 없기 때문에 편한 방법을 이용한다. 반복문을 이용한 값 복제 func main() { slice1 := []int{1, 2, 3, 4, 5} slice2 := make([]int, len(slice1)) for i, v := range slice1 { slice2[i] = v } slice2[1] = 100 fmt.Println(\"slice1 : \", slice1) fmt.Println(\"slice2 : \", slice2) } append() 함수를 이용한 값 복제 slice1 := []int{1, 2, 3, 4, 5} slice2 := make([]int{}, slice1...) copy() 함수를 이용한 값 복제 slice1 := []int{1, 2, 3, 4, 5} slice2 := make([]int, len(slice1)) copy(slice1, slice2) ","date":"2022-04-26","objectID":"/chapter18-slice/:5:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"4.2 요소 삭제하기 슬라이스 중간의 요소를 삭제하는 방법이다. 중간에 위치한 삭제 요소 이후의 값을 앞당겨서 삭제된 요소를 채운다. 마지막 값을 지워준다. package main import \"fmt\" func main() { slice1 := []int{1, 2, 3, 4, 5, 6} idx := 2 for i := idx + 1; i \u003c len(slice1); i++ { slice1[i-1] = slice1[i] } slice1 = slice1[:len(slice1)-1] fmt.Println(slice1) } append() 함수 이용 처음 요소 부터 삭제할 요소의 이전 요소 슬라이스와 삭제할 요소 이후 부터 끝까지 슬라이싱 된 슬라이스를 append()한다. slice1 = append(slice1[:idx], slice1[idx+1:]...) ","date":"2022-04-26","objectID":"/chapter18-slice/:5:2","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"4.3 요소 추가 슬라이스 중간에 요소를 추가한다. package main import \"fmt\" func main() { slice := []int{1, 2, 3, 4, 5, 6} idx := 2 slice = append(slice, 0) // 1. 맨 뒤에 요소 추가 // 2. 맨 뒤의 인덱스부터 삽입하려는 위치까지 한 칸씩 뒤로 밀어준다. for i := len(slice) - 2; i \u003e= idx; i-- { slice[i+1] = slice[i] } // 3. 값 변경 slice[idx] = 100 fmt.Println(slice) } 슬라이스 맨 뒤에 요소를 추가한다. 맨 뒤값부터 삽입하려는 위치까지 한 칸씩 뒤로 밀어준다. 삽입하는 위치의 값을 바꿔준다. append() 함수로 코드 개선 slice = append(slice[:idx], append([]int{100}, slice[idx:]...)...) 불필요한 메모리 사용이 없도록 코드 개선 위에서 append() 구문으로 생성한 [100, 3, 4, 5, 6] 슬라이스는 임시 버퍼 슬라이스 이다. 연산을 위해 임시로 생성되었으며 나중에 사라지기는 하나 불필요한 메모리 자원이 사용되었다. slice = append(slice, 0) // 1. 맨 뒤에 요소 추가 copy(slice[idx+1:], slice[idx:]) // 2. 하나씩 뒤로 복사 ","date":"2022-04-26","objectID":"/chapter18-slice/:5:3","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"5 슬라이스 정렬 ","date":"2022-04-26","objectID":"/chapter18-slice/:6:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"5.1 int 슬라이스 정렬 sort 패키지의 Ints() 함수를 이용하여 정렬 package main import ( \"fmt\" \"sort\" ) func main() { slice := []int{5, 2, 6, 3, 1, 4} // 1. 정렬되지 않은 슬라이스 sort.Ints(slice) // 2. 정렬 fmt.Println(slice) } ","date":"2022-04-26","objectID":"/chapter18-slice/:6:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"5.2 구조체 슬라이스 정렬 Sort() 함수를 이용하기 위해서는 Len(), Less(), Swap() 메서드를 구현해야 한다. 이를 이용하면 우리가 정의한 구조체도 정렬을 할 수 있다. https://pkg.go.dev/sort#Sort package main import ( \"fmt\" \"sort\" ) type Student struct { Name string Age int } type Students []Student // 1) // 2) func (s Students) Len() int { return len(s) } func (s Students) Less(i, j int) bool { return s[i].Age \u003c s[j].Age } func (s Students) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func main() { s := []Student{ {\"화랑\", 31}, {\"백두산\", 52}, {\"류\", 42}, {\"켄\", 38}, {\"송하나\", 18}, } sort.Sort(Students(s)) // 3) fmt.Println(s) } 결과 [{송하나 18} {화랑 31} {켄 38} {류 42} {백두산 52}] 1) []Student 별칭 타입 Students 생성 2) Len(), Less(), Swap() 메서드 구현하여 sort.Interface를 사용할 수 있게 해준다. 3) []Student를 Students 타입으로 변환한 뒤 sort.Sort() 함수를 호출 Students는 이미 sort.Interface 메서드를 포함하고 있기 때문에 sort.Sort() 인수로 사용할 수 있다. ","date":"2022-04-26","objectID":"/chapter18-slice/:6:2","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 18. 슬라이스","uri":"/chapter18-slice/"},{"categories":["Docker/Kubernetes"],"content":" 시작하세요! 도커/쿠버네티스 책 정리 🐳🐳🐳 ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:0:0","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"1 도커 이미지와 컨테이너 도커 엔진에서 사용하는 기본단위는 이미지와 컨테이너이다. ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:1:0","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"1.1 도커 이미지 이미지는 컨테이너를 생성할 때 필요한 요소이다. 가상 머신을 생성할 때 사용하는 iso 파일과 비슷한 개념이다. 여러 개의 계층으로 된 바이너리 파일로 존재, 컨테이너를 생성하고 실행할 때 읽기 전용으로 사용된다. 도커 이미지의 구성 도커 이미지 이름은 저장소 이름/이미지 이름:[태그] 형태로 구성 된다. 저장소 (Repository) : 이미지가 저장된 장소. 저장소 이름이 명시되지 않은 이미지는 도커에서 기본적으로 제공하는 이미지 저장소인 도커 허브의 공식 이미지. 이미지 이름 : 이미지가 어떤 역할을 하는지 나타냄. 이미지 이름을 생략할 수 없으며 반드시 설정 태그 : 이미지의 버전 관리, 혹은 리비전 Revision 관리에 사용. 태그를 생략하면 이미지의 latest 로 인식 ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:1:1","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"1.2 도커 컨테이너 이미지로 컨테이너를 생성하면 해당 이미지 목적에 맞는 파일이 들어 있는 격리된 시스템 및 자원 네트워크를 사용할 수 있는 독립된 공간이 생성 된다. 컨테이너 이미지를 읽기 전용으로 사용하되 이미지에서 변경된 사항만 저장하므로 원래 이미지는 영향을 받지 않는다. 생성된 각 컨테이너는 각기 독립된 파일시스템을 제공 받으며 호스트와 분리돼 있으므로 특정 컨테이너에서 어떤 어플리케이션을 삭제해도 다른 컨테이너와 호스트에는 영향을 주지 않는다. ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:1:2","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"2. 도커 컨테이너 다루기 ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:2:0","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"2.1 컨테이너 생성 도커는 다양한 기능이 빠르게 업데이트되고 새로운 버전이 배포되므로 설치된 도커 엔진을 먼저 확인해야 한다. sudo docker -v Docker version 19.03.12, build 48a66213fe 컨테이너 생성 후 접속 sudo docker run -i -t ubuntu:14.04 docker run : 컨테이너를 생성하고 실행하는 역할 -i -t : -i 옵션으로 컨테이너와 상호 interactive 입출력을, -t 옵션으로 tty 를 활성화해서 bash 쉘을 사용하도록 컨테이너를 설정. ubuntu:14.04 이미지가 엔진에 존재하지 않는 경우 도커 중앙 이미지 저장소인 도커 허브에서 자동으로 이미지를 내려 받음 위의 명령어로 실행할 경우 컨테이너 생성과 동시에 도커 환경 내부로 접속된다. 호스트 도커 환경으로 복귀하려면, exit를 입력한다. 이 방법은 컨테이너 내부에서 빠져나오면서 동시에 컨테이너를 정지한다. Ctrl + P, Q 입력한다. 단순히 컨테이너의 쉘에서만 빠져나온다. create 명령 sudo docker create -i -t --name mycentos centos:7 # docker 컨테이너 실행하기 sudo docker start mycentos # docker 컨테이너 내부로 들어가기 sudo docker attach mycentos run 명령어와 create 명령어의 차이점 run 명령어 : pull, create, start 명령어를 일괄적으로 실행한 attach가 가능한 컨테이너라면 컨테이너 내부로 들어간다. create 명령어 : pull 한 뒤 컨테이너만 생성할 start, attach를 실행하지 않는다. 보통은 run 명령어를 더 많이 사용한다. 도커 이미지 내려받기 sudo docker pull centos:7 도커 엔진에 존재하는 이미지 조회 sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 18.04 2eb2d388e1a2 10 days ago 64.2MB wordpress latest 04b52c96c4b6 11 days ago 543MB mysql 5.7 8679ced16d20 11 days ago 448MB mysql 8 e3fcc9e1cc04 11 days ago 544MB ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:2:1","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"2.2 컨테이너 목록 확인 생성한 컨테이너 목록 확인 # 정지되지 않은 컨테이너만 출력 sudo docker ps # 정지된 컨테이너를 포함한 모든 컨테이너 출력 sudo docker ps -a CONTAINER ID : 컨테이너에게 할당되는 고유한 ID. 위 결과에서는 ID의 일부분 밖에 확인할 수 없지만 컨테이너를 확인하기 위해 docker inspect 명령어를 사용하면 전체 ID를 확인할 수 있다. IMAGE : 컨테이너를 생성할 때 사용된 이미지 이름. COMMAND : 커맨드는 컨테이너가 시작될 때 실행 명령어. 커맨드는 대부분의 이미지에 미리 내장되어 있기 때문에 별도로 설정할 필요가 없다. CREATE : 컨테이너가 생성되고 난 뒤 흐른 시간을 나타냄 STATUS : 컨테이너의 상태를 나타낸다. Exited... 는 정지된 상태 나타내며 Up ... seconds 는 실행중인 상태를 나타낸다. PORTS : 컨테이너가 개방한 포트와 호스트에 연결한 포트를 나열. NAMES : 컨테이너의 고유 이름. docker rename 명령어를 통해 컨테이너 이름을 변경할 수도 있다. # 컨테이너 이름 변경 docker rename angry_morse my_container ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:2:2","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"2.3 컨테이너 삭제 docker rm 명령어를 통해 컨테이너를 삭제할 수 있다. 한 번 삭제한 컨테이너는 복구할 수 없으므로 신중을 기해야 한다. 도커 컨테이너 삭제 실행 중인 컨테이너는 삭제할 수 없다. 실행 중인 컨테이너를 종료하거나 강제삭제 옵션을 추가해야한다. # 실행 중인 컨테이너 종료 후 삭제 docker stop mycentos docker rm mycentos # 강제 옵션을 통한 삭제 docker rm -f mycentos 모든 도커 컨테이너 삭제 - prune prune 명령어를 사용하면 모든 컨테이너를 한번에 삭제할 수 있다. riley@DESKTOP-XXXXX:~$ docker container prune WARNING! This will remove all stopped containers. Are you sure you want to continue? [y/N] y Total reclaimed space: 0B ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:2:3","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"2.4 컨테이너를 외부에 노출 컨테이너는 가상 머신과 마찬가지로 가상 IP 주소를 할당 받는다. 기본적으로는 172.17.0.x의 IP를 순차적으로 받게 된다. (나는 WSL2 우분투 사용중이라 네트워크 정보가 조금 다른것 같다.) ifconfig 명령어를 통해 도커의 NAT IP를 할당받은 eht0 인터페이스와 로컬 lo 인터페이스를 확인 할 수 있다. 외부에 컨테이너의 애플리케이션을 노출하기 위해서는 eth0의 IP와 포트를 호스트의 IP와 포트에 바인딩 해야 한다. # ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 172.21.154.31 netmask 255.255.240.0 broadcast 172.21.159.255 inet6 fe80::215:5dff:fe81:5ff2 prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:15:5d:81:5f:f2 txqueuelen 1000 (Ethernet) RX packets 5941 bytes 1924948 (1.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 146 bytes 10909 (10.9 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 도커 컨테이너로 아파치 웹서비스 띄우기 docker run -i -t --name mywebserver -p 80:80 ubuntu:18.04 root@b6e1a96299bb:/# apt-get update root@b6e1a96299bb:/# apt-get install apache2 -y root@b6e1a96299bb:/# service apache2 start 아파치 웹 서버는 172 대역을 가진 컨테이너의 NAT IP와 80번 포트로 서비스하므로 여기에 접근하려면 172.x.x.x:80 의 주소로 접근해야 한다. 도커의 포트 포워딩 옵션인 -p 옵션을 통해 호스트와 컨테이너를 연결했으므로 호스트 ip를 통해 172.x.x.x:80에 접근할 수 있다. ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:2:4","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"2.5 컨테이너 어플리케이션 구축 보통은 여러 에이전트나 데이터베이스 등을 연결하여 하나의 서비스로 동작시킨다. 이런 서비스를 컨테이너화(Containerize)할 때 여러개의 애플리케이션을 하나의 컨테이너에 설치할 수 있다. 컨테이너에 애플리케이션을 하나만 동작시키면 컨테이너 간 독립성을 보장함을 동시에 애플리케이션의 버전 관리, 소스코드 모듈화 등이 더 쉬워진다. 도커에서는 한 컨테이너에 하나의 프로세스만 실행하도록 권장한다. MySql 이미지로 데이터베이스 컨테이너 생성 docker run -d \\ --name wordpressdb \\ -e MYSQL_ROOT_PASSWORD=password \\ -e MYSQL_DATABASE=wordpress \\ mysql:5.7 워드프레스 이미지로 워드프레스 웹 서비스 컨테이너 생성 docker run -d \\ -e WORDPRESS_DB_PASSWORD=password \\ --name wordpress \\ --link wordpressdb:mysql \\ -p 80 \\ wordpress -d : Detached 모드로 컨테이너를 실행한다. Detached 모드는 백그라운드에서 동작하는 애플리케이션으로써 실행하도록 설정. 컨테이너 내부에서 프로그램이 foreground로 실행된다. -e : 컨테이너 내부의 환경변수 설정 docker exec -i -t wordpressdb /bin/bash root@d777facb7e1f:/# echo ${MYSQL_ROOT_PASSWORD} password exec : 명령어를 사용하면 컨테이너 내부에서 명령어를 실행한 뒤 그 결과값을 반환 받을 수 있다. -i, -t 옵션을 추가해 /bin/bash로 상호 입출력이 가능한 형태로 exec를 사용할 수 있다. --link : deprecated 된 옵션이며 도커 브리지(bridge) 네트워크를 사용하면 link와 동일한 기능을 손쉽게 사용할 수 있다. docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0ba1266d50e0 wordpress \"docker-entrypoint.s…\" 3 seconds ago Up 2 seconds 0.0.0.0:57594-\u003e80/tcp wordpress 7a8d5ded323e mysql:5.7 \"docker-entrypoint.s…\" 29 seconds ago Up 27 seconds 3306/tcp, 33060/tcp wordpressdb # wordpress가 사용중인 포트 확인하기 $ docker port wordpress 80/tcp -\u003e 0.0.0.0:57594 포트 54746과 호스트의 80 포트와 매핑되었다. ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:2:5","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"2.6 도커 볼륨 도커 이미지로 컨테이너를 생성하면 이미지는 읽기 전용이 되고 컨테이너의 변경 사항만 별도 저장하여 컨테이너의 정보를 보존한다. 이미 생성된 이미지는 어떠한 경우로도 변경되지 않으며, 컨테이너 계층에 원래 이미지에서 변경된 파일시스템 등을 저장한다. 생성된 mysql 이미지에는 mysql을 실행하는 데 필요한 애플리케이션 파일이, 컨테이너 계층에는 워드프레스에서 쓴 로그인 정보나 게시글 등과 같은 데이터베이스를 운용하면서 쌓인 데이터가 저장된다. [그림] 이미지와 컨테이너의 구조 위의 mysql 컨테이너를 삭제하면 컨테이너 계층에 저장되어 있던 데이터베이스의 정보도 모두 사라진다. 도커는 컨테이너의 생성과 삭제가 매우 쉬으므로 데이터를 영속적(Persistent)로 활용할 수 있는 방법은 아래와 같다. 볼륨 생성 방법 호스트 볼륨 공유 볼륨 컨테이너 활용 도커가 관리하는 볼륨 이용 2.6.1 호스트 볼륨 공유 -v 옵션을 통해 ~/wordpress_db:/var/lib/mysql로 설정하여 [호스트 공유 디렉터리]:[컨테이너 공유 디렉터리] 형태로 디렉토리를 공유한다. ~/wordpress_db 에 mysql 구동에 필요한 파일이 공유된 것을 확인 할 수 있다. 컨테이너의 /var/lib/mysql 디렉터리는 호스트의 ~/wordpress_db 디렉터리와 동기화되는 것이 아니라 완전히 같은 디렉터리이다. docker run -d \\ --name wordpressdb_hostvolume \\ -e MYSQL_ROOT_PASSWORD=password \\ -e MYSQL_DATABASE=wordpress \\ -v ~/wordpress_db:/var/lib/mysql mysql:5.7 docker run -d \\ -e WORDPRESS_DB_PASSWORD=password \\ --name wordpress_hostvolume \\ --link wordpressdb_hostvolume:mysql \\ -p 80 wordpress 컨테이너를 삭제해도 호스트 공유 디렉터리(~/wordpress_db)에는 mysql 컨테이너가 사용한 데이터가 그대로 남아 있다. # stop containers docker stop wordpress_hostvolume wordpressdb_hostvolume # remove containers docker rm wordpress_hostvolume wordpressdb_hostvolume 💡 이미지에 이미 존재하던 디렉터리에 호스트의 볼륨을 공유하면 컨테이너 디렉터리가 덮어씌워진다. 2.6.2 볼륨 컨테이너 -v 옵션으로 볼륨을 사용하는 컨테이너를 다른 컨테이너와 공유하는 방법이 있다. 컨테이너를 생성할 때 –volumes-from 옵션을 설정하면 -v 또는 --volume 옵션을 적용한 컨테이너의 볼륨 디렉터리를 공유할 수 있다. 호스트에서 볼륨만 공유하고 별도의 역할을 담당하지 않는 볼륨 컨테이너로 활용하는 것이 가능하다. 2.6.3 도커가 관리하는 볼륨이용 docker volume 명령어를 사용하여 도커 자체에서 제공하는 볼륨 기능을 활용할 수도 있다. docker volume create --name myvolume 호스트와 볼륨을 공유할 때는 다음과 같은 형식으로 입력한다. [볼륨이름]:[컨테이너의 공유 디렉터리] docker run -i -t --name myvolume_1 \\ -v myvolume:/root/ \\ ubuntu:18.04 docker inspect 명령어를 이용하면 볼륨이 실제 어디에 저장되는지 알 수 있다. docker inspect --type volume myvolume ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:2:6","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"2.7 도커 네트워크 ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:3:0","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"도커 네트워크 구조 도커는 컨테이너 내부 IP를 순차적으로 할당한다. 이 IP는 컨테이너를 재시작 할 때마다 변경 될 수 있다. 각 컨테이너에 외부와의 네트워크를 제공하기 위해 각 컨테이너마다 가상 네트워크 인터페이스를 호스트에 생성한다. 이름은 veth(virtual eth)로 시작한다. docker0 브리지는 각 veth 인터페이스와 바인딩 되어 호스트의 eth0 인터페이스와 이어주는 역할을 한다. ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:3:1","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Docker/Kubernetes"],"content":"도커 네트워크 기능 컨테이너를 생성하면 기본적으로 docker0 브릿지를 통해 통신한다. 도커가 자체적으로 제공하는 네트워크로는 bridge, host, none, container, overlay 가 있다. weave, flannel, openvswitch 등의 서드파티 플러그인 솔루션을 활용하여 확장된 네트워크를 구성할 수 있다. ","date":"2022-04-20","objectID":"/chapter2-1-docker-engine/:3:2","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 2. 도커 엔진","uri":"/chapter2-1-docker-engine/"},{"categories":["Javascript"],"content":"개요 Go의 라이브러리에서 사용하는 SHA3-512 해시값과 자바스립트에서 사용하는 CryptoJS의 SHA3-512 해시값이 다른 문제가 발생 ","date":"2022-04-17","objectID":"/hash3/:1:0","tags":["Javascript","SHA3","Keccak","CryptoJS"],"title":"Javascript SHA3 라이브러리 조사","uri":"/hash3/"},{"categories":["Javascript"],"content":"테스트 대상 모듈 hash.js js-sha3 CrytoJS ","date":"2022-04-17","objectID":"/hash3/:2:0","tags":["Javascript","SHA3","Keccak","CryptoJS"],"title":"Javascript SHA3 라이브러리 조사","uri":"/hash3/"},{"categories":["Javascript"],"content":"테스트 방법 Go의 테스트 코드 작성 후 Go에서 생성한 해시값과 Javascript에서 위의 라이브러리로 생성했을 때 해시값이 같은지 비교한다. ","date":"2022-04-17","objectID":"/hash3/:3:0","tags":["Javascript","SHA3","Keccak","CryptoJS"],"title":"Javascript SHA3 라이브러리 조사","uri":"/hash3/"},{"categories":["Javascript"],"content":"테스트 결과 hash.js : SHA3-512 관련 함수가 없는 것 같았다. js-sha3 : 성공 CrytoJS : 실패 CrytoJS 의 경우 Go에서 사용하는 SHA3-512와 차이가 있는 것 같다. cryptojs_document에 참고 사항이 있었다. NOTE: I made a mistake when I named this implementation SHA-3. It should be named Keccak[c=2d]. Each of the SHA-3 functions is based on an instance of the Keccak algorithm, which NIST selected as the winner of the SHA-3 competition, but those SHA-3 functions won’t produce hashes identical to Keccak. ","date":"2022-04-17","objectID":"/hash3/:4:0","tags":["Javascript","SHA3","Keccak","CryptoJS"],"title":"Javascript SHA3 라이브러리 조사","uri":"/hash3/"},{"categories":["Javascript"],"content":"Go 테스트 코드 func TestSha3(t *testing.T) { addr, _ := utils.FromHex(\"079164CF59F8B91DA6EC0767CB78075D73E93994\") tx, _ := utils.FromHex(\"D08BC04E9EDACA0D964BF7404CD1E9C4939C1F099F26177B9B8597BC521BC5CE\") shashum1 := sha3.New512() shashum1.Write(addr) println(\"[addr to sha3-512] \", utils.ToHex(shashum1.Sum(nil), false)) shashum2 := sha3.New512() shashum2.Write(tx) println(\"[txHash to sha3-512] \", utils.ToHex(shashum2.Sum(nil), false)) hasher512 := sha3.New512() hasher512.Write(addr) hasher512.Write(tx) sha512 := hasher512.Sum(nil) hasher160 := ripemd160.New() _, _ = hasher160.Write(sha512) println(\"[data-account] \", utils.ToHex(hasher160.Sum(nil), false)) } ","date":"2022-04-17","objectID":"/hash3/:4:1","tags":["Javascript","SHA3","Keccak","CryptoJS"],"title":"Javascript SHA3 라이브러리 조사","uri":"/hash3/"},{"categories":["Javascript"],"content":"javascript test(\"Test sha3-512\", () =\u003e { const u8Addr = Hex.toU8Array('079164CF59F8B91DA6EC0767CB78075D73E93994'); const expected_sha3_512 = 'A6CEF82C523F10ABE2684E19FD1AB35580E8B2DCE4926280B6CEC829D2A1A734F46A642BAA5C62369F185577D23A8428D50C201842B62663DCEB1EF2CD911853'; // js-sha3 (pass) const shasum = sha3_512.create() shasum.update(u8Addr) shasum.hex() expect(shasum.toString().toUpperCase()).toEqual(expected_sha3_512) // hashjs (fail) const shasum2 = hashjs.sha512().update(u8Addr).digest('hex') console.log(shasum2.toUpperCase()) expect(shasum2.toUpperCase()).toEqual(expected_sha3_512) // CRYPTOJS (fail) const shasum3 = CryptoJS.SHA3.create(u8Addr, {outputLength: 512}); expect(shasum3.toUpperCase()).toEqual(expected_sha3_512) }); ","date":"2022-04-17","objectID":"/hash3/:4:2","tags":["Javascript","SHA3","Keccak","CryptoJS"],"title":"Javascript SHA3 라이브러리 조사","uri":"/hash3/"},{"categories":["Javascript"],"content":"결론 및 답변 내용 SHA-3은 SHA-1과 SHA-2를 대체하기 위해 미국 국립표준기술연구소(NIST)가 공개적인 방식을 통해 선정한 암호화 해시 함수이다. 최종 적으로 Keccak이 SHA-3의 해시 알고리즘으로 선정되었고 그 이후 NIST에서 변경된 암호화 해시 함수 표준을 발표했다. 결과적으로 처음 선정되었던 Keccak 방식과 현재 공식적인 SHA3 방식이 일부 달라지게 되었다. CryptoJS 에서 구현한 SHA3은 공식적인 SHA3이 아니라 이전 SHA3(Keccak)으로 보임. js-sha3 라이브러리가 추가됨에 따라 최적화가 필요하므로 hash-wasm 라이브러리를 추천해주심. ","date":"2022-04-17","objectID":"/hash3/:5:0","tags":["Javascript","SHA3","Keccak","CryptoJS"],"title":"Javascript SHA3 라이브러리 조사","uri":"/hash3/"},{"categories":["Think Data Structures"],"content":"목표 자바 배열을 사용하여 요소를 저장하는 List 인터페이스 구현한다. ","date":"2022-02-26","objectID":"/think-data-structures-1/:1:0","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"클래스 정의와 인스턴스 변수, 생성자 public class MyArrayList\u003cT\u003e implements List\u003cT\u003e { int size; // keeps track of the number of elements private T[] array; // stores the elements public MyArrayList() { array = (T[]) new Object[10]; size = 0; } } size 변수는 MyArrayList의 요소 개수를 추적한다. array 변수는 실제로 그 요소들을 저장하는 배열을 의미한다. 생성자는 10개의 요소를 갖는 빈 배열을 생성, size 변수는 0으로 설정한다. ","date":"2022-02-26","objectID":"/think-data-structures-1/:2:0","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"add 메서드 살펴보기 ","date":"2022-02-26","objectID":"/think-data-structures-1/:3:0","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"boolean add(E e) @Override public boolean add(T element) { if(size \u003e= array.length) { T[] temp = (T[]) new Object[array.length * 2]; System.arraycopy(array, 0, temp, 0, array.length); array = temp; } array[size] = element; size++; return true; } 배열에 여분의 공간이 없으면 더 큰 배열을 만들어 복사 한다. 리스트 마지막에 요소를 추가한다. 리스트의 사이즈를 증가한다. ","date":"2022-02-26","objectID":"/think-data-structures-1/:3:1","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"get 메서드 살펴보기 @Override public T get(int index) { if (index \u003c 0 || index \u003e= size) { throw new IndexOutOfBoundsException(); } return array[index]; } 인덱스가 범위를 벗어나면 IndexOutOfBoundsException 예외를 던진다. 배열의 인덱스 요소를 읽고 반환한다. ","date":"2022-02-26","objectID":"/think-data-structures-1/:4:0","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"set 메서드 구현하기 ","date":"2022-02-26","objectID":"/think-data-structures-1/:5:0","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"E set(int index, E element) 이 목록에 지정된 위치에 있는 요소를 입력받은 요소로 변경한다. 인덱스를 검사하는 코드의 반복은 피한다. Parameter index - 교체 할 요소의 인덱스 element - 특정한 위치에 저장할 요소 @Override public T set(int index, T element) { T prev = get(index); array[index] = element; return prev; } get(index) 메서드를 사용하여 인덱스의 범위를 검사하는 코드의 중복을 피한다. 입력받은 요소를 array 입력받은 위치에 대입한다. 이전 요소를 리턴한다. ","date":"2022-02-26","objectID":"/think-data-structures-1/:5:1","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"indexOf 구현하기 ","date":"2022-02-26","objectID":"/think-data-structures-1/:6:0","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"int indexOf(Object o) 이 목록에서 지정된 요소가 처음 나타나는 인덱스를 반환한다. 요소가 없으면 -1을 반환 (o==null ? get(i)==null : o.equals(get(i))) Parameter o - 검색할 요소 Return 이 목록에서 지정된 요소가 처음 나타나는 인덱스 private boolean equals(Object target, Object element) { if (target == null) { return element == null; } else { return target.equals(element); } } @Override public int indexOf(Object target) { for(int i = 0; i \u003c size; i++) { if(equals(target, array[i])) { return i; } } return -1; } 책에서는 배열의 요소를 대상 값과 비교하여 같으면 true를 반환하는 equals 헬퍼 메서드를 제공. (null 처리 포함) 리스트의 사이즈만큼 순회하면서 입력받은 요소와 같은 요소가 있는지 확인한다. 없는 경우 -1 ","date":"2022-02-26","objectID":"/think-data-structures-1/:6:1","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"특정 위치에 add 하는 메서드 구현 ","date":"2022-02-26","objectID":"/think-data-structures-1/:7:0","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"void add(int index, E element) 요소를 리스트의 지정한 위치에 삽입. 삽입 된 위치에 있는 다음 요소들을 모두 오른쪽으로 이동. 배열을 더 크게 늘리는 코드는 반복하지 않는다. (?? 이건 다시 봐야겠다…) @Override public void add(int index, T element) { if (index \u003c 0 || index \u003e size) { throw new IndexOutOfBoundsException(); } // add the element to get the resizing add(element); // shift the elements for (int i=size-1; i\u003eindex; i--) { array[i] = array[i-1]; } // put the new one in the right place array[index] = element; } ","date":"2022-02-26","objectID":"/think-data-structures-1/:7:1","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"remove 메서드 구현 ","date":"2022-02-26","objectID":"/think-data-structures-1/:8:0","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["Think Data Structures"],"content":"E remove(int index) 지정한 위치에 존재하는 요소를 삭제한다. 삭제된 위치 다음 요소드를 모두 왼쪽으로 이동시킨다. @Override public T remove(int index) { T prev = get(index); for(int i = index + 1; i \u003c size; i++) { array[i - 1] = array[i]; } size--; return prev; } get(index) 메서드를 통해 인덱스에 위치한 요소를 삭제할 요소를 가져온다. 삭제하는 인덱스 다음 요소를 왼쪽으로 이동한다. 리스트의 size를 감소시킨다. 이전 요소를 리턴한다. ","date":"2022-02-26","objectID":"/think-data-structures-1/:8:1","tags":["Data Structures","Java"],"title":"[Think Data Structures] 자바 배열 리스트 구현하기","uri":"/think-data-structures-1/"},{"categories":["CI/CD"],"content":" 사내 개발 협업을 위한 CI/CD 서버를 구축한다. AWS EC2 인스턴스를 사용중이다. (Ubuntu LTS) docker, docker-compose가 설치되어 있다. GitLab의 경우 추후 라이센스 구매를 위해 ce가 아닌 ee 버전으로 설치한다. ","date":"2022-02-14","objectID":"/install-jenkins-gitlab/:0:0","tags":["CI","CD","devops","Docker Compose","Jenkins","GitLab"],"title":"[CI/CD 서버 구축하기] 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/install-jenkins-gitlab/"},{"categories":["CI/CD"],"content":"설치를 위한 Docker Compose 설정 아래는 GitLab, Jenkins를 컨테이너를 띄우기 위한 docker-compose 설정이다. GitLab 이미지는 단일 컨테이너에서 서비스를 실행하기위한 Monolithic 이미지이며 최소 시스템 요구사항은 아래와 같다. GitLab installation minimum requirements ","date":"2022-02-14","objectID":"/install-jenkins-gitlab/:1:0","tags":["CI","CD","devops","Docker Compose","Jenkins","GitLab"],"title":"[CI/CD 서버 구축하기] 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/install-jenkins-gitlab/"},{"categories":["CI/CD"],"content":"docker-compose.yml 파일 준비 작업 디렉터리를 생성한다. cd ~/ mkdir devops cd devops docker-compose.yml 파일을 생성한다 touch docker-compose.yml vi docker-compose.yml docker-compose.yml에 아래 내용을 추가한다. version: '3.0' services: gitlab: container_name: gitlab image: gitlab/gitlab-ee:latest restart: always hostname: \"내IP:8289\" environment: TZ: 'Asia/Seoul' GITLAB_OMNIBUS_CONFIG: | external_url 'http://내IP:8289' nginx['redirect_http_to_https'] = false nginx['listen_https'] = false nginx['listen_port'] = 8289 gitlab_rails['gitlab_shell_ssh_port'] = 2202 ports: - \"2202:22\" - \"8289:8289\" volumes: - \"/home/ubuntu/devops/gitlab/config:/etc/gitlab\" - \"/home/ubuntu/devops/gitlab/logs:/var/log/gitlab\" - \"/home/ubuntu/devops/gitlab/data:/var/opt/gitlab\" networks: - votenet jenkins: container_name: jenkins user: root image: jenkins/jenkins:lts restart: always ports: - \"9080:8080\" environment: - GRADLE_HOME=/home/ubuntu/devops/jenkins/libs/gradle volumes: - \"/home/ubuntu/devops/jenkins/jenkins_home:/var/jenkins_home\" - \"/home/ubuntu/devops/jenkins/script:/app/jenkins/script\" - \"/home/ubuntu/devops/jenkins/source:/app/jenkins/source\" - \"/home/ubuntu/devops/jenkins/ssh_key:/app/jenkins/ssh_key\" - \"/home/ubuntu/devops/jenkins/libs:/app/jenkins/libs\" - \"/var/run/docker.sock:/var/run/docker.sock\" networks: - votenet networks: votenet: ","date":"2022-02-14","objectID":"/install-jenkins-gitlab/:1:1","tags":["CI","CD","devops","Docker Compose","Jenkins","GitLab"],"title":"[CI/CD 서버 구축하기] 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/install-jenkins-gitlab/"},{"categories":["CI/CD"],"content":"Docker Compose를 사용하여 구동 docker-compose.yml을 생성한 디렉터리에서 해당 명령어를 실행한다. $ sudo docker-compose up -d 아래 명령어로 구동한 도커 컨테이너를 확인할 수 있다. $ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 72dd26a6e3c4 jenkins/jenkins:lts \"/sbin/tini -- /usr/…\" 15 seconds ago Up 12 seconds 50000/tcp, 0.0.0.0:9080-\u003e8080/tcp, :::9080-\u003e8080/tcp jenkins 99e8736406b5 gitlab/gitlab-ee:latest \"/assets/wrapper\" 15 seconds ago Up 11 seconds (health: starting) 80/tcp, 443/tcp, 0.0.0.0:8289-\u003e9980/tcp, :::8289-\u003e9980/tcp, 0.0.0.0:2202-\u003e22/tcp, :::2202-\u003e22/tcp gitlab ","date":"2022-02-14","objectID":"/install-jenkins-gitlab/:2:0","tags":["CI","CD","devops","Docker Compose","Jenkins","GitLab"],"title":"[CI/CD 서버 구축하기] 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/install-jenkins-gitlab/"},{"categories":["CI/CD"],"content":"설치 확인 설치한 GitLab이 정상 동작하는지 Web으로 접속하여 확인한다. DNS 설정은 안했기 때문에 IP로 접속하게 끔 설정했다. 클라우드 서버를 사용하여 구동하기 때문에 외부에서 내가 지정한 포트로 접속이 가능하게 오픈하였다. ","date":"2022-02-14","objectID":"/install-jenkins-gitlab/:3:0","tags":["CI","CD","devops","Docker Compose","Jenkins","GitLab"],"title":"[CI/CD 서버 구축하기] 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/install-jenkins-gitlab/"},{"categories":["CI/CD"],"content":"GitLab 설치 확인 external_url로 설정한 URL로 접속한다. 처음 접속이라면 관리자 계정의 패스워드를 변경할 수 있는 화면이 뜬다. ","date":"2022-02-14","objectID":"/install-jenkins-gitlab/:3:1","tags":["CI","CD","devops","Docker Compose","Jenkins","GitLab"],"title":"[CI/CD 서버 구축하기] 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/install-jenkins-gitlab/"},{"categories":["CI/CD"],"content":"Jenkins 설치 확인 Jenkins 설치 후 처음 접속하게되면 Jenkins를 잠금 해제하는 화면이 뜨게 된다. 아래 명령어를 통해 초기 패스워드를 설정할 수 있다. 그 이후 프로세스를 쭉 따라 Jenkins 관리자 계정을 설정한다. $ sudo docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword ","date":"2022-02-14","objectID":"/install-jenkins-gitlab/:3:2","tags":["CI","CD","devops","Docker Compose","Jenkins","GitLab"],"title":"[CI/CD 서버 구축하기] 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/install-jenkins-gitlab/"},{"categories":["CI/CD"],"content":"참고 Jenkins vs GitLab CI: Battle of CI/CD Tools ","date":"2022-02-14","objectID":"/install-jenkins-gitlab/:4:0","tags":["CI","CD","devops","Docker Compose","Jenkins","GitLab"],"title":"[CI/CD 서버 구축하기] 2. docker-compose를 사용하여 Jenkins, GitLab 설치","uri":"/install-jenkins-gitlab/"},{"categories":["CI/CD"],"content":"요약 CI/CD는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법이다. 아래 세 가지 단계로 구분 할 수 있다. 지속적인 통합 Continuous Integration 지속적인 서비스 제공 Continuous Delivery 지속적인 배포 Continuous Deployment [출처] https://www.redhat.com/ko/topics/devops/what-is-ci-cd 💡 “CD\"는 지속적인 서비스 제공(Continuous Delivery) 및/또는 지속적인 배포(Continuous Deployment)를 의미하며 이 두 용어는 상호 교환적으로 사용할 수 있다. ","date":"2022-02-10","objectID":"/ci-cd/:1:0","tags":["CI","CD","devops"],"title":"[CI/CD 서버 구축하기] 1. 개념","uri":"/ci-cd/"},{"categories":["CI/CD"],"content":"개념 ","date":"2022-02-10","objectID":"/ci-cd/:2:0","tags":["CI","CD","devops"],"title":"[CI/CD 서버 구축하기] 1. 개념","uri":"/ci-cd/"},{"categories":["CI/CD"],"content":"CI 다수의 개발자가 작성 및 수정한 코드가 지속적으로 통합/테스트(Continuous Integration) 되는 것을 의미한다. CI 작업 순서는 도구, 프로그래밍 언어, 프로젝트 등 기타 여러 요인에 따라 많이 다르지만 일반적으로는 다음과 같다. 코드를 레포지토리로 푸시한다. 정적 분석 배포 전 테스트 테스트 환경에 패키징 및 배포 배포 후 테스트 [출처] www.pepgotesting.com ","date":"2022-02-10","objectID":"/ci-cd/:2:1","tags":["CI","CD","devops"],"title":"[CI/CD 서버 구축하기] 1. 개념","uri":"/ci-cd/"},{"categories":["CI/CD"],"content":"CD CD는 지속적 제공 Continuous Delivery과 지속적 배포 Continuous Deployment를 두 가지를 모두 의미한다. 지속적 제공 Continuous Delivery : CI 수행 후 프로세스에 유효한 코드를 레포지토리에 올리는 것을 자동화 한다. 프로덕션 레벨로 배포가 가능한 상태까지 준비해되는 것이 목표. (코드의 변경 사항 병합, 테스트 자동화, 코드 릴리스 자동화 포함) 지속적 배포 Continuous Deployment : CI/CD 마지막 단계. 프로덕션 준비가 완료된 빌드를 코드 리포지토리에 자동으로 릴리즈 한다. ","date":"2022-02-10","objectID":"/ci-cd/:2:2","tags":["CI","CD","devops"],"title":"[CI/CD 서버 구축하기] 1. 개념","uri":"/ci-cd/"},{"categories":["CI/CD"],"content":"CI/CD 도구들 CI/CD를 위한 도구들은 굉장히 많다. 본인 팀에 맞는 형태의 도구를 고르면 된다. 🐹 나는 계속 스타트업에서 일했기 때문에 무료로 구성할 수 있는 Jenkins 와 GitLab을 가장 많이 사용했다. docker를 통해 쉽게 구성이 가능하다. Bamboo의 경우 Jira의 이슈 시스템과 연동하여 사용할 수 있어 프로젝트 관리 측면에서 매우 유용하다. (대신 프로젝트 인원이 많은 경우 가격이 사악…) GitHub Action/Travis CI 는 따로 CI 서버를 구성하지 않아도 되기 때문에 내 블로그는 GitHub Action을 통해 빌드 및 배포하고 있다. [출처] https://www.katalon.com/resources-center/blog/ci-cd-tools/ ","date":"2022-02-10","objectID":"/ci-cd/:3:0","tags":["CI","CD","devops"],"title":"[CI/CD 서버 구축하기] 1. 개념","uri":"/ci-cd/"},{"categories":["CI/CD"],"content":"참고링크 RedHat 토픽 - CI/CD(지속적 통합/지속적 제공): 개념, 방법, 장점, 구현 과정 Continuous Integration: A “Typical” Process ","date":"2022-02-10","objectID":"/ci-cd/:4:0","tags":["CI","CD","devops"],"title":"[CI/CD 서버 구축하기] 1. 개념","uri":"/ci-cd/"},{"categories":["Etc"],"content":"Web worker Web Worker 는 메인 스레드와 분리된 별도의 백그라운드 스레드에서 스크립트를 실행할 수 있는 기술이다. UI 스레드와는 별개의 스레드를 실행시켜 사용자 인터페이스를 방해하지않고 작업을 수행할 수 있다. ","date":"2022-01-16","objectID":"/webworker/:0:0","tags":["Web Worker","Web"],"title":"Web Worker API","uri":"/webworker/"},{"categories":["Etc"],"content":"Web worker scope Web worker는 메인 스레드와 별도의 worker 스레드를 갖는다. 메인 스레드에서 window 객체는 GlobalScope 이지만 worker 스레드에서는 별도의 스코프 범위를 갖는다. Worker 종류에 따른 Scope worker 스레드는 메인 스레드 window 객체에 액세스할 수 있는 권한이 없기 때문에 window의 메서드나 DOM을 직접적으로 제어할 수 없다. window 의 DOM에 접근하기 위해서는 postMessage() 메서드를 이용하여 메세지를 보내고 onmessage 이벤트 핸들러를 통해 제어할 수 있다. ","date":"2022-01-16","objectID":"/webworker/:1:0","tags":["Web Worker","Web"],"title":"Web Worker API","uri":"/webworker/"},{"categories":["Etc"],"content":"Worker 종류 Dedicated workers : 단일 스크립트 환경을 이용하는 worker. 처음 worker를 생성한 context 영역에서만 사용이 가능하다. Shared workers : worker가 같은 도메인 내에 존재하는 모든 Thread에서 사용이 가능하다. 다른 컨텍스트 (iframe, 다른 탭 등)에서도 접근이 가능하다. script에서 worker와 port 를 통해서 통신한다. Service workers : 브라우저가 백그라운드 영역에서 실행하는 스크립트로 Service worker의 생명주기는 웹페이지와는 별개로 작동한다. 웹페이지 또는 사용자 인터랙션이 필요하지 않는 기능을 제공하고 있다. 오프라인 환경, 푸시 알림, 백그라운드 동기화 등의 기능을 지원한다. ","date":"2022-01-16","objectID":"/webworker/:2:0","tags":["Web Worker","Web"],"title":"Web Worker API","uri":"/webworker/"},{"categories":["Etc"],"content":"Service Worker Web worker의 한 종류이다. 웹 페이지의 라이프 사이클과는 별개로 동작하기 때문에 웹페이지가 닫혀도 자동으로 비활성화 되지 않는다. 웹 애플리케이션, 브라우저 및 네트워크 사이에 proxy 서버 역할을 한다. 주로 오프라인, 푸시 알림 및 백그라운드 동기화 API를 위해 사용한다. 보안상의 이유로 localhost 이외에는 HTTPS 통신을 해야한다. multi-threading 의 기능을 사용하기 위해 설계된 것이 아니므로 몇가지 기능들이 제한되어 있다. EventSource 나WebSocket 기능도 제한되어 있다. ","date":"2022-01-16","objectID":"/webworker/:3:0","tags":["Web Worker","Web"],"title":"Web Worker API","uri":"/webworker/"},{"categories":["Javascript"],"content":" 회사에서 Javascript 용 서비스 SDK를 개발하면서 설정했던 webpack5 설정파일을 기록한다. 오래전에 잠깐 접해보았던게 webpack2 버전이었는데 어느새 5까지 나왔다. 알고 사용하는게 아니다보니 쓰면서 애를 먹었다…🥺🥺🥺 Webpack5 설정하기 (ESM 사용) 회사에서 개발한 SDK는 CJS(CommonJS)에서 ESM(ECMAScript Module) 모듈 방식을 사용하여 개발했다. ESM 모듈 로더 사용하기 위해 package.json에 아래 설정을 추가했다. package.json \"type\": \"module\" 아래 글에서는 CJS가 기본값이기 때문에 라이브러리의 경우 CJS로 개발하는 것을 추천하고 있다. Node Modules at War: Why CommonJS and ES Modules Can’t Get Along ","date":"2022-01-16","objectID":"/webpack/:0:0","tags":["Javascript","Webpack5","ESM","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/webpack/"},{"categories":["Javascript"],"content":"설치 라이브러리 npm install --save-dev webpack webpack-cli webpack-merge webpack-stream webpack-merge 웹팩 설정을 하나로 병합해주는 라이브러리. 웹팩 설정을 개발용과 배포용으로 나누기 위해 적용했다. webpack-stream 태스크 러너는 gulp를 사용하고 있다. gulp에서 웹팩을 모듈링작업을 추가 하기 위해 설치했다. ","date":"2022-01-16","objectID":"/webpack/:1:0","tags":["Javascript","Webpack5","ESM","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/webpack/"},{"categories":["Javascript"],"content":"webpack.config.js import webpack from \"webpack\"; const webpack5esmInteropRule = { test: /\\.m?js/, resolve: { fullySpecified: false } } const config = { target: ['web', 'es5'], entry: { main: \"./entries-webpack.js\", }, output: { filename: \"tychain.min.js\" }, resolve: { modules: ['node_modules'], fallback: { assert: false, buffer: await Promise.resolve('buffer'), console: false, constants: false, crypto: await Promise.resolve('crypto-browserify'), domain: false, events: false, fs: false, http: false, https: false, os: false, path: false, punycode: false, process: false, querystring: false, stream: await Promise.resolve('stream-browserify'), string_decoder: false, sys: false, timers: false, tty: false, url: false, util: false, vm: false, zlib: false, } }, module: { rules: [ webpack5esmInteropRule, { test: /\\.js$/, exclude: /node_modules/, use: { loader: \"babel-loader\", options: { presets: [\"@babel/preset-env\"], plugins: [\"@babel/plugin-proposal-class-properties\"] } } }, ] }, plugins: [ new webpack.ProvidePlugin({ Buffer: ['buffer', 'Buffer'], ndcrypto: ['crypto', 'ndcrypto'], }), ], optimization: { concatenateModules: true } } export default config; ","date":"2022-01-16","objectID":"/webpack/:2:0","tags":["Javascript","Webpack5","ESM","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/webpack/"},{"categories":["Javascript"],"content":"target 웹팩은 여러 환경과 타켓으로 컴파일 할 수 있다. Targets|webpack ","date":"2022-01-16","objectID":"/webpack/:2:1","tags":["Javascript","Webpack5","ESM","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/webpack/"},{"categories":["Javascript"],"content":"entry entry는 애플리케이션을 번들리할 때 프로세스를 시작할 지점이다. Entry and Context|webpack ","date":"2022-01-16","objectID":"/webpack/:2:2","tags":["Javascript","Webpack5","ESM","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/webpack/"},{"categories":["Javascript"],"content":"output output은 컴파일 된 번들파일과 리소스를 어느 경로에 어떤 이름으로 생성할지 지정할 수 있다. entry는 여러 지점이 있을 수 있지만 output은 하나의 구성만 지정할 수 있다. Output|webpack ","date":"2022-01-16","objectID":"/webpack/:2:3","tags":["Javascript","Webpack5","ESM","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/webpack/"},{"categories":["Javascript"],"content":"resolve resolve 옵션은 모듈을 해석하는 방식을 지정할 수 있다. resolve.modules 모듈을 해석할 때 검색할 디렉터리를 웹팩에 알려준다. 상대경로는 node가 현재 디렉터리와 상위 디렉터리를 통해 node_modeuls를 검색하는 방법과 유사하게 검색되며, 절대경로는 오직 주어진 디렉터리에서만 검색한다. webpack.config.js module.exports = { //... resolve: { modules: ['node_modules'], }, }; webpack.config.js const path = require('path'); module.exports = { //... resolve: { modules: [path.resolve(__dirname, 'src'), 'node_modules'], }, }; resolve.fallback webpack5에서는 Node.js 코어 모듈에 대해 자동 polyfill을 제공하지 않는다. 그러므로 브라우저에서 실행되는 코드에서 사용하는 경우 npm 모듈을 직접 설치하고 포함해야 한다. 다음은 webpack 5 이전에 webpack이 사용한 polyfill 목록이다. 회사에서는 모든 설정파일도 ESM 방식으로 webpack.conf.js 파일 또한 ESM으로 작성되었다. ESM의 경우 아래와 같이 설정한다. crypto: await Promise.resolve('crypto-browserify'), resolve: { fallback: { assert: require.resolve('assert'), buffer: require.resolve('buffer'), console: require.resolve('console-browserify'), constants: require.resolve('constants-browserify'), crypto: require.resolve('crypto-browserify'), domain: require.resolve('domain-browser'), events: require.resolve('events'), http: require.resolve('stream-http'), https: require.resolve('https-browserify'), os: require.resolve('os-browserify/browser'), path: require.resolve('path-browserify'), punycode: require.resolve('punycode'), process: require.resolve('process/browser'), querystring: require.resolve('querystring-es3'), stream: require.resolve('stream-browserify'), string_decoder: require.resolve('string_decoder'), sys: require.resolve('util'), timers: require.resolve('timers-browserify'), tty: require.resolve('tty-browserify'), url: require.resolve('url'), util: require.resolve('util'), vm: require.resolve('vm-browserify'), zlib: require.resolve('browserify-zlib'), }, }, ","date":"2022-01-16","objectID":"/webpack/:2:4","tags":["Javascript","Webpack5","ESM","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/webpack/"},{"categories":["Javascript"],"content":"To Do CJS, ESM ","date":"2022-01-16","objectID":"/webpack/:3:0","tags":["Javascript","Webpack5","ESM","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/webpack/"},{"categories":["Javascript"],"content":"Reference ","date":"2022-01-16","objectID":"/webpack/:4:0","tags":["Javascript","Webpack5","ESM","cjs"],"title":"Webpack5 설정하기 (ESM)","uri":"/webpack/"},{"categories":["Tucker의 Go 프로그래밍"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 정리하였습니다. ","date":"2021-08-23","objectID":"/chapter20-interface/:0:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"1. 인터페이스 정의 ","date":"2021-08-23","objectID":"/chapter20-interface/:1:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"인터페이스 선언 인터페이스 선언은 type을 쓴 뒤 인터페이스 명을 쓰고 interface 키워드를 쓴다. 그런 뒤 {} 블록 안에 인터페이스에 포함된 메서드 집합을 써준다. type DuckInterface interface { Fly() Walk(distance int) int } 유의사항 메서드는 반드시 메서드명이 있어야한다. 매개변수와 반환이 다르더라도 이름이 같은 메서드는 있을 수 없다. 인터페이스에서는 메서드 구현을 포함하지 않는다. 인터페이스 선언 예제 package main import \"fmt\" type Stringer interface { String() string } type Student struct { Name string Age int } func (s Student) String() string { return fmt.Sprintf(\"안녕! 나는 %d살 %s라고 해.\", s.Age, s.Name) } func main() { student := Student{\"쳘수\", 5} var stringer Stringer stringer = student fmt.Printf(\"%s\\n\", stringer.String()) } ","date":"2021-08-23","objectID":"/chapter20-interface/:1:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"2. 인터페이스를 사용하는 이유 인터페이스는 객체 지향 프로그래밍에서 아주 중요한 역할을 한다. 인터페이스를 이용하면 구체화된 객체가 아닌 인터페이스만 가지고 메서드를 호출할 수 있기 때문에 큰 코드 수정 없이 필요에 따라 구체화 된 객체로 바꿔 사용할 수 있다. ","date":"2021-08-23","objectID":"/chapter20-interface/:2:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"추상화 계층 추상화(abstraction) : 내부 동작을 감춰서 서비스를 제공하는 쪽과 사용하는 쪽 모두에게 자유를 주는 방식. 인터페이스는 추상화를 제공하는 추상화 계층(abstraction layer) 이다. 인터페이스를 사용하여 서로 결합하고 의존성을 줄이는 것을 디커플링(decoupling) 이라고 한다. 구체화된 타입으로 상호작용하는게 아니라 추상화된 관계로 상호작용함으로써 결합도를 낮추고 의존관계를 줄이므로써 이후 유지 보수를 용이하 하고 유연성을 확보할 수 있다. ","date":"2021-08-23","objectID":"/chapter20-interface/:2:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"3. 덕 타이핑 Go 언어에서는 어떤 타입이 인터페이스를 포함하고 있는지 여부를 결정할 때 덕 타이핑(duck typing) 방식을 사용한다. 덕 타이핑 방식은 타입 선언 시 인터페이스 구현 여부를 명시적으로 나타낼 필요 없이 인터페이스에 정의한 메서드 포함 여부로만 결정하는 방식이다. Stringer 인터페이스를 정의 type Stringer interface { String() string } Stringer 인터페이스 포함 여부를 명시적으로 나타내지 않아도 String() 메서드를 포함하는 것 만으로 Stringer 인터페이스를 사용할 수 있다. type Student struct { ... } func (s *Student) String() string { ... } 만약 Go 언어가 덕 타이핑을 지원하지 않았더라면, implements 와 같은 키워드를 써서 명시적으로 Stringer 구현 여부를 표시해야 했을 것이다. type Student struct implements Stringer { ... } ","date":"2021-08-23","objectID":"/chapter20-interface/:3:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"덕 타이핑의 장점 서비스 사용자 중심의 코딩을 할 수 있다. 덕 타이핑은 인터페이스 구현 여부를 타입 선언에서 하는게 아니라 사용될 때 해당 타입이 인터페이스에 정의된 메서드를 포함했는지 여부로 결정한다. 따라서 서비스 제공자가 인터페이스를 정의 할 필요 없이 구체화된 객체만 제공하고 서비스 이용자가 필요에 따라 그때그때 인터페이스를 정의해서 사용할 수 있다. ","date":"2021-08-23","objectID":"/chapter20-interface/:3:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"4. 인터페이스 기능 더 알기 포함된 인터페이스 빈 인터페이스 인터페이스 기본값 ","date":"2021-08-23","objectID":"/chapter20-interface/:4:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"인터페이스를 포함하는 인터페이스 구조체에서 다른 구조체를 포함된 필드로 가질 수 있듯이 인터페이스도 다른 인터페이스를 포함할 수 있다. 이를 포함된 인터페이스라고 부른다. // 1) Read()와 Close() 메서드를 포함한 Reader 인터페이스 type Reader interface { Read() (n int, err error) Close() error } // 2) Write() 메서드와 Close() 메서드를 포함한 Writer 인터페이스 type Writer interface { Write() (n int, err error) Close() error } // 3) Reader, Writer 인터페이스의 메서드 집합을 모두 포함한 ReadWriter 인터페이스 type ReadWriter interface { Reader // Reader의 메서드 집합을 포함 Writer // Writer의 메서드 집합을 포함 } ","date":"2021-08-23","objectID":"/chapter20-interface/:4:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"빈 인터페이스 interface{}는 메서드를 가지고 있지 않은 빈 인터페이이다. 가지고 있어야 할 메서드가 하나도 없기 때문에 모든 타입이 빈 인터페이스로 쓰일 수 있다. 빈 인터페이스는 어떤 값이든 받을 수 있는 함수, 메서드, 변수값을 만들 때 사용한다. package main import \"fmt\" func PrintVal(v interface{}) { switch t := v.(type) { case int: fmt.Printf(\"v is int %d\\n\", int(t)) case float64: fmt.Printf(\"v is float64 %f\\n\", t) case string: fmt.Printf(\"v is string %s\\n\", string(t)) default: fmt.Printf(\"Not supported Type : %T: %v\", t, t) } } type Student struct { Age int } func main() { PrintVal(10) PrintVal(3.14) PrintVal(\"Hello\") PrintVal(Student{15}) } ","date":"2021-08-23","objectID":"/chapter20-interface/:4:2","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"인터페이스 기본값 nil 인터페이스 변수의 기본값은 nil이다. package main type Attacker interface { Attack() } func main() { var att Attacker att.Attack() // Error! att의 초기값이 없기 때문에 기본값인 nil } invalid memory address로 비정상적인 메모리 주소에 접근해서 프로그램 실행중에 런타임 에러가(runtime error) 발생한다. ","date":"2021-08-23","objectID":"/chapter20-interface/:4:3","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 20. 인터페이스","uri":"/chapter20-interface/"},{"categories":["Tucker의 Go 프로그래밍"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 정리하였습니다. ","date":"2021-08-20","objectID":"/chapter15-string/:0:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 15. 문자열","uri":"/chapter15-string/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"string 구조 string 타입은 Go 언어에서 제공하는 내장 타입으로 그 내부구현은 감추어져 있다. 하지만 reflect 패키지 안의 StringHeader 구조체를 통해 내부구조를 엿볼 수 있다. // StringHeader is the runtime representation of a string. // It cannot be used safely or portably and its representation may // change in a later release. // Moreover, the Data field is not sufficient to guarantee the data // it references will not be garbage collected, so programs must keep // a separate, correctly typed pointer to the underlying data. type StringHeader struct { Data uintptr Len int } string은 필드가 2개인 구조체이다. Data 필드는 unitptr 타입으로 문자열 데이터가 있는 메모리 주소를 나타내는 일종의 포인터이다. Len 필드는 문자열의 길이를 나타낸다. ","date":"2021-08-20","objectID":"/chapter15-string/:1:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 15. 문자열","uri":"/chapter15-string/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"string 끼리 대입하기 package main import ( \"fmt\" \"reflect\" \"unsafe\" ) func main() { str1 := \"Hello World!\" str2 := str1 stringHeader1 := (*reflect.StringHeader)(unsafe.Pointer(\u0026str1)) stringHeader2 := (*reflect.StringHeader)(unsafe.Pointer(\u0026str2)) fmt.Println(stringHeader1) fmt.Println(stringHeader2) } Result \u0026{17598669 12} \u0026{17598669 12} str1과 str2의 주소값은 동일하다. str1 변수값을 str2로 복사했을때 str1의 값이 str2로 복사되어 같은 메모리 데이터를 가르키게 된다. ","date":"2021-08-20","objectID":"/chapter15-string/:2:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 15. 문자열","uri":"/chapter15-string/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"문자열은 불변이다 문자열은 불변(immutable)이다. string 타입이 가리키는 문자열의 일부만 변경할 수 없다. var str string = \"Hello World\" str = \"How are you?\" str[2] = 'a' // Error! “How are you?” 문자열이 담긴 메모리주소로 str의 Data 포인터 값이 변경된다. Len 값 또한 문자열 길이에 맞게 변경된다. 문자열은 불변이라는 특성을 갖기 때문에 문자열 일부는 변경이 불가능하다. ","date":"2021-08-20","objectID":"/chapter15-string/:3:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 15. 문자열","uri":"/chapter15-string/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"문자열 합산 Go 언어에서 string 타입 간 합 연산을 지원한다. 합 연산을 하면 두 문자열이 하나로 합쳐진다. package main import ( \"fmt\" \"reflect\" \"unsafe\" ) func main() { var str string = \"Hello\" stringHeader := (*reflect.StringHeader)(unsafe.Pointer(\u0026str)) addr1 := stringHeader.Data str += \" World\" addr2 := stringHeader.Data str += \" Welcome!\" addr3 := stringHeader.Data fmt.Println(str) fmt.Printf(\"addr1:\\t%x\\n\", addr1) fmt.Printf(\"addr2:\\t%x\\n\", addr2) fmt.Printf(\"addr3:\\t%x\\n\", addr3) } Result Hello World Welcome! addr1: 10c9543 addr2: c000118000 addr3: c00011a000 모든 주소값이 다 다르게 출력되었다. Go 언어는 기존 문자열 메모리를 건드리지 않고, 새로운 메모리 공간을 만들어 두 문자열을 합치기 때문에 string 합 연산 이후 주소값이 변경된다. string의 합 연산을 빈번하게 사용하면 메모리가 낭비되므로 strings 패키지의 Builder를 이용하는 것이 좋다. ","date":"2021-08-20","objectID":"/chapter15-string/:4:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 15. 문자열","uri":"/chapter15-string/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"strings 패키지의 Builder를 이용한 문자열 합 연산 package main import ( \"fmt\" \"strings\" ) func ToUpper1(str string) string { var rst string for _, c := range str { if c \u003e= 'a' \u0026\u0026 c \u003c= 'z' { rst += string('A' + (c - 'a')) } else { rst += string(c) } } return rst } func ToUpper2(str string) string { var builder strings.Builder for _, c := range str { if c \u003e= 'a' \u0026\u0026 c \u003c= 'z' { builder.WriteRune('A' + (c - 'a')) } else { builder.WriteRune(c) } } return builder.String() } func main() { var str string = \"Hello World\" fmt.Println(ToUpper1(str)) fmt.Println(ToUpper2(str)) } ","date":"2021-08-20","objectID":"/chapter15-string/:4:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 15. 문자열","uri":"/chapter15-string/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"왜 문자열은 불변 원칙을 지키려 할까? 빈번한 합 연산시 메모리가 낭비되는 데도 문자열 불변 원칙을 지키려할까? 가장 큰 이유는 예기치 못한 버그를 방지하기 위해서다. string 타입이 복사 될때 문자열 데이터가 복사되는 것이 아니라 Data(주소값), Len 필드값만 복사된다. 만약 문자열 불변 원칙이 없어서 문자열 값이 일부가 변경된다면 참조하고 있는 다른 곳에서 모두 변경된 문자열을 가리키게 되버린다. string 변수값이 코드 전반에 걸쳐 여러 곳으로 복사되었다면 언제 어디서 문자열이 변경되었는지 알 수없다. ","date":"2021-08-20","objectID":"/chapter15-string/:5:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 15. 문자열","uri":"/chapter15-string/"},{"categories":["Tucker의 Go 프로그래밍"],"content":" 음.. 완벽하게 이해하지는 못했다 😇😇😇 ","date":"2021-08-19","objectID":"/go-escape-analysis/:0:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] Go 스택 메모리와 힙 메모리","uri":"/go-escape-analysis/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"스택 메모리와 힙 메모리 대부분의 프로그래밍 언어는 메모리를 할당할 때 스택 메모리 영역 또는 힙 메모리 영역을 사용한다. 함수 내부에서만 사용되는 값은 스택 메모리에 할당된다. 함수 외부로 공개되는 메모리 공간은 힙 메모리 영역에 할당된다. C/C++ 언어에서는 malloc() 함수를 직접 호출해서 힙 메모리 공간을 할당한다. 자바의 경우 클래스 타입을 힙에, 기본 타입을 스택에 할당한다. Go 언어는 이스케이프 분석(escape analysis) 을 해서 어느 메모리에 할당할지 결정한다. ","date":"2021-08-19","objectID":"/go-escape-analysis/:1:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] Go 스택 메모리와 힙 메모리","uri":"/go-escape-analysis/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"이스케이프 분석(escape analysis) GC 컴파일러는 함수와 패키지를 넘어 전역적으로 탈출 검사를 수행한다. 빌드 시 아래 옵션을 사용하면 이스케이프 분석 정보를 확인할 수 있다. go build -gcflags=\"-m\" package main import \"fmt\" type User struct { Name string Age int } func stayOnStack() User { u := User{ Name : \"chunsik\", Age : 5, } return u } func escapeToHeap() *User { u := User{ Name : \"chunsik\", Age : 5, } // 탈출 분석으로 u 메모리가 사라지지 않음. return \u0026u } func main() { fmt.Println(stayOnStack()) fmt.Println(escapeToHeap()) } stayOnStack()의 변수 u는 객체의 사본이 리턴되었다. 컴파일 할 때 구조체 u의 크기를 알 수 있기에 컴파일러는 u를 스택에 저장한다. escapeToHeap()는 값을 리턴하는 것이 아니라 값의 포인터(주소)를 리턴한다. u변수의 인스턴스가 함수 외부로 공개되는 것을 분석해내에 u를 스택 메모리가 아닌 힙 메모리에 할당한다. ","date":"2021-08-19","objectID":"/go-escape-analysis/:1:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] Go 스택 메모리와 힙 메모리","uri":"/go-escape-analysis/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"참고 Tucker의 Go 언어 프로그래밍 The Ultimate Go Study Guide ","date":"2021-08-19","objectID":"/go-escape-analysis/:2:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] Go 스택 메모리와 힙 메모리","uri":"/go-escape-analysis/"},{"categories":["Tucker의 Go 프로그래밍"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 정리하였습니다. ","date":"2021-08-19","objectID":"/go-constant-literal/:0:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] Go 상수와 리터럴","uri":"/go-constant-literal/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"상수와 리터럴 ","date":"2021-08-19","objectID":"/go-constant-literal/:1:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] Go 상수와 리터럴","uri":"/go-constant-literal/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"상수 (Constant) 상수는 변하지 않는 값을 의미한다. 한번 초기화 하면 값을 바꿀 수 없다. 정수, 실수, 문자열 등 기본 타입값들로만 상수로 선언될 수 있다. 구조체, 배열 등 기본 타입이 아닌 타입에는 상수를 사용할 수 없다. 상수로 사용될 수 있는 타입 불리언 룬 정수 실수 복소수 문자열 상수는 값으로만 동작한다. 변수가 값, 이름, 타입, 메모리 주소 4가지 속성을 가지는 반면 상수는 값, 이름, 타입 3가지 속성만 가진다. const C int = 10 fmt.Println(\u0026C) // 에러 상수는 값으로만 동작. 주소값에 접근할 수 없다. ","date":"2021-08-19","objectID":"/go-constant-literal/:1:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] Go 상수와 리터럴","uri":"/go-constant-literal/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"리터럴 (Literal) 리터럴은 고정된 값, 데이터 그 자체를 의미한다. var str string = \"Hello World\" var i int = 0 i = 30 “Hello World”, 0, 30 처럼 고정된 값 자체로 쓰인 데이터가 바로 리터럴이다. ","date":"2021-08-19","objectID":"/go-constant-literal/:1:2","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] Go 상수와 리터럴","uri":"/go-constant-literal/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"Go에서 상수와 리터럴 Go 언어에서는 상수는 리터럴과 같이 취급한다. 그래서 컴파일 될 때 상수는 리터럴로 변환되어 실행 파일에 쓰인다. 상수 표현식 역시 컴파일 타임에 실제 결과값 리터럴로 변하기 때문에 상수 표현식 계산에 CPU 자원을 사용하지 않는다. const PI = 3.14 var a int = PI * 100 위의 구문은 컴파일 타임에 아래와 같이 변환된다. var a int = 314 상수의 메모리 주소값에 접근할 수 없는 이유 역시 컴파일 타임에 리터럴로 전환되어서 실행 파일에 값 형태로 쓰이기 때문이다. 그래서 동적 할당 메모리 영역을 사용하지 않는다. ","date":"2021-08-19","objectID":"/go-constant-literal/:1:3","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] Go 상수와 리터럴","uri":"/go-constant-literal/"},{"categories":["Tucker의 Go 프로그래밍"],"content":" Tucker의 Go 언어 프로그래밍 책 내용을 참고 및 정리해서 작성하였습니다. 실수 끼리의 비교연산에서 예기치 않은 결과가 나올 때가 있다. 0.1 + 0.2 = 0.3의 결과를 예상하였지만 실제 출력값은 0.30000000000000004가 출력되었다. package main import \"fmt\" func main() { var a float64 = 0.1 var b float64 = 0.2 var c float64 = 0.3 fmt.Printf(\"%f + %f == %f : %v\\n\", a, b, c, a+b == c) fmt.Println(a+b) } Result 0.100000 + 0.200000 == 0.300000 : false 0.30000000000000004 ","date":"2021-08-18","objectID":"/go-comparison-operator/:0:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 실수 오차","uri":"/go-comparison-operator/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"실수 오차 컴퓨터에서는 실수값을 표현할 때 지수부와 소수부로 나누어서 표현한다. 컴퓨터는 지수부와 소수부가 10진수 기준이 아니라 2진수 기준으로 되어 있다. 그렇기 때문에 10진수를 정확히 표현하기 어려운 문제가 있다. 예를들어 0.375는 0.3 + 0.07 + 0.005로 나타낼 수 있고, 십진수로 표현하면 다음과 같다. $3 * 10^{-1} + 7 * 10^{-2} + 5 * 10^{-3} $ 컴퓨터의 경우 2진수 숫자 체계를 다루므로, $1 * 2^{-2} + 1 * 2^{-3}$ 로 나타낼 수 있다. ($2^{-1} = 0.5, 2^{-2} = 0.25, 2^{-3} = 0.125$) 대부분의 소수점 이하 숫자들은 2의 음의 승수료 표현하기가 어렵다. 그래서 0.376값은 float32 타입으로 최대한 가까운 근사값인 0.375999987125396728515625로 표현이 된다. 이렇게 실수를 근사값으로 표현하면서 발생되는 문제를 부동 소수점 반올림 오차(rounding error) 라고도 한다. 두 실수끼리 같은지 다른지 비교하기 위해서는 어떻게 할 수 있을까? ","date":"2021-08-18","objectID":"/go-comparison-operator/:1:0","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 실수 오차","uri":"/go-comparison-operator/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"1. 작은 오차 무시하기 아주 작은 오차는 무시하는 방법으로 비교해보자. 무시할 오차 한계를 정의하여 그 값을 무시하고 비교한다. package main import \"fmt\" const epsilon = 0.00001 // 매우 작은 상수값을 선언. 무시할 오차 한계를 정의 // 두 값의 차이가 epsilon 비교해서 작을 경우 두 값이 같다고 간주한다. func equal(a, b float64) bool { if a \u003e b { if a - b \u003c= epsilon { return true } else { return false } } else { if b - a \u003c= epsilon { return true } else { return false } } } func main() { var a float64 = 0.1 var b float64 = 0.2 var c float64 = 0.3 fmt.Printf(\"%0.18f + %0.18f = %0.18f\\n\", a, b, a + b) fmt.Printf(\"%0.18f == %0.18f : %v\\n\", c, a + b, equal((a + b), c)) a = 0.0000000000004 b = 0.0000000000002 c = 0.0000000000007 fmt.Printf(\"%g == %g : %v\\n\", c, a+b, equal((a+b), c)) } Result 0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044 0.299999999999999989 == 0.300000000000000044 : true 7e-13 == 6.000000000000001e-13 : true 문제점 오차의 기준을 명확히 정할 수 없다. float64의 경우 $10^{-308}$ ~ $10^{308}$ 까지 매우 큰 값의 범위를 갖는데, 앞서 사용한 상수 epsilon의 경우 0.0000234에 비하면 무시할 만큼 크게 작지 않은 값이다. a,b,c의 값을 매우 작은 값으로 바꾸게 되면 7e-13 == 6.000000000000001e-13 : true 결과처럼 서로 같다는 문제가 발생한다. ","date":"2021-08-18","objectID":"/go-comparison-operator/:1:1","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 실수 오차","uri":"/go-comparison-operator/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"2. 최소 비트 차이 비교 package main import ( \"fmt\" \"strings\" ) func main() { var a float64 = 0.1 var b float64 = 0.2 var c float64 = 0.3 fmt.Printf(\"float64 a : %0.60f\\n\", a) fmt.Printf(\"float64 b : %0.60f\\n\", b) fmt.Println(strings.Repeat(\"-\", 100)) fmt.Printf(\"float64 a+b : %0.60f\\n\", a+b) fmt.Printf(\"float64 0.3 : %0.60f\\n\", c) } Result float64 a : 0.100000000000000005551115123125782702118158340454101562500000 float64 b : 0.200000000000000011102230246251565404236316680908203125000000 —————————————————————————————————- float64 a+b : 0.300000000000000044408920985006261616945266723632812500000000 float64 0.3 : 0.299999999999999988897769753748434595763683319091796875000000 실수 0.1의 근사값(float64) 0.1000000000000000055511151231257827021181583404541015625과 실수 0.2의 근사값(float64) 0.200000000000000011102230246251565404236316680908203125이 덧셈 계산이 발생하여 0.3000000000000000444089209850062616169452667236328125 이라는 결과가 출력되었다. 실수 0.3의 근사값(float64) 0.299999999999999988897769753748434595763683319091796875으로 출력되었다. 두 값 모두 0.3과 정확히 같지는 않지만 0.3보다 아주 작고 혹은 0.3 보다 아주 크다. 두 값은 2진수로 표현했을 때 마지막 1 비트 차이밖에 나지 않는다. 즉 0.3을 표현할 수 있는 실수 타입 범위에서 가장 작은 차이다. 만약 어떤 값이 이 두값의 사이라면 0.3과 같다고 간주할 수 있다. Go lang에서는 math 패키지에 Nextafter() 함수를 통해 x에서 y를 향한 1비트만 조정한 값을 반환한다. func Nextafter(x, y float64) (r float64) x\u003ey : x보다 1비트 감소시킨 값을 반환 x\u003cy : x보다 1비트 증가시킨 값을 반환 x=y : x 즉 가장 작은 오차만큼을 y를 향해서 1비트를 조정하여 실수값의 대소를 비교할 수 있다. Nextafter 함수를 이용한 실수값 대소비교 package main import ( \"fmt\" \"math\" ) func equal(a, b float64) bool { return math.Nextafter(a, b) == b } func main() { var a float64 = 0.1 var b float64 = 0.2 var c float64 = 0.3 fmt.Printf(\"%0.18f + %0.18f = %0.18f\\n\", a, b, a + b) fmt.Printf(\"%0.18f == %0.18f : %v\\n\", c, a+b, equal(a+b, c)) a = 0.0000000000004 b = 0.0000000000002 c = 0.0000000000007 fmt.Printf(\"%g == %g : %v\\n\", c, a+b, equal(a+b, c)) } Result 0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044 0.299999999999999989 == 0.300000000000000044 : true 7e-13 == 6.000000000000001e-13 : false ","date":"2021-08-18","objectID":"/go-comparison-operator/:1:2","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 실수 오차","uri":"/go-comparison-operator/"},{"categories":["Tucker의 Go 프로그래밍"],"content":"3. math/big 패키지의 Float 객체 이용 제작하는 프로그램이 금융 프로그램이라면 math/big 패키지에서 제공하는 Float 객체를 사용해야 한다. 정밀도를 직접 조절 할 수 있기 때문에 정밀도를 높여 더 정확한 수치 계산이 가능하다. math/big 패키지의 Float를 이용하여 실수 비교 예제 package main import ( \"fmt\" \"math/big\" ) func main() { a, _ := new(big.Float).SetString(\"0.1\") b, _ := new(big.Float).SetString(\"0.2\") c, _ := new(big.Float).SetString(\"0.3\") d := new(big.Float).Add(a, b) fmt.Println(a, b, c, d) fmt.Println(c.Cmp(d)) } Result 0.1 0.2 0.3 0.3 0 ","date":"2021-08-18","objectID":"/go-comparison-operator/:1:3","tags":["GO"],"title":"[Tucker의 Go 프로그래밍] 실수 오차","uri":"/go-comparison-operator/"},{"categories":["Etc"],"content":" 할때마다 까먹는다. ","date":"2021-08-13","objectID":"/telegrambot/:0:0","tags":["Telegram Bot"],"title":"텔레그램 봇 설정하기","uri":"/telegrambot/"},{"categories":["Etc"],"content":"텔레그램 봇 만들기 1. 봇아빠 채팅방에 접속 https://t.me/BotFather 혹은 @BotFather 검색하여 채팅방 접속 2. BotFather 채팅방에서 봇 생성 명령어를 입력한다. 채팅창에 /newbot을 입력한다. 3. 텔레그램 봇 이름을 입력한다. 이름은 _bot으로 끝나야 한다. 4. 다시 입력 한번 더 bot 이름을 입력하면 봇 주소와 API 토큰 값을 얻을 수 있다. 5. 봇 채팅방 접속 후 시작 버튼 클릭 6. 봇 채팅방 chat id 얻기 봇 채팅방에서 아무 메세지나 입력한다. 브라우저에서 https://api.telegram.org/bot`봇토큰`/getUpdates 으로 접속하면 JSON 데이터에서 chat 아이디를 확인할 수 있다. chat 객체에 id 값 9자리가 봇챗방 아이디 이다. { \"ok\": true, \"result\": [ { \"update_id\": 556815269, \"message\": { \"message_id\": 3, \"from\": { \"id\": 1719000000, ... }, \"chat\": { \"id\": 1719000000, ... }, \"date\": 1628829234, \"text\": \"/start\", \"entities\": [ { \"offset\": 0, \"length\": 6, \"type\": \"bot_command\" } ] } } ] } ","date":"2021-08-13","objectID":"/telegrambot/:1:0","tags":["Telegram Bot"],"title":"텔레그램 봇 설정하기","uri":"/telegrambot/"},{"categories":["Etc"],"content":"2. Private 채팅방 텔레그램 채널 ID 알아내기 새로운 private 채널을 생성한다. 채널의 초대링크를 복사한다. @username_to_id_bot 채팅방에 접속하여 내 초대 링크를 채팅창에 입력한다. IDBot계정이 나의 private 채팅방의 챗방 ID를 리턴한다. 메세지 보내기 API 테스트! https://api.telegram.org/bot\u003c봇토큰\u003e/sendmessage?chat_id=-1001183952507\u0026text=에쑤빠는나야두리될수없숴 성공쓰 ","date":"2021-08-13","objectID":"/telegrambot/:2:0","tags":["Telegram Bot"],"title":"텔레그램 봇 설정하기","uri":"/telegrambot/"},{"categories":["Etc"],"content":"참고링크 How to obtain the chat_id of a private Telegram channel? ","date":"2021-08-13","objectID":"/telegrambot/:3:0","tags":["Telegram Bot"],"title":"텔레그램 봇 설정하기","uri":"/telegrambot/"},{"categories":["Docker/Kubernetes"],"content":" 기록쓰 기록쓰 👻👻👻👻 ","date":"2021-08-12","objectID":"/docker-oracle/:0:0","tags":["Docker","Oracle"],"title":"[Doker] docker를 사용하여 oracle 12c 세팅하기","uri":"/docker-oracle/"},{"categories":["Docker/Kubernetes"],"content":"Oracle 12c 공식 이미지 다운로드 https://hub.docker.com/_/oracle-database-enterprise-edition?tab=resources 공식 이미지를 다운로드 후 Preceed to Checkout 버튼을 클릭하여 동의 정보를 입력한다. 대충 입력쓰… ","date":"2021-08-12","objectID":"/docker-oracle/:0:1","tags":["Docker","Oracle"],"title":"[Doker] docker를 사용하여 oracle 12c 세팅하기","uri":"/docker-oracle/"},{"categories":["Docker/Kubernetes"],"content":"도커 이미지 다운로드 후 실행 8080은 많이 사용하니까 각각 8282, 1522로 매핑하였다. # docker image pull docker pull store/oracle/database-enterprise:12.2.0.1 # docker run docker run -d -p 8282:8080 -p 1522:1521 --name oracle12c store/oracle/database-enterprise:12.2.0.1 ","date":"2021-08-12","objectID":"/docker-oracle/:0:2","tags":["Docker","Oracle"],"title":"[Doker] docker를 사용하여 oracle 12c 세팅하기","uri":"/docker-oracle/"},{"categories":["Docker/Kubernetes"],"content":"유저 생성 및 권한 부여 sysdba로 sqlplus 접속 docker exec -it oracle12c bash -c \"source /home/oracle/.bashrc; sqlplus sys/Oradoc_db1@ORCLCDB as sysdba\" 사용할 유저 생성 bluetape이라는 유저 생성후 “afternoon” 지정 CREATE USER bluetape IDENTIFIED BY afternoon; ORA-65096: invalid common user or role name Oracle 12c에서는 사용자 생성 방식이 조금 변경되었다. 이전 생성 스크립트로 생성시 ORA-65096: invalid common user or role name 가 발생한다. 해결방안 1 : 계정앞에 C##키워드를 붙여 준다. CREATE USER c##bluetape IDENTIFIED BY afternoon; 해결방안 2 : 현재 세션에 설정 변경 ALTER SESSION SET \"_ORACLE_SCRIPT\" = TRUE; ","date":"2021-08-12","objectID":"/docker-oracle/:0:3","tags":["Docker","Oracle"],"title":"[Doker] docker를 사용하여 oracle 12c 세팅하기","uri":"/docker-oracle/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-23","objectID":"/easy-golang-section12/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 12 : 패키지 고급","uri":"/easy-golang-section12/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"12.1 사용자 패키지 제작 및 문서화 ","date":"2021-04-23","objectID":"/easy-golang-section12/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 12 : 패키지 고급","uri":"/easy-golang-section12/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"12.1.1 사용자 패키지 작성 및 문서화 go 에서 패키지는 폴더명(디렉토리명)으로 접근한다. → 그러므로 명확하게 지정해야 한다. 사용자 패키지를 문서화 할 때 main 패키지를 제외하고 package 문서에 등록된다. 기본적으로 GOROOT 의 패키지에서 검색 → 없으면 GOPATH 패키지를 검색한다. go install 명령어 : GOPATH/pkg 에 패키지 등록 godoc -http:=6060 으로 본인 패키지 메소드 및 주석을 확인 할 수 있다. // 사용자 패키지 작성 및 문서화 예제 package main import ( \"fmt\" oper \"section12/arithmetic\" // alias 사용 (패키지 중복 또는 약자로 사용) ) func main() { // 패키지 사용 예제(사칙연산) nums := oper.Numbers{ X : 100, Y : 10} fmt.Println(\"Package Used(1) : \", nums.Plus()) fmt.Println(\"Package Used(2) : \", nums.Minus()) fmt.Println(\"Package Used(3) : \", nums.Mulit()) fmt.Println(\"Package Used(4) : \", nums.Divide()) fmt.Println(\"Package Used(5) : \", nums.SquarePlus()) fmt.Println(\"Package Used(6) : \", nums.SquareMinus()) } ","date":"2021-04-23","objectID":"/easy-golang-section12/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 12 : 패키지 고급","uri":"/easy-golang-section12/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"12.2 외부 저장소 패키지 설치 및 사용 ","date":"2021-04-23","objectID":"/easy-golang-section12/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 12 : 패키지 고급","uri":"/easy-golang-section12/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"12.2.1 사용자 패키지 설치 및 활용 외부 저장소에 저장된 패키지를 설치하여 사용할 수 있다. import 선언 후 폴더로 이동하여 go get 명령어로 설치한다. go get 패키지 주소 로 설치한다. package main import ( \"github.com/tealeg/xlsx\" ) func main() { xfile := \"section12/sample.xlsx\" xlFile, err := xlsx.OpenFile(xfile) if err != nil { panic(\"Excel Loads Error!\") } for _, sheet := range xlFile.Sheets { for _, row := range sheet.Cols { for _, cell := range row.Cells { text := cell.st } } } } ","date":"2021-04-23","objectID":"/easy-golang-section12/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 12 : 패키지 고급","uri":"/easy-golang-section12/"},{"categories":["Database"],"content":"Oracle Scheduler - DBMS_SCHEDULER 오라클에서 정해진 시간에 반복된 작업을 수행하기 위해 DBMS_JOB 패키지를 활용하였지만 Oracle 10g 부터는 좀 더 확장된 기능을 가진 DBMS_SCHEDULER 패키지를 제공하고 있다. DBMS_JOB과의 가장 큰 차이점은 DBMS_JOB에서는 불가능하던 외부스크립트 (프로시저나, 함수 이외에도 OS에서 생성된 각종 유틸, 프로그램 까지) 실행이 가능하다. ","date":"2021-04-23","objectID":"/oracle-scheduler/:0:0","tags":["Oracle","Database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/oracle-scheduler/"},{"categories":["Database"],"content":"Class 생성 클래스를 지정하지 않게 되면 DEFAULT_JOB_CLASS 에 포함되는데 이 경우 기본 로깅 정책을 따른다. 기본로깅 정책은 DBMS_SCHEDULER.LOGGING_RUNS 이며 로깅레벨을 별도로 설정하거나 다른 스케쥴잡과 그룹화하여 관리하고 싶을 경우 Class를 생성한다. /** * CLASS 생성 예제 * 로그정책 : DBMS_SCHEDULER.LOGGING_FAILED_RUNS * 30일만 로그 보관 * */ BEGIN DBMS_SCHEDULER.CREATE_JOB_CLASS ( job_class_name =\u003e 'EXAMPLE_JOB_CLASS', resource_consumer_group =\u003e 'DEFAULT_CONSUMER_GROUP', logging_level =\u003e DBMS_SCHEDULER.LOGGING_FAILED_RUNS, log_history =\u003e 30, comments =\u003e 'JOB CLASS 설명 입니다.' ); END; ","date":"2021-04-23","objectID":"/oracle-scheduler/:0:1","tags":["Oracle","Database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/oracle-scheduler/"},{"categories":["Database"],"content":"Scheduler Job 생성하고 활성화 하기 로그정책 : DBMS_SCHEDULER.LOGGING_FAILED_RUNS. 30일만 로그를 보관한다. 실행 주기는 30초 마다로 설정 -- Job 생성 BEGIN DBMS_SCHEDULER.CREATE_JOB( JOB_NAME =\u003e 'test_job', JOB_TYPE =\u003e 'STORED_PROCEDURE', JOB_ACTION =\u003e 'test_procedure', START_DATE =\u003e SYSDATE, REPEAT_INTERVAL =\u003e 'FREQ=SECONDLY;INTERVAL=30', COMMENTS =\u003e '테스트 잡' ); END; -- Job 활성화 BEGIN DBMS_SCHEDULER.ENABLE('JBT_SEARCH_TRUCK_FLTER'); END; ","date":"2021-04-23","objectID":"/oracle-scheduler/:0:2","tags":["Oracle","Database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/oracle-scheduler/"},{"categories":["Database"],"content":"Oracle Scheduler Job에 로그 레벨 세팅하기 Logging Level Description DBMS_SCHEDULER.LOGGING_OFF No logging is performed. DBMS_SCHEDULER.LOGGING_FAILED_RUNS A log entry is made only if the job fails. DBMS_SCHEDULER.LOGGING_RUNS A log entry is made each time the job is run. DBMS_SCHEDULER.LOGGING_FULL A log entry is made every time the job runs and for every operation performed on a job, including create, enable/disable, update (with SET_ATTRIBUTE), stop, and drop. BEGIN DBMS_SCHEDULER.set_attribute ( name =\u003e 'test_log_job', attribute =\u003e 'logging_level', value =\u003e DBMS_SCHEDULER.logging_off); END; -- 스케쥴 잡 로그 테이블 SELECT * FROM USER_SCHEDULER_JOB_LOG; ","date":"2021-04-23","objectID":"/oracle-scheduler/:0:3","tags":["Oracle","Database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/oracle-scheduler/"},{"categories":["Database"],"content":"기타 설정 메서드 -- Job 활성화 BEGIN DBMS_SCHEDULER.ENABLE('JBT_SEARCH_TRUCK_FLTER'); END; -- Job 비활성화 BEGIN DBMS_SCHEDULER.DISABLE('JBT_SEARCH_TRUCK_FLTER'); END; -- Job 지우기 BEGIN DBMS_SCHEDULER.DROP_JOB (job_name =\u003e 'JBT_SEARCH_TRUCK_FLTER'); END; ","date":"2021-04-23","objectID":"/oracle-scheduler/:0:4","tags":["Oracle","Database"],"title":"Oracle Scheduler DBMS_SCHEDULER 개념 및 사용법","uri":"/oracle-scheduler/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-23","objectID":"/easy-golang-section11/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 11 : Go 파일 입출력","uri":"/easy-golang-section11/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"11.1 파일 입출력 ","date":"2021-04-23","objectID":"/easy-golang-section11/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 11 : Go 파일 입출력","uri":"/easy-golang-section11/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"11.1.1 os 패키지 - 파일 읽기, 쓰기 Go에서 파일을 읽고 쓰기 위해 Go 표준 패키지인 os 패키지를 사용할 수 있다. os.Open() : 기존 파일 열기 os.Create() : 새 파일을 생성 os.Close() : 파일 리소스 닫기 파일 읽기 및 탐색 예제 package main import ( \"fmt\" \"os\" ) // 에러 체크 방식 1 func errCheck1(e error) { if e != nil { panic(e) } } // 에러 체크 방식 2 func errCheck2(e error) { if e != nil { fmt.Println(e) return } } func main() { // 파일 열기 file, err := os.Open(\"section11/sample.txt\") errCheck1(err) // 읽기 예제 1 fileInfo, err := file.Stat() // 파일 사이즈 확인 위해 정보 획득 errCheck2(err) fd1 := make([]byte, fileInfo.Size()) // 슬라이스에 읽은 내용 담는다. ct1, err := file.Read(fd1) fmt.Println(\"파일 정보 출력 1 =\u003e \", fileInfo, \"\\n\") fmt.Println(\"파일 이름 1 =\u003e \", fileInfo.Name(), \"\\n\") fmt.Println(\"파일 크기 1 =\u003e \", fileInfo.Size(), \"\\n\") fmt.Println(\"파일 수정 시간 1 =\u003e\", fileInfo.ModTime(), \"\\n\") fmt.Printf(\"읽기 작업 완료 1 =\u003e (%d bytes) \\n\\n\", ct1) fmt.Println(string(fd1)) // 읽기 예제 2 (탐색 : Seek(offset)) o1, err := file.Seek(20, 0) // 0 : 처음위치, 1: 현재위치 2: 마지막위치 errCheck2(err) fd2 := make([]byte, 20) ct2, err := file.Read(fd2) errCheck2(err) fmt.Printf(\"읽기 작업 완료 2 =\u003e (%d bytes) (%d ret)\\n\\n\", ct2, o1) fmt.Println(string(fd2)) // 읽기 예제 3 o2, err := file.Seek(0, 0) errCheck2(err) fd3 := make([]byte, 50) ct3, err := file.ReadAt(fd3, 8) // offset errCheck1(err) fmt.Printf(\"읽기 작업 완료 2 =\u003e (%d bytes) (%d ret)\\n\\n\", ct3, o2) fmt.Println(string(fd3)) defer file.Close() } 파일 쓰기 예제 package main import ( \"fmt\" \"os\" ) // 에러 체크 방식 1 func errCheck1(e error) { if e != nil { panic(e) } } // 에러 체크 방식 2 func errCheck2(e error) { if e != nil { fmt.Println(e) return } } // 파일 쓰기 1 func main() { // 파일 쓰기 예제 file, err := os.Create(\"test_write.txt\") errCheck1(err) // 리소스 해제 defer file.Close() // 쓰기 예제 s1 := []byte{115, 111, 109, 101, 111} n1, err := file.Write([]byte(s1)) // 문자열 -\u003e byte 슬라이스 형으로 변환 후 쓰기 errCheck2(err) fmt.Printf(\"File Write Result : (%d bytes)\\n\", n1) file.Sync() // Write Commit (Stable)! // 쓰기 예제 2 s2 := \"Hello GoLang! \\n File Write Test - 1 \\n\" n2, err := file.WriteString(s2) errCheck2(err) fmt.Printf(\"File Write Result(2) : (%d bytes)\\n\", n2) file.Sync() // 쓰기 예제 3 s3 := \"Test WriteAt ! - 2 \\n\" n3, err := file.WriteAt([]byte(s3), 70) // len(offset) 조절하면서 테스트 errCheck1(err) fmt.Printf(\"File Write Result(3) : (%d bytes)\\n\", n3) file.Sync() // 쓰기 예제 4 n4, err := file.WriteString(\"Hello GoLang! \\n File Write Test! - 3\\n\") errCheck2(err) fmt.Printf(\"File Write Result(4) : (%d bytes)\\n\", n4) } ","date":"2021-04-23","objectID":"/easy-golang-section11/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 11 : Go 파일 입출력","uri":"/easy-golang-section11/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"11.1.2 CSV 파일 읽기 패키지 저장소를 통해 Excel 등 다양한 파일 형식 쓰기, 읽기가 가능하다. bufio : 파일이 용량이 클 경우 버퍼 사용을 권장한다. 사용패키지 : tealeg/xlsx csv 파일 읽기 package main import ( \"bufio\" \"encoding/csv\" \"fmt\" \"os\" ) func errCheck(e error) { if e != nil { panic(e) } } func main() { // 파일 생성 file, err := os.Open(\"section11/sample.csv\") errCheck(err) // 리소스 해제 defer file.Close() // CSV Reader 생성 //rr := csv.NewReader(file) rr := csv.NewReader(bufio.NewReader(file)) // 권장 // CSV 내용 읽기 row, err := rr.Read() // 1개의 Row 단위로 읽기 errCheck(err) row2, err2 := rr.Read() // 1개의 Row 단위로 읽기 errCheck(err2) fmt.Println(\"CSV Read Example\") fmt.Println(row[0], row[1], row[2]) fmt.Println(row2[0], row2[1], row2[2]) fmt.Println(row[0:5]) fmt.Println(\"=================================\") rows, err := rr.ReadAll() // 전체 Row Read errCheck(err) fmt.Println(\"CSV Read All Example\") fmt.Println(rows) fmt.Println(rows[5][1]) // Row 단위로 CSV 파일 읽기 for i, row := range rows { // fmt.Println(i, row) for j := range row { fmt.Printf(\"%s \", rows[i][j]) } fmt.Println() } } csv 파일 쓰기 package main import ( \"encoding/csv\" \"fmt\" \"os\" _ \"bufio\" ) // 에러 체크 방식 1 func errCheck1(e error) { if e != nil { panic(e) } } // 에러 체크 방식 2 func errCheck2(e error) { if e != nil { fmt.Println(e) return } } func main() { // 파일 생성 file, err := os.Create(\"test_write.csv\") errCheck1(err) // 리소스 해제 defer file.Close() // CSV Writer 생성 wr := csv.NewWriter(file) // wr := csv.NewWriter(bufio.NewWriter(file)) // csv 내용 쓰기 wr.Write([]string{\"KIM\", \"4.8\"}) wr.Write([]string{\"LEE\", \"4.2\"}) wr.Write([]string{\"PARK\", \"4.1\"}) wr.Write([]string{\"CHO\", \"4.0\"}) wr.Write([]string{\"HONG\", \"4.2\"}) wr.Flush() // 버퍼 -\u003e 파일로 쓰기 fi, err := file.Stat() errCheck1(err) fmt.Printf(\"CSV 쓰기 작업 후 파일 크기 (%d bytes)\\n\", fi.Size()) fmt.Println(\"CSV 파일명 : \", fi.Name()) fmt.Println(\"운영 체제 파일 권한 : \", fi.Mode()) } ","date":"2021-04-23","objectID":"/easy-golang-section11/:1:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 11 : Go 파일 입출력","uri":"/easy-golang-section11/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"11.1.3 ioutil 패키지를 활용 ioutil 패키지를 활용하면 더욱 편리하고 직관적인 파일을 읽고 쓰기가 가능. WriteFile(), ReadFile() , ReadAll() 등을 사용한다. ioutil - The Go Programming Language 파일 퍼미션 읽기(4), 쓰기(2), 실행(1) 소유자, 그룹, 기타사용자 순서 os - The Go Programming Language ioutil 활용 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func errCheck(e error) { if e != nil { panic(e) } } func main() { s := \"Hello Golang!\\n File Write Test!\\n\" // 파일 쓰기 err := ioutil.WriteFile(\"test_write1.txt\", []byte(s), os.FileMode(0644)) errCheck(err) // 파일 읽기 data, err := ioutil.ReadFile(\"section11/sample.txt\") errCheck(err) fmt.Println(\"=============================================\") fmt.Println(string(data)) fmt.Println(\"=============================================\") } ","date":"2021-04-23","objectID":"/easy-golang-section11/:1:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 11 : Go 파일 입출력","uri":"/easy-golang-section11/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"11.1.5 파일 버퍼사용 bufio 패키지를 활용하여 파일 읽고 쓰기시 버퍼를 사용할 수 있다. ioutil, bufio 등은 io.Reader, io.Writer 인터페이스를 구현 한다. bufio - The Go Programming Language type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } 버퍼의 사용 상태 a ------\u003e a b ------\u003e ab c ------\u003e abc d ------\u003e abcd // 버퍼가 꽉찰경우 버퍼를 비우고 파일을 쓴다. e ------\u003e e -------\u003e abcd f ------\u003e ef -------\u003e abcd g ------\u003e efg -------\u003e abcd h ------\u003e efgh --------\u003e abcd i ------\u003e i -------\u003e abcdefg package main import ( \"bufio\" \"fmt\" \"os\" ) func errCheck(e error) { if e != nil { panic(e) } } func main() { file, err := os.OpenFile(\"test_write2.txt\", os.O_CREATE|os.O_RDWR, os.FileMode(0777)) // bufio 파일 쓰기 예제 wt := bufio.NewWriter(file) // Writer 반환한다. - 버퍼사용 wt.WriteString(\"Hello Golang!\\nFile Write Test!\\n\") wt.Write([]byte(\"Hello Golang!\\nFile Write Test222!\\n\")) // Error Check errCheck(err) // 버퍼 정보 출력 fmt.Printf(\"사용한 Buffer Size : (%d Bytes)\\n\", wt.Buffered()) fmt.Printf(\"남은 Buffer Size : (%d Bytes)\\n\", wt.Available()) fmt.Printf(\"전체 Buffer Size : (%d Bytes)\\n\", wt.Size()) wt.Flush() // 버퍼 비우고 디스크 반영 (버퍼의 내용을 디스크에 기록한다.) fmt.Println(\"쓰기 작업 완료 \\n\") fmt.Println(\"=================================================\") rt := bufio.NewReader(file) // Reader 반환 fi, err := file.Stat() errCheck(err) b := make([]byte, fi.Size()) fmt.Println(\"파일 정보 출력 : \", fi) fmt.Println(\"파일 이름: \", fi.Name()) fmt.Println(\"파일 크기 : \", fi.Size()) fmt.Println(\"파일 수정시간 : \", fi.ModTime()) fmt.Println(\"=================================================\") fmt.Println() file.Seek(0, os.SEEK_SET) data, _ := rt.Read(b) // 읽기(ReadLine, ReadByte, ReadBytes 등) // rt.Read(b) fmt.Printf(\"전체 Buffer Szie : (%d Bytes)\\n\", rt.Size()) fmt.Printf(\"읽기 작업 완료 (%d Bytes) \\n\", data) fmt.Println(\"=================================================\") fmt.Println(string(b)) fmt.Println(\"=================================================\") defer file.Close() } ","date":"2021-04-23","objectID":"/easy-golang-section11/:1:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 11 : Go 파일 입출력","uri":"/easy-golang-section11/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-23","objectID":"/easy-golang-section10/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 10 : 에러 처리","uri":"/easy-golang-section10/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"10.1 에러처리 ","date":"2021-04-23","objectID":"/easy-golang-section10/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 10 : 에러 처리","uri":"/easy-golang-section10/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"10.1.1 Go 에러 소프트웨어의 품질 향상에 가장 중요한 것 → 유형코드 및 에러 정보 등을 남기는 것 Go 에서는 기본적으로 error 라는 인터페이스 타입을 갖고 있다. 개발자는 이 인터페이스를 구현하는 커스텀 에러 타입을 만들 수 있다. type error interface { Error() string } ","date":"2021-04-23","objectID":"/easy-golang-section10/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 10 : 에러 처리","uri":"/easy-golang-section10/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"10.1.2 Go 에러처리 Go 함수의 경우 기본적으로 리턴 타입을 두개 갖고 있다. (리턴값, 에러) 주로 에러 타입을 리턴 하거나 Fatal(프로그램 종료) 메소드를 통해 에러를 출력한다. os.Open() 함수는 첫번째는 File 포인터를 두번째는 error 인터페이스를 리턴한다. func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) } 기본적인 메서드 에러 처리 예제 package main import ( \"fmt\" \"log\" \"os\" ) func main() { // 기본적인 메서드 에러 처리 예제 f, err := os.Open(\"unnamedfile\") // 예외 발생 if err != nil { log.Fatal(err.Error()) // 프로그램 종료 //log.Fatal(err) } fmt.Println(\"=======================\") fmt.Println(\"Example 1 : \", f.Name()) } errors 패키지의 New 메소드를 활용한 에러 생성 package main import ( \"errors\" \"fmt\" ) func main() { var err1 error = errors.New(\"Error occurred - 1\") err2 := errors.New(\"error occurred - 2\") fmt.Println(\"error1 : \", err1) fmt.Println(\"error1 : \", err1.Error()) fmt.Println(\"error2 : \", err2) fmt.Println(\"error2 : \", err2.Error()) } 구조체를 사용하여 사용자 정의 예외처리 예제 package main import ( \"fmt\" \"log\" \"math\" \"time\" ) // 에러(예외) 처리 구조체 type PowError struct { time time.Time // 에러 발생 시간 value float64 // 파라미터 message string // 에러 메세지 // value interface{} } func(e *PowError) Error() string { return fmt.Sprintf(\"[%v]Error - Input Value(value: %g) - %s\", e.time, e.value, e.message) } func Power2(f, i float64) (float64, error) { if f == 0 { return 0, \u0026PowError{time : time.Now(), value: f, message: \"0은 사용할 수 없습니다.\"} } if math.IsNaN(f) { return 0, \u0026PowError{time: time.Now(), value: f, message: \"숫자가 아닙니다.\"} } if math.IsNaN(i) { return 0, \u0026PowError{time: time.Now(), value: i, message: \"숫자가 아닙니다.\"} } return math.Pow(f, i), nil } // Go 에러 처리 고급 - 3 func main() { // Example 1 v, err := Power2(10, 3) // 정상 if err != nil { log.Fatal(err) } fmt.Println(\"Example 1 : \", v) // Example 2 t, err := Power2(0, 3) // Error if err != nil { log.Fatal(err) fmt.Println(err.(*PowError).message) } fmt.Println(\"Example 1 : \", t) } ","date":"2021-04-23","objectID":"/easy-golang-section10/:1:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 10 : 에러 처리","uri":"/easy-golang-section10/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"10.2 recover, panic ","date":"2021-04-23","objectID":"/easy-golang-section10/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 10 : 에러 처리","uri":"/easy-golang-section10/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"10.2.1 panic 함수 Go 내장 함수인 panic() 함수는 현재 함수를 즉시 중지시키고 defer 함수를 호출하고 자기 자신을 호출한 곳으로 즉시 리턴한다. 이러한 panic 모드 실행 방식은 다시 상위함수에도 똑같이 적용되고, 계속 콜스택을 타고 올라가며 적용된다. → 런타임 이외에 사용자가 코드 흐름에 따라 에러를 발생 시킬때 중요하다 panic 사용방법 package main import ( \"fmt\" ) func main() { fmt.Println(\"Start Main\") panic(\"Error occurred : user Stopped!\") // 방법1 //log.Panic(\"Error occurred : user Stopped!\") // 방법2 fmt.Println(\"End Main\") // 실행 불가 } ","date":"2021-04-23","objectID":"/easy-golang-section10/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 10 : 에러 처리","uri":"/easy-golang-section10/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"10.2.2 recover 함수 Go 내장 함수인 recover() 함수는 패닉상태를 다시 정상상태로 되돌리는 함수이다. panic에서 설정한 메세지를 받아 올 수 있다. package main import ( \"fmt\" \"os\" ) func fileOpen(filename string) { // defer 함수 - panic이 호출 되면 실행 defer func() { if r := recover(); r != nil { fmt.Println(\"File Open Error! -\u003e \", r) } }() f, err := os.Open(filename) if err != nil { panic(err) } else { fmt.Println(\"Filename : \", f.Name()) } defer f.Close() } func main() { fileOpen(\"undefined.txt\") fmt.Println(\"End Main.\") } ","date":"2021-04-23","objectID":"/easy-golang-section10/:2:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 10 : 에러 처리","uri":"/easy-golang-section10/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-15","objectID":"/easy-golang-section9/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.1 고루틴 ","date":"2021-04-15","objectID":"/easy-golang-section9/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.1.1 GoRoutine goroutine은 go 런타임이 관리하는 lightweight 논리적(가장적) Thread이다. 생성 방법이 매우 간단하고 리소스를 매우 적게 사용한다. → 수 많은 고루틴을 동시에 생성 및 실행이 가능 Java나 Python의 스레드는 MB단위인 반면에 GO KB 단위이다. 비동기적 asynchronously 함수 루틴을 실행 한다. 채널을 통해 루틴간 통신이 가능하다. 공유 메모리를 사용시에 정확한 동기화 코딩이 필요하다. 싱글 루틴에 비해 항상 빠르지는 않다. 멀티 스레드의 장점과 단점 장점 응답성이 향상 자원공유를 효율적으로 활용 가능 작업이 분리되어 코드 간결 단점 구현하기 어려움. 테스트 및 디버깅이 어렵다 전체 프로세스의 사이드 이펙트가 발생 성능 저하 동기화 코딩을 반드시 숙지 데드락(교착상태) 고루틴 기초사용 예제 메인 루틴이 종료되면 서브루틴(exe2, exe3) 도 종료되기 때문에 메인루틴의 실행시간을 줌 package main import ( \"fmt\" \"time\" ) func exe1() { fmt.Println(\"exe1 func start\", time.Now()) time.Sleep(1 * time.Second) // 1초 fmt.Println(\"exe1 func end\", time.Now()) } func exe2() { fmt.Println(\"exe2 func start\", time.Now()) time.Sleep(1 * time.Second) // 1초 fmt.Println(\"exe2 func end\", time.Now()) } func exe3() { fmt.Println(\"exe3 func start\", time.Now()) time.Sleep(1 * time.Second) // 1초 fmt.Println(\"exe3 func end\", time.Now()) } // 고루틴(Goroutine) 기초 func main() { exe1() // 가장 먼저 실행 (일반적인 실행 흐름) // exe2() // exe3() fmt.Println(\"Main Routine Start\", time.Now()) // 별도의 실행 흐름을 생성 go exe2() go exe3() time.Sleep(4 * time.Second) fmt.Println(\"Main Routine End\", time.Now()) } Result exe1 func start 2021-04-13 11:40:12.15236 +0900 KST m=+0.000091278 exe1 func end 2021-04-13 11:40:13.157639 +0900 KST m=+1.005357230 Main Routine Start 2021-04-13 11:40:13.157766 +0900 KST m=+1.005484383 exe3 func start 2021-04-13 11:40:13.157812 +0900 KST m=+1.005529633 exe2 func start 2021-04-13 11:40:13.157855 +0900 KST m=+1.005573044 exe2 func end 2021-04-13 11:40:14.162966 +0900 KST m=+2.010670709 exe3 func end 2021-04-13 11:40:14.163006 +0900 KST m=+2.010710760 Main Routine End 2021-04-13 11:40:17.158061 +0900 KST m=+5.005725592 // exe2, exe3은 별도의 실행흐름에 따라 실행된다. goroutine 반복문 예제 package main import ( \"fmt\" \"time\" ) func exe(name string) { fmt.Println(name, \"Start : \", time.Now()) for i := 0; i \u003c 1000; i++ { fmt.Println(name, \"\u003e\u003e\u003e\u003e\u003e\", i) } fmt.Println(name, \"End : \", time.Now()) } func main() { // 고루틴 (Goroutine) exe(\"t1\") fmt.Println(\"Main Routine Start : \", time.Now()) go exe(\"t2\") go exe(\"t3\") time.Sleep(4 * time.Second) // time.Second, Minute, Hour, Millisecond ... fmt.Println(\"Main Routine End : \", time.Now()) } ","date":"2021-04-15","objectID":"/easy-golang-section9/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.1.2 멀티 코어 (다중 CPU) 활용하기 Go는 디폴트로 1개의 CPU를 사용한다. → 여러개의 Go 루틴을 만들더라도 1 개의 CPU에서 작업을 시분할하여 처리한다 ⇒ 동시성(concurrent) 처리 만약 머신이 복수개의 CPU를 가진경우, Go 프로그램을 다중 CPU에서 병렬처리(parallel) 하게 할 수 있다. 병렬처리를 위해서는 runtime.GOMAXPROCS(CPU수) 함수를 호출해야 한다. package main import ( \"fmt\" \"time\" \"math/rand\" \"runtime\" ) func exe(name int) { r := rand.Intn(100) fmt.Println(name, \"Start : \", time.Now()) for i := 0; i \u003c 100; i++ { fmt.Println(name, \"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\", r, i) } fmt.Println(name, \"End : \", time.Now()) } func main() { runtime.GOMAXPROCS(runtime.NumCPU()) // 현 시스템 cpu 코어 개수 반환 후 설정 fmt.Println(\"Current System CPU : \", runtime.GOMAXPROCS(0)) // 설정 값 출력 // Example 1 fmt.Println(\"Main Routine Start : \", time.Now()) for i := 0; i \u003c 100; i++ { go exe(i) // GO ROUTINE 100개 생성 } time.Sleep(5 * time.Second) fmt.Println(\"Main Routine End : \", time.Now()) } ","date":"2021-04-15","objectID":"/easy-golang-section9/:1:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.1.3 클로저를 고루틴으로 실행할 때 주의할 점 반복문 내에 고루틴을 삽입하여 클로저를 통해 바깥 변수를 참조할 때 유의하여 사용해야 한다. for i := 0; i \u003c 1000; i++ { go func() { fmt.Println(\"Closure Test =\u003e \", i) }() } 이렇게 사용하는 경우 출력이 i가 0부터 999 까지 출력 될 것이라 예상하지만 결과는 다르다. 실행 결과 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 Closure Test =\u003e 1000 … 일반적으로 반복문 클로저는 즉시 실행되지만, 고루틴으로 클로저를 사용할 때 반복문이 종료된 뒤 가장 나중에 실행된다. 그러므로 i 가 반복문을 다 돌고난 1000의 값이 나오게 된다. 고루틴 클로저를 사용할때 반복문에 의해 변경되는 값은 파라미터로 넘겨주어야만 올바른 결과를 얻을 수 있다. 개선소스 package main import ( \"fmt\" \"runtime\" \"time\" ) func main() { runtime.GOMAXPROCS(1) s := \"Go Routine Closure : \" for i := 0; i \u003c 1000; i++ { go func(n int) { fmt.Println(s, n, \" - \", time.Now()) }(i) } time.Sleep(5 * time.Second) } ","date":"2021-04-15","objectID":"/easy-golang-section9/:1:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.2 채널 ","date":"2021-04-15","objectID":"/easy-golang-section9/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.2.1 채널 Go 채널은 고루틴간의 데이터를 주고 받는 통로라고 할 수 있다. 고루틴 끼리 데이터를 주고 받는데 사용되며, 상태편이 준비될 때까지 채널에서 대기함으로서 별도의 Lock 을 걸지않고 데이터를 동기화하는데 사용된다. 채널은 make() 함수를 통해 미리 생성되어야 하며(=참조타입임) 동기방식으로 동작한다. 지정한 데이터 타입만 주고 받을 수 있다. → interface{} 를 통해 자료형 상관없이 전송 및 수신 가능 멀티프로세싱 처리에서 교착상태(경쟁상태)에 주의해야 한다. \u003c-, -\u003e 을 통해 데이터를 주고 받는다. 채널 ← 데이터 : 송신 변수 ← 채널 : 수신 package main import \"fmt\" func rangeSum(rg int, c chan int) { sum := 0 for i := 1; i \u003c= rg; i++ { sum += i } c \u003c- sum } func main() { // 채널(Channel) c := make(chan int) go rangeSum(1000, c) go rangeSum(7000, c) go rangeSum(5000, c) result1 := \u003c- c result2 := \u003c- c result3 := \u003c- c fmt.Println(\"Example 1 : \", result1) fmt.Println(\"Example 2 : \", result2) fmt.Println(\"Example 3 : \", result3) } Result Example 1 : 12502500 Example 2 : 500500 Example 3 : 24503500 ","date":"2021-04-15","objectID":"/easy-golang-section9/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.2.2 Go 채널 버퍼링 Unbuffered Channel ,Buffered Channel 두가지의 채널이 있다. Unbuffered Channel 수신자가 데이터를 받을 때 까지 송신자가 데이터를 보내느 채널에 묶여 있게 된다. package main import ( \"fmt\" \"time\" ) func main() { // Channel // 동기 : 버퍼 미사용 ch := make(chan bool) cnt := 6 go func() { for i := 0; i \u003c cnt; i++ { ch \u003c- true fmt.Println(\"Go =\u003e \", i) time.Sleep(1 * time.Second) } }() for i := 0; i \u003c cnt; i++ { \u003c- ch fmt.Println(\"Main : \", i) } } Result Buffered Channel 수신자가 받을 준비가 되어 있지 않을 지라도 지정된 버퍼만큼 데이터를 보내고 계속 다른 일을 수행할 수 있다. make(chan type, N) 함수를 통해 생성할 수 있으며 N 에 사용할 버퍼의 개수를 넣는다. 발신 : 가득차면 대기, 비어있으면 동작 수신 : 비어있으면 대기, 가득차면 작동 package main import ( \"fmt\" \"runtime\" ) func main() { runtime.GOMAXPROCS(1) ch := make(chan bool, 2) cnt := 12 go func() { for i := 0; i \u003c cnt; i++ { ch \u003c- true fmt.Println(\"Go =\u003e \", i) } }() for i := 0; i \u003c cnt; i++ { \u003c- ch fmt.Println(\"Main : \", i) } } Result 버퍼 채널의 경우 수신자가 당장 없더라도 최대버퍼 수까지 데이터를 보낼 수 있다. 버퍼채널을 이용하지 않는 경우 fatal error: all goroutines are asleep - deadlock! 에러발생 package main import \"fmt\" func main() { ch := make(chan int, 1) //수신자가 없더라도 보낼 수 있다. ch \u003c- 101 fmt.Println(\u003c-ch) } ","date":"2021-04-15","objectID":"/easy-golang-section9/:2:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.2.3 채널 닫기 채널을 오픈하고 데이터를 송신한 뒤 close() 함수를 통해 채널을 닫을 수 있다. 닫힌 채널에서 값을 전송할 경우 panic 예외가 발생한다. 채널 Range 채널에서 송신자가 송신을 한 후, 채널을 닫을 수 있다. 그리고 수신자는 임의의 갯수의 데이터를 채널이 닫힐 때까지 계속 수신할 수 있다. range로 순회하면서 채널이 닫힐 때까지 값을 꺼내올 수 있다. package main import \"fmt\" func main() { ch := make(chan bool) go func() { for i := 0; i \u003c 5; i++ { ch \u003c- true } close(ch) // 5회 채널에 값 전송 후 채널 닫기 }() for i := range ch { // 채널에서 값을 꺼내 온다 fmt.Println(\"Example 1 : \", i) } } 채널이 닫힌것을 파라미터를 통해 받아 올 수 있다. ch := make(chan int) go func() { for i := 0; i \u003c 3; i++ { ch \u003c- 7777 } }() if val1, ok := \u003c- ch; ok { // ... } ","date":"2021-04-15","objectID":"/easy-golang-section9/:2:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.2.4 채널 파라미터 채널을 함수 파라미터를 전달할 때, 일반적으로 송수신을 모두 하는 채널을 전달하지만 특별히 해당 채널로 송신 및 수신 전용 채널을 지정할 수 있다. 수발신 전용 채널 설정 후 방향이 다를 경우 예외가 발생한다. 발신 전용 : channel ← 데이터형 수신 전용 : ← channel 채널 또한 함수의 반환 값으로 사용할 수 있다. 발신 전용, 수신 전용 채널 생성 package main import ( \"fmt\" \"time\" ) // 발신 전용 func sendOnly(c chan\u003c- int, cnt int) { for i := 0; i \u003c cnt; i++ { c \u003c- i } c \u003c- 777 // fmt.Println(\u003c-c) // 수신 전용채널에서 발신 처리 시 예외 발생 } // 수신 전용 func receiveOnly(c \u003c-chan int) { for i := range c { fmt.Println(\"Received i : \", i) } fmt.Println(\u003c-c) } func main() { c := make(chan int) go sendOnly(c, 10) // 발신 전용 go receiveOnly(c) // 수신 전용 time.Sleep(1 * time.Second) } 채널을 함수의 반환 값으로 사용 package main import \"fmt\" // 수신 전용 채널을 리턴값으로 리턴 func sum(cnt int) \u003c-chan int { sum := 0 tot := make(chan int) go func() { for i := 1; i \u003c= cnt; i++ { sum += i } tot \u003c- sum }() return tot } func main() { c := sum(100) fmt.Println(\"Example 1 \", \u003c-c ) } 반환 된 채널을 전달받아 다시 채널로 반환 package main import \"fmt\" func receiveOnly(cnt int) \u003c-chan int { sum := 0 tot := make(chan int) go func() { for i := 1; i \u003c= cnt; i++ { sum += i } tot \u003c- sum tot \u003c- 777 tot \u003c- 777 close(tot) }() return tot } func total(c \u003c-chan int) \u003c-chan int { tot := make(chan int) go func() { a := 0 for i := range c { a = a + i } tot \u003c- a close(tot) }() return tot } func main() { // Channel // Example1 c := receiveOnly(100) // 채널 반환 output := total(c) // 채널 전달 후 반환 fmt.Println(\"Example 1 : \", \u003c-output) } ","date":"2021-04-15","objectID":"/easy-golang-section9/:2:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.2.5 채널 Select 구문 select문은 여러 개의 case문에서 각기 다른 채널을 기다리다가 데이터가 수신되면 준비된 채널 case를 실행하게 된다. 일회성 구문이므로 for (반복문) 안에서 수행되어야 한다. 복수 채널에 신호가 오면 Go 런타임에서 랜덤하게 한개를 선택한다. select문에 defaut 문이 있으면 case문 채널이 준비되지 않더라도 계속 대기하지 않고 바로 default 문을 실행하므로 주의해야 한다. package main import ( \"fmt\" \"time\" ) func main() { ch1 := make(chan int) ch2 := make(chan string) go func() { for { ch1 \u003c- 77 time.Sleep(250 * time.Millisecond) } }() go func() { for { ch2 \u003c- \"Golang Hi!\" time.Sleep(500 * time.Millisecond) } }() go func() { for { select { case num := \u003c- ch1: fmt.Println(\"Channel 1 =\u003e \", num) case str := \u003c- ch2: fmt.Println(\"Channel 2 =\u003e \", str) // default: // fmt.Println(\"Default Test !\") } } }() time.Sleep(7 * time.Second) } ","date":"2021-04-15","objectID":"/easy-golang-section9/:2:5","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.3 동기화 ","date":"2021-04-15","objectID":"/easy-golang-section9/:3:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.3.1 고루틴 동기화 다중 코어에서 어떤 작업을 분할하여 작업시 해당 작업과 다른 작업이 같은 메모리 영역을 건드릴 경우 예기치 않은 동작이나 치명적이 에러를 유발할 수 있다. OS 내부적으로 원자적 연산을 보장하기 위해 다양한 기법을 사용하지만 응용 프로그래머 입장에서도 멀티코어를 잘 처리하기 위해 코드안에서 동기화 처리가 매우 중요하다. 동기화를 사용하지 않은 경우 package main import ( \"fmt\" \"runtime\" ) // 구조체 선언 - 여러 Go Routine 에서 접근하는 공유 데이터 type count struct { num int } func (c *count) increment() { c.num += 1 } func (c *count) result() { fmt.Println(c.num) } func main() { // 동기화 사용하지 않은 경우 예제 // 시스템 전체 CPU 사용 runtime.GOMAXPROCS(runtime.NumCPU()) c := count{num: 0} done := make(chan bool) for i := 1; i \u003c= 10000; i++ { go func() { c.increment() done \u003c- true runtime.Gosched() // 다른 CPU 에게 양보 }() } for i := 1; i \u003c= 10000; i++ { \u003c- done } c.result() } Result 실행할 때마다 다른 값을 반환 ","date":"2021-04-15","objectID":"/easy-golang-section9/:3:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.3.2 Mutex 상호 배제 → 고루틴들이 서로 running time에 영향을 주지 않게 한다. → 단독으로 실행되게 하는 기술 여러 고루틴에서 작업하는 공유 데이터를 보호한다. sync.Mutex 선언 후 Lock, Unlock 을 사용한다. 동기화를 사용한 예제 package main import ( \"fmt\" \"runtime\" \"sync\" ) // 구조체 선언 - 여러 Go Routine 에서 접근하는 공유 데이터 type count struct { num int mutex sync.Mutex // 구조체 내부에 있기때문에 } // 공유 데이터가 변경이 되는 부분 func (c *count) increment() { // 공유 데이터 수정 전 뮤텍스로 보호 c.mutex.Lock() c.num += 1 // 공유 데이터 수정 후 보호 해제 c.mutex.Unlock() } func (c *count) result() { fmt.Println(c.num) } func main() { // 동기화 사용한 예제 // 시스템 전체 CPU 사용 runtime.GOMAXPROCS(runtime.NumCPU()) // runtime.GOMAXPROCS(1) c := count{num: 0} done := make(chan bool) for i := 1; i \u003c= 10000; i++ { go func() { c.increment() done \u003c- true runtime.Gosched() // 다른 CPU 에게 양보 }() } for i := 1; i \u003c= 10000; i++ { \u003c- done } c.result() } Result ","date":"2021-04-15","objectID":"/easy-golang-section9/:3:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.3.3 쓰기, 읽기 전용 Mutex RWMutex : 쓰기 Lock → 쓰기 시도 중에는 다른 곳에서 이전 값을 읽지 못함. 읽기 락, 쓰기 락 전부 방어(방지) RMutex : 읽기 Lock → 읽기 시도 중에 값 변경 방지. 즉 쓰기 락만 방어(방지) 동기화 사용하지 않은 경우 예제 쓰기, 읽기 동작 순서가 일정하지 않아 잘못된 오류를 반환 할 가능성 증가 package main import ( \"fmt\" \"runtime\" \"time\" ) func main() { runtime.GOMAXPROCS(runtime.NumCPU()) data := 0 go func() { for i := 1; i \u003c= 10; i++ { data += 1 fmt.Println(\"Write : \", data) time.Sleep(200 * time.Millisecond) } }() go func() { for i := 1; i \u003c= 10; i++ { fmt.Println(\"Read 1 : \", data) time.Sleep(1 * time.Second) } }() go func() { for i := 1; i \u003c= 10; i++ { fmt.Println(\"Read 2 : \", data) time.Sleep(1 * time.Second) } }() time.Sleep(5 * time.Second) } 동기화 사용 예제 package main import ( \"fmt\" \"runtime\" \"sync\" \"time\" ) func main() { // 시스템 전체 cpu 사용 runtime.GOMAXPROCS(runtime.NumCPU()) data := 0 mutex := new(sync.RWMutex) // var mutex = new (sync.RWMutex) go func() { for i := 1; i \u003c= 10; i++ { // 쓰기 뮤텍스 잠금 mutex.Lock() data += 1 fmt.Println(\"Write : \", data) time.Sleep(200 * time.Millisecond) // 쓰기 뮤텍스 잠금 해제 mutex.Unlock() } }() go func() { for i := 1; i \u003c= 10; i++ { // 읽기 뮤텍스 잠금 mutex.RLock() fmt.Println(\"Read 1 : \", data) time.Sleep(1 * time.Second) mutex.RUnlock() // 읽기 뮤텍스 해제 } }() go func() { for i := 1; i \u003c= 10; i++ { // 읽기 뮤텍스 잠금 mutex.RLock() fmt.Println(\"Read 2 : \", data) time.Sleep(1 * time.Second) mutex.RUnlock() // 읽기 뮤텍스 해제 } }() time.Sleep(10 * time.Second) } ","date":"2021-04-15","objectID":"/easy-golang-section9/:3:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.3.4 동기화 상태 메소드 동기화 상태(조건) 메소드 wait, signal , Broadcast 사용 package main import ( \"fmt\" \"runtime\" \"sync\" \"time\" ) func main() { // 시스템 전체 CPU 사용 runtime.GOMAXPROCS(runtime.NumCPU()) var mutex = new(sync.Mutex) var condition = sync.NewCond(mutex) ch := make(chan int, 5) // 비동기 버퍼 채널 for i := 0; i \u003c 5; i++ { go func(n int) { mutex.Lock() ch \u003c- 777 fmt.Println(\"GoRoutine Wait -\u003e \", n) condition.Wait() // 고 루틴 멈춤(대기) fmt.Println(\"Waiting End\", n) mutex.Unlock() }(i) } for i := 0; i \u003c 5; i++ { // \u003c- ch fmt.Println(\"Received : \", \u003c-ch ) } /*for i := 0; i \u003c 5; i++ { mutex.Lock() fmt.Println(\"Wake GoRoutine(Signal)\", i) condition.Signal() // 모든 고 루틴 생성 후 한개 씩 깨우기 mutex.Unlock() }*/ mutex.Lock() fmt.Println(\"Wake Goroutine(Broadcast)\") condition.Broadcast() mutex.Unlock() time.Sleep(2 * time.Second) } ","date":"2021-04-15","objectID":"/easy-golang-section9/:3:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.3.5 sync.Once 특정 함수를 한 번만 수행해야 할 때 sync.Once 를 사용한다. sync.Once 구조체는 다음과 같은 메서드를 제공한다. func (o *Once) Do(f func()) 한 번만 수행해야 하는 함수를 Do() 메서드의 매개변수로 전달하여 실행하면 여러 고루틴에서 실행한다 해도 해당 함수는 한 번만 수행된다. 주로 초기화에 사용된다. package main import ( \"fmt\" \"runtime\" \"sync\" \"time\" ) func onceTest() { // 이 부분에 한 번 실행 할 코드 작성 // 초기화 작업 등 fmt.Println(\"Once Test Execute!\") } func main() { runtime.GOMAXPROCS(runtime.NumCPU()) once := new(sync.Once) // Once 객체 생성 for i := 0; i \u003c 5; i++ { go func(n int) { fmt.Println(\"Go Routine -\u003e \", n) once.Do(onceTest) }(i) } time.Sleep(2 * time.Second) } Result ","date":"2021-04-15","objectID":"/easy-golang-section9/:3:5","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.3.6 sync.WaitGroup sync.WaitGroup 는 모든 고루틴이 종료될 때까지 대기해야 할 때 사용한다. sync.WaitGroup 이 제공하는 메서드 func (wg *WaitGroup) Add(delta int) : WaitGroup에 대기중인 고루틴 개수 추가 func (wg *WaitGroup) Done() : 대기 중인 고루틴의 수행이 종료되는 것을 알려줌 func (wg *WaitGroup) Wait() : 모든 고루틴이 종료 될 때까지 대기 package main import ( \"fmt\" \"sync\" ) // 고루틴 동기화 고급 - 2 func main() { wg := new(sync.WaitGroup) for i := 0; i \u003c 100; i++ { wg.Add(1) go func(n int) { fmt.Println(\"WaitGroup =\u003e \", n) wg.Done() }(i) } // Add 와 Done 횟수가 같아야한다. wg.Wait() // 대기 그룹이 끝날떄까지 기다린다. fmt.Println(\"WaitGroup End!\") } Result ","date":"2021-04-15","objectID":"/easy-golang-section9/:3:6","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"9.3.7 원자성을 보장하는 연산 원자성 atomic : 기능적으로 분할 가능한 완전 보증된 일련의 조작. 모두 성공하거나 모두 실패해야 한다. 모든 조작이 완료 될 때까지 다른 프로세스 개입이 불가하다. sync.atomic 에서 원자적 연산자를 제공한다. 주로 공용 변수에 관한 계산에 사용한다. atomic - The Go Programming Language sync/atomic 패키지가 제공하는 함수 함수 설명 AddT 특정 포인터 변수에 값을 더함 CompareAndSwapT 특정 포인터 변수의 값을 주어진 값과 비교하여 같으면 새로운 값으로 대체함 LoadT 특정 포인터 변수의 값을 가져옴 StoreT 특정 포인터 변수에 값을 저장함 SwapT 특정 포인터 변수에 새로운 값을 저장하고 이전 값을 가져옴 원자성을 사용하지 않은 경우 package main import ( \"fmt\" \"runtime\" \"sync\" ) func main() { // 원자성을 사용하지 않은 경우 예제 runtime.GOMAXPROCS(runtime.NumCPU()) var cnt int64 = 0 wg := new(sync.WaitGroup) for i := 0; i \u003c 5000; i++ { wg.Add(1) go func(n int) { cnt += 1 wg.Done() }(i) } for i := 0; i \u003c 2000; i++ { wg.Add(1) go func(n int) { cnt -= 1 wg.Done() }(i) } wg.Wait() // 대기 그룹이 끝날떄까지 기다린다. fmt.Println(\"WaitGroup End! cnt : \", cnt) } Result 공용변수 cnt에 대해 올바르지 못한 결과값이 나옴. 원자성 연산자를 사용한 경우 예제 package main import ( \"fmt\" \"runtime\" \"sync\" \"sync/atomic\" ) // 고루틴 동기화 고급 - 3 func main() { runtime.GOMAXPROCS(runtime.NumCPU()) var cnt int64 = 0 wg := new(sync.WaitGroup) for i := 0; i \u003c 5000; i++ { wg.Add(1) go func(n int) { //cnt += 1 atomic.AddInt64(\u0026cnt, 1) wg.Done() }(i) } for i := 0; i \u003c 2000; i++ { wg.Add(1) go func(n int) { //cnt -= 1 atomic.AddInt64(\u0026cnt, -1) wg.Done() }(i) } wg.Wait() // 대기 그룹이 끝날떄까지 기다린다. finalCnt := atomic.LoadInt64(\u0026cnt) fmt.Println(\"WaitGroup End! cnt : \", cnt) fmt.Println(\"WaitGroup End! cnt : \", finalCnt) } Result ","date":"2021-04-15","objectID":"/easy-golang-section9/:3:7","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 9 : Go 병행처리","uri":"/easy-golang-section9/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-13","objectID":"/easy-golang-section8/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 8 : Go 객체지향","uri":"/easy-golang-section8/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"8.1 인터페이스 ","date":"2021-04-13","objectID":"/easy-golang-section8/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 8 : Go 객체지향","uri":"/easy-golang-section8/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"8.1.1 인터페이스란 구조체가 필드들의 집합체라면 interface는 메서드들의 집합이다. 인터페이스는 타입이 구현해야 하는 메서드 원형 prototype 을 정의한다. → 추상화를 제공 디자인패턴 측면에서 client의 입장 → 인터페이스에 정의된 메소드의 동작을 보장하므로 정확한 class의 구현방법을 몰라도 된다. 클래스간의 결합도 감소 → 유지보수성 향상, 기능 추가 용이성, 독립적인 프로그래밍 가능 인터페이스를 구현하기 위해서는 해당 타입이 그 인터페이스 메서드들이 모두 구현되어야 한다. 인터페이스 선언 type 인터페이스명 interface { 메소드1() 반환 값(타입 형) 메소드2() // 반환 값이 없을 경우 } ","date":"2021-04-13","objectID":"/easy-golang-section8/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 8 : Go 객체지향","uri":"/easy-golang-section8/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"8.1.2 Empty Interface 메서드를 전혀 갖지 않는 빈 인터페이스 go에서 모든 Type을 나타내기 위해 빈 인터페이스를 사용한다. → 빈 인터페이스는 어떠한 타입도 담을 수 있는 컨테이너다. type test interface {} // 빈 인터페이스 ... var t test fmt.Println(\"Example 1\", t) // 빈(Empty) 인터페이스일 경우 Nil을 리턴한다. package main import \"fmt\" type Dog struct { name string weight int } type Cat struct { name string weight int } func printValue(s interface{}) { fmt.Println(\"Example 1 : \", s) } func main() { dog := Dog{\"poll\", 10} cat := Cat{\"bob\", 5} printValue(dog) printValue(cat) printValue(15) printValue(\"Animals\") printValue(25.5) printValue([]Dog{}) printValue([5]Dog{}) } ","date":"2021-04-13","objectID":"/easy-golang-section8/:1:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 8 : Go 객체지향","uri":"/easy-golang-section8/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"8.1.3 인터페이스 사용 인터페이스 구현 예제 package main import \"fmt\" type Dog struct { name string weight int } // bite 메소드를 구현 func (d Dog) bite() { fmt.Println(d.name, \" bites!\") } // 동물의 행동 인터페이스 선언 type Behavior interface { bite() } func main() { dog1 := Dog{\"poll\", 10} var interface1 Behavior interface1 = dog1 interface1.bite() // Example 2 dog2 := Dog{\"marry\", 12} interface2 := Behavior(dog2) interface2.bite() // Example 3 interface3 := []Behavior{dog1, dog2} // 인덱스 형태로 실행 for idx, _ := range interface3 { interface3[idx].bite() } // 값 형태로 실행(인터페이스) for _, val := range interface3 { val.bite() } } ","date":"2021-04-13","objectID":"/easy-golang-section8/:1:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 8 : Go 객체지향","uri":"/easy-golang-section8/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"8.1.3 덕타이핑 구조체 및 변수의 값이나 타입은 상관하지 않고 오로지 구현된 메소드로만 판단하는 방식 Go의 덕타이핑의 중요한 특징 오리처럼 걷고, 소리내고, 헤엄 등 행동이 같으면 오리라고 볼 수 있다. 🦆 인터페이스의 정의된 메소드 사용을 유도한다. 코드의 가독성 및 유지보수 package main import \"fmt\" type Dog struct { name string weight int } type Cat struct { name string weight int } // 구조체 Dog 메소드 구현 func (d Dog) bite() { fmt.Println(d.name, \"Dog bites!\") } func (d Dog) sounds() { fmt.Println(d.name, \"Dog barks!\") } func (d Dog) run() { fmt.Println(d.name, \"Dog is running!\") } // 구조체 Cat 메소드 구현 func (c Cat) bite() { fmt.Println(c.name, \"Cat 할퀴다!\") } func (c Cat) sounds() { fmt.Println(c.name, \"Cat cries!\") } func (c Cat) run() { fmt.Println(c.name, \"Cat is running!\") } // 동물의 행동 인터페이스 선언 type Behavior interface { bite() sounds() run() } // 인터페이스를 파라미터로 받는다. func act(animal Behavior) { animal.bite() animal.sounds() animal.run() } func main() { // Example 1 dog := Dog{\"poll\", 10} cat := Dog{\"bob\", 5} act(dog) act(cat) } ","date":"2021-04-13","objectID":"/easy-golang-section8/:1:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 8 : Go 객체지향","uri":"/easy-golang-section8/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"8.1.4 익명 인터페이스 사용 package main import \"fmt\" type Dog struct { name string weight int } type Cat struct { name string weight int } // 구조체 Dog 메소드 구현 func (d Dog) run() { fmt.Println(d.name, \"Dog is running!\") } // 구조체 Cat 메소드 구현 func (c Cat) run() { fmt.Println(c.name, \"Cat is running!\") } // 익명 인터페이스 (타입 정의 X) func act(animal interface{run()}) { animal.run() } func main() { // Example 1 dog := Dog{\"poll\", 10} cat := Dog{\"bob\", 5} act(dog) act(cat) } ","date":"2021-04-13","objectID":"/easy-golang-section8/:1:5","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 8 : Go 객체지향","uri":"/easy-golang-section8/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"8.1.5 Type Assertion 실행(런타임) 시에 인터페이스에 할당한 변수는 실제 타입으로 변환 후 사용해야 하는 경우 인터페이스.(타입) package main import ( \"fmt\" \"reflect\" ) func main() { var a interface{} = 15 b := a c := a.(int) // 실행시에 에러가 발생한다. // d := a.(float64) // panic: interface conversion: interface {} is int, not float64 fmt.Println(\"Example 1 : \", a) fmt.Println(\"Example 1 : \", reflect.TypeOf(a)) fmt.Println(\"Example 1 : \", b) fmt.Println(\"Example 1 : \", reflect.TypeOf(b)) fmt.Println(\"Example 1 : \", c) fmt.Println(\"Example 1 : \", reflect.TypeOf(c)) // fmt.Println(\"Example 1 : \", d) // Example 2 - 저장된 실제 타입 검사 if v, ok := a.(int); ok { fmt.Println(\"Example 2 : \", v, ok) } } switch 문을 활용하여 형변환 package main import \"fmt\" func checkType(arg interface{}) { // arg.(type) 을 통해서 현재 데이터형 반환 switch arg.(type) { case bool: fmt.Println(\"This is a bool\", arg) case int, int8, int16, int32, int64: fmt.Println(\"This is a int\", arg) case float32, float64: fmt.Println(\"This is a int\", arg) case string: fmt.Println(\"This is a string\", arg) case nil: fmt.Println(\"This is a nil\", arg) default: fmt.Println(\"What is this type?\", arg) } } func main() { // 실제 타입 검사 switch 사용 // 빈 인터페이스는 어떠한 자료형도 전달 받을 수 있으므로, 타입 체크를 통해 형 변환 후 사용 가능 // Example 1 checkType(true) checkType(1) checkType(22.542) checkType(nil) checkType(\"Hello Golang!\") } ","date":"2021-04-13","objectID":"/easy-golang-section8/:1:6","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 8 : Go 객체지향","uri":"/easy-golang-section8/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-08","objectID":"/easy-golang-section7/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.1 함수 기초 ","date":"2021-04-08","objectID":"/easy-golang-section7/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.1.1 함수 여러 문장을 묶어서 실행하는 코드 블럭 단위 func 키워드를 사용하여 정의한다. 타 언어와 달리 변환 값 return value 다수 가능 func 함수명(매개변수) (반환타입 or 반환 값 변수명) : 반환 값 존재 func 함수명() (반환타입 or 반환 값 변수명) : 매개변수 없음, 반환 값 존재 func 함수명(매개변수) : 매개변수 존재, 반환 값 없음 func 함수명() : 매개변수 없음, 반환값 없음 함수 사용 예제 package main import ( \"fmt\" \"strconv\" ) // 함수 선언 위치는 어느 곳이 든 가능 func helloGoLang() { // 매개변수 X, 반환값 x fmt.Println(\"Example 1 : Hello, GoLang\") } func say_one(m string) { fmt.Println(\"Example 2 : \", m) } func sum(x int, y int) int { return x + y } // 함수 기초 func main() { // Example 1 helloGoLang() // Example 2 say_one(\"Hello World!\") // Example 3 result := sum(5, 5) fmt.Println(\"Example 3 : \", result) fmt.Println(\"Example 3 : \", sum(5, 5)) fmt.Println(\"Example 3 : \", strconv.Itoa(sum(5,5))) } Result Example 1 : Hello, GoLang Example 2 : Hello World! Example 3 : 10 Example 3 : 10 Example 3 : 10 ","date":"2021-04-08","objectID":"/easy-golang-section7/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.1.2 매개변수 전달 Go에서 파라미터를 전달하는 방식 함수(콜백)전달 값 전달call by value 참조 전달call by reference 로 나뉜다. package main import \"fmt\" // 함수(콜백)전달 func sum(i int, f func(int, int)) { f(i, 10) } func add(a, b int) { fmt.Println(\"Example 1 : \", a + b) } // 값 전달call by value func multi_value(i int) { i = i * 10 } // 참조 전달call by reference func multi_reference(i *int) { *i *= 10 // *i = *i * 10 } func main() { sum(100, add) // 매개변수로 함수를 전달 // Example 2 a := 100 multi_value(a) fmt.Println(\"Example 2 : \", a) // Example 3 b := 100 multi_reference(\u0026b) fmt.Println(\"Example 3 :\", b) } Result Example 1 : 110 Example 2 : 100 Example 3 : 1000 ","date":"2021-04-08","objectID":"/easy-golang-section7/:1:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.1.3 함수의 리턴 값 Go에서는 리턴값은 복수 개도 지원한다. Multi Return Value 예제 package main import \"fmt\" func multiply(x, y int) (int, int) { return x * 10, y * 10 } func arrayMultiply(a, b, c, d, e int) (int, int, int, int, int) { return a * 1, b * 2, c * 3, d * 4, e * 5 } func main() { // 다중 값 반환 a, b := multiply(10, 5) // c := multiply(10 , 5) c, _ := multiply(10, 5) _, d := multiply(10, 5) fmt.Println(\"Example 1 :\", a, b) fmt.Println(\"Example 1 :\", c) fmt.Println(\"Example 1 :\", d) // Example 2 x1, x2, x3, x4, x5 := arrayMultiply(1, 2, 3, 4, 5) y1, _, y3, _, y5 := arrayMultiply(1, 2, 3, 4, 5) fmt.Println(\"Example 2 : \", x1, x2, x3, x4, x5) fmt.Println(\"Example 2 : \", y1, y3, y5) } Go에서는 리턴되는 값들을 (함수에 정의된) 리턴 파라미터들에 할당할 수 있다. Named Return Parameter 예제 package main import \"fmt\" func multiply(x, y int) (r1, r2 int) { r1 = x * 10 r2 = y * 20 return r1, r2 } func multiply2(x, y int) (int, int) { return x * 10, y * 20 } func main() { // 리턴 값 변수 사용 a, b := multiply(10, 5) fmt.Println(\"Example 1 : \", a, b) // Example 2 c, d := multiply2(10, 5) fmt.Println(\"Example 2 : \", c, d) } ","date":"2021-04-08","objectID":"/easy-golang-section7/:1:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.1.4 가변 인자 함수 Variadic Function 함수에 고정된 수의 파라미터를 전달하지 않고 다양한 숫자의 파라미터를 전달하고자 할때 사용 … 예약어를 사용한다. package main import \"fmt\" func multiply(n ...int) int { tot := 1 for _, value := range n { tot *= value } return tot } func sum(n ...int) int { tot := 0 for _, value := range n { tot += value } return tot } func prtWord(msg ...string) { for _, value := range msg { fmt.Println(\"Print Word -\u003e \", value) } } func main() { // 함수 고급 // 가변 인자 실습 : 매개 변수 개수가 동적으로 변할 때 - 정해져 있지 않음. // Example 1 x := multiply(5, 6, 7, 8, 9, 10) y := sum(1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13) fmt.Println(\"x -\u003e \", x) fmt.Println(\"y -\u003e \", y) fmt.Println() // Example 2 prtWord(\"A\", \"F\", \"test\", \"golang\", \"seoul\") // Example 3 a := []int{5, 6, 7, 8, 9, 10} m := multiply(a...) n := sum(a...) fmt.Println() fmt.Println(\"Slice Parameter -\u003e \", m) fmt.Println(\"Slice Parameter -\u003e\", n) } Result x -\u003e 151200 y -\u003e 91 Print Word -\u003e A Print Word -\u003e F Print Word -\u003e test Print Word -\u003e golang Print Word -\u003e seoul Slice Parameter -\u003e 151200 Slice Parameter -\u003e 45 함수를 변수에 할당 package main import \"fmt\" func multiply(x, y int) (r int) { r = x * y return r } func sum(x, y int) (r int) { r = x + y return r } func main() { // Example 1 - 슬라이스에 할당 f := []func(int, int) int {multiply, sum} a := f[0](10, 10) b := f[1](10, 10) fmt.Println(\"슬라이스에 함수 할당 -\u003e\", a, f[0](10,10)) fmt.Println(\"슬라이스에 함수 할당 -\u003e\", b, f[1](10,10)) fmt.Println() // Example 2 - 변수에 할당 var f1 func(int, int) int = multiply f2 := sum fmt.Println(\"변수에 함수 할당 -\u003e\", f1(10, 10)) fmt.Println(\"변수에 함수 할당 -\u003e\", f2(10, 10)) fmt.Println() // Example 3 - 맵에 할당 m := map[string] func(int, int) int{ \"mul_func\" : multiply, \"sum_func\" : sum, } fmt.Println(\"Map에 함수 할당\", m[\"mul_func\"](10, 10)) fmt.Println(\"Map에 함수 할당\", m[\"sum_func\"](10, 10)) } Result 슬라이스에 함수 할당 -\u003e 100 100 슬라이스에 함수 할당 -\u003e 20 20 변수에 함수 할당 -\u003e 100 변수에 함수 할당 -\u003e 20 Map에 함수 할당 100 Map에 함수 할당 20 ","date":"2021-04-08","objectID":"/easy-golang-section7/:1:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.1.5 재귀 함수 Recursion 장점 : 프로그램이 보기 쉽고, 코드가 간결, 오류 수정이 용이하다. 단점 : 코드를 이해하기 어렵고, 기억공간을 많이 사용, 무한루프 가능성이 있다. 팩토리얼 재귀함수 예제 package main import \"fmt\" func fact(n int) int { if n == 0 { return 1 } return n * fact(n - 1) } func prtHello(n int) { if n == 0 { return } fmt.Println(\"Example 2 : (\", n, \")\", \" hi!\") prtHello(n - 1) } func main() { x := fact(7) fmt.Println(\"Example 1 : \", x) // Example 2 prtHello(10) } Result Example 1 : 5040 Example 2 : ( 10 ) hi! Example 2 : ( 9 ) hi! Example 2 : ( 8 ) hi! Example 2 : ( 7 ) hi! Example 2 : ( 6 ) hi! Example 2 : ( 5 ) hi! Example 2 : ( 4 ) hi! Example 2 : ( 3 ) hi! Example 2 : ( 2 ) hi! Example 2 : ( 1 ) hi! ","date":"2021-04-08","objectID":"/easy-golang-section7/:1:5","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.1.6 익명함수 Anonymous Functions 선언과 동시에 즉시 실행 package main import \"fmt\" func main() { // Example 1 func() { fmt.Println(\"Example 1 : Anonymous Function !\") }() // Example 2 msg := \"Hello GoLang!\" func(m string) { fmt.Println(\"Example 2 : \", m) }(msg) // Example 3 func(x, y int) { fmt.Println(\"Example 3 :\", x + y) }(10, 20) // Example 4 r := func(x, y int) int { return x * y }(10, 100) fmt.Println(\"Example 4 : \", r) } Result Example 1 : Anonymous Function ! Example 2 : Hello GoLang! Example 3 : 30 Example 4 : 1000 ","date":"2021-04-08","objectID":"/easy-golang-section7/:1:6","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.2 defer ","date":"2021-04-08","objectID":"/easy-golang-section7/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.2.1 지연실행 defer defer 키워드는 특정 문장 혹은 함수를 나중에 (defer를 호출하는 함수가 리턴하기 직전) 실행한다. 일반적으로 C#, java 같은 언어에서의 finally 블럭처럼 마지막에 clean-up 작업을 위해 사용된다. 리소스 반환, 열린 파일 닫기, Mutex 잠금 해제 등 사용 package main import \"fmt\" func ex_f2() { fmt.Println(\"f2 : called!\") } func ex_f1() { fmt.Println(\"f1 : start!\") defer ex_f2() // 마지막에 호출 된다. fmt.Println(\"f1 : end!\") } func main() { ex_f1() } Result f1 : start! f1 : end! f2 : called! 익명함수 defer 예제 package main import \"fmt\" func sayHello(msg string) { defer func() { fmt.Println(msg) }() func() { fmt.Println(\"Hi !\") }() } func main() { // Example 1 sayHello(\"GoLang\") } Result Hi ! GoLang ","date":"2021-04-08","objectID":"/easy-golang-section7/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.2.2 스택 defer 키워드를 사용하면 함수가 역순으로 실행되는 것을 볼 수 있다. 자료구조의 stack 과 동일하며, 제일 나중에 지연 호출한 함수가 제일 먼저 힐행된다. 후입선출 package main import \"fmt\" func stack() { for i := 1; i \u003c= 10; i++ { defer fmt.Println(\"Example 1 : \", i) } } func main() { // Example 1. stack() } Result Example 1 : 10 Example 1 : 9 Example 1 : 8 Example 1 : 7 Example 1 : 6 Example 1 : 5 Example 1 : 4 Example 1 : 3 Example 1 : 2 Example 1 : 1 중첩 함수에 defer 키워드를 사용할 경우 주의 사항 package main import \"fmt\" func start(t string) string { fmt.Println(\"start : \", t) return t } func end(t string) { fmt.Println(\"end : \", t) } func a() { defer end(start(\"b\")) // defer 문에 있는 end()만 적용됨. 중첩 함수 주의 ! -\u003e 웬만하면 사용하지 말것. fmt.Println(\"in a\") } func main() { // Example 1 a() } Result start : b in a end : b ","date":"2021-04-08","objectID":"/easy-golang-section7/:2:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.3 Closure ","date":"2021-04-08","objectID":"/easy-golang-section7/:3:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"7.3 Closure란 익명함수는 함수를 변수에 할당할 수 있다. 함수 안에서 함수를 선언 및 정의 가능하며 이 때 외부 함수에 선언된 변수에 접근 가능하다. 함수가 선언되는 순간에 함수가 실행 될 때 실체의 외부 변수에 접근하기 위한 스냅샷(객체)이다. 함수를 호출 할 때 이전에 존재했던 값을 유지하기 위해 사용한다 비동기, 누적카운트, 무분별한 전역변수 남발을 피하기 위해 사용 전역변수 남발로 인해 메모리 부족, 오버플로우 현상, 리소스 남용을 방지 클로저를 정확하게 이해하고 사용하는 것이 중요 package main import \"fmt\" func main() { // Example 1 multiply := func(x, y int) int { // 익명함 return x * y } r1 := multiply(5, 10) fmt.Println(\"익명 함수 변수에 할당 -\u003e\", r1) // Example 2 m, n := 5, 10 // 지역변수 - 변수가 캡쳐 sum := func(c int) int { // 익명함수 변수 할당 return m + n + c // 지역 변수 소멸되지 않는다. (함수 호출 시 마다 사용 가능) } r2 := sum(10) fmt.Println(\"Closure 예제 -\u003e\", r2) } Result 익명 함수 변수에 할당 -\u003e 50 Closure 예제 -\u003e 25 카운팅 예제 package main import \"fmt\" func main() { // Example 1 cnt := increaseCnt() fmt.Println(\"Count -\u003e\", cnt()) fmt.Println(\"Count -\u003e\", cnt()) fmt.Println(\"Count -\u003e\", cnt()) fmt.Println(\"Count -\u003e\", cnt()) fmt.Println(\"Count -\u003e\", cnt()) anotherCnt := increaseCnt() fmt.Println(\"함수를 새로운 변수에 할당 시 초기화\") fmt.Println(\"Another Count -\u003e\", anotherCnt()) fmt.Println(\"Another Count -\u003e\", anotherCnt()) fmt.Println(\"Another Count -\u003e\", anotherCnt()) } func increaseCnt() func() int { n := 0 // 지역변수(캡쳐됨) return func() int { n += 1 return n } } Result Count -\u003e 1 Count -\u003e 2 Count -\u003e 3 Count -\u003e 4 Count -\u003e 5 함수를 새로운 변수에 할당 시 초기화 Another Count -\u003e 1 Another Count -\u003e 2 Another Count -\u003e 3 ","date":"2021-04-08","objectID":"/easy-golang-section7/:3:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 7 : Go 함수","uri":"/easy-golang-section7/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-04-06","objectID":"/easy-golang-section6/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.1 배열 ","date":"2021-04-06","objectID":"/easy-golang-section6/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.1 배열 배열은 용량, 길이가 항상 같다. cap() : 배열, 슬라이스 용량 len() : 배열, 슬라이스 길이 대부분은 슬라이스를 많이 사용한다. 배열과 슬라이스 차이점 배열 슬라이스 길이 고정여부 길이가 고정 되어 있다. 길이가 가변이다. 타입 여부 값 타입 참조 타입 전달 방식 값을 복사 전달 참조 값 전달 기타 전체 비교연산자 가능 전체 비교 연산자 사용 불가 배열 선언 예제 - 1 var arr1 [5]int var arr2 [5]int = [5]int{1, 2, 3, 4, 5} var arr3 = [5]int{1, 2, 3, 4, 5} arr4 := [5]int{1, 2, 3, 4, 5} arr5 := [5]int{1, 2, 3} arr6 := [...]int{1, 2, 3, 4, 5} // 배열 길이를 확신 할 수 없을 때. 잘 사용하지 않음. arr7 := [5][5]int{ {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, } arr1[2] = 5 fmt.Printf(\"%-5T %d %v\\n\", arr1, len(arr1), arr1) // %-5T 원 자료형 fmt.Printf(\"%-5T %d %v\\n\", arr2, len(arr2), arr2) fmt.Printf(\"%-5T %d %v\\n\", arr3, len(arr3), arr3) fmt.Printf(\"%-5T %d %v\\n\", arr4, len(arr4), arr4) fmt.Printf(\"%-5T %d %v\\n\", arr5, len(arr5), arr5) fmt.Printf(\"%-5T %d %v\\n\", arr6, len(arr6), arr6) fmt.Printf(\"%-5T %d %v\\n\", arr7, len(arr7), arr7) Result [5]int 5 [0 0 5 0 0] [5]int 5 [1 2 3 4 5] [5]int 5 [1 2 3 4 5] [5]int 5 [1 2 3 4 5] [5]int 5 [1 2 3 0 0] [5]int 5 [1 2 3 4 5] [5][5]int 5 [[1 2 3 4 5] [6 7 8 9 10] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]] 배열 선언 예제 - 2 arr8 := [5]int{1, 2, 3, 4, 5} arr9 := [5]int{ 1, 2, 3, 4, 5, } arr10 := [...]string{\"kim\", \"lee\", \"park\"} fmt.Printf(\"%-5T %d %v\\n\", arr8, len(arr8), arr8) fmt.Printf(\"%-5T %d %v\\n\", arr9, len(arr9), arr9) fmt.Printf(\"%-5T %d %v\\n\", arr10, len(arr10), arr10) Result [5]int 5 [1 2 3 4 5] [5]int 5 [1 2 3 4 5] [3]string 3 [kim lee park] ","date":"2021-04-06","objectID":"/easy-golang-section6/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.2 배열 순회 func main() { // 배열 순회 arr1 := [5]int{1, 10, 100, 1000, 10000} // len 길이 반복 for i := 0; i \u003c len(arr1); i++ { fmt.Println(\"Example 1 : \", arr1[i]) } arr2 := [5]int{7, 77, 777, 7777, 77777} // range for i, v := range arr2 { fmt.Println(\"Example 2 : \", i, v) } for _, v := range arr2 { fmt.Println(\"Example 3 : \", v) } for v := range arr2 { fmt.Println(\"Example 4 : \", v) // 인덱스가 출력 된다. } } Result Example 1 : 1 Example 1 : 10 Example 1 : 100 Example 1 : 1000 Example 1 : 10000 Example 2 : 0 7 Example 2 : 1 77 Example 2 : 2 777 Example 2 : 3 7777 Example 2 : 4 77777 Example 3 : 7 Example 3 : 77 Example 3 : 777 Example 3 : 7777 Example 3 : 77777 Example 4 : 0 Example 4 : 1 Example 4 : 2 Example 4 : 3 ","date":"2021-04-06","objectID":"/easy-golang-section6/:1:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.3 배열 복사 값이 복사된다. 배열은 복사하여도 서로 다른 주소값을 갖게 된다. func main() { // 배열 복사 arr1 := [5]int{1, 10, 100, 1000, 10000} arr2 := arr1 fmt.Println(\"Example 1 : \", arr1, \u0026arr1) fmt.Println(\"Example 1 : \", arr2, \u0026arr2) fmt.Printf(\"Example 1 : %p %v\\n\", \u0026arr1, arr1) fmt.Printf(\"Example 1 : %p %v\\n\", \u0026arr2, arr2) } Result Example 1 : [1 10 100 1000 10000] \u0026[1 10 100 1000 10000] Example 1 : [1 10 100 1000 10000] \u0026[1 10 100 1000 10000] Example 1 : 0xc00010c030 [1 10 100 1000 10000] Example 1 : 0xc00010c060 [1 10 100 1000 10000] ","date":"2021-04-06","objectID":"/easy-golang-section6/:1:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2 슬라이스 ","date":"2021-04-06","objectID":"/easy-golang-section6/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.1 슬라이스 길이가 가변이다. → 동적으로 크키가 늘어난다. 레퍼런스(참조 값) 타입 이다. 슬라이스(길이, 용량) 크기가 동적으로 할당이 가능하다. 부분 배열을 발췌할 수 있다. 선언 방법 배열처럼 선언한다. make 함수를 사용하여 선언한다. make 함수를 이용하면 슬라이스의 길이(length)와 용량(capacity)을 임의로 지정할 수 있다. make(자료형, 길이, 용량:생략시 길이) 슬라이스 선언 예제 - 1 // 배열 처럼 선언 var slice1 []int slice2 := []int{} slice3 := []int{1, 2, 3, 4, 5} // 슬라이스에 리터럴 값을 지정 slice4 := [][]int{ {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, } // slice2[0] = 1 // 길이가 가변형이기 때문에 초기화를 별도로 해야한다. slice3[4] = 10 // 값 수정 가능 fmt.Printf(\"%-5T %d %d %v\\n\", slice1, len(slice1), cap(slice1), slice1) fmt.Printf(\"%-5T %d %d %v\\n\", slice2, len(slice2), cap(slice2), slice2) fmt.Printf(\"%-5T %d %d %v\\n\", slice3, len(slice3), cap(slice3), slice3) fmt.Printf(\"%-5T %d %d %v\\n\", slice4, len(slice4), cap(slice4), slice4) Result []int 0 0 [] []int 0 0 [] []int 5 5 [1 2 3 4 10] [][]int 2 2 [[1 2 3 4 5] [6 7 8 9 10]] 슬라이스 선언 예제 - 2 var slice5 []int = make([]int, 5, 10) // 길이가 5이고 용량이 10인 슬라이스. 용량이 늘어날 경우에 var slice6 = make([]int, 5, 100) slice7 := make([]int, 5, 100) slice8 := make([]int, 5, 100) slice6[2] = 7 // make로 생성시 default 값으로 초기화된다. fmt.Printf(\"%-5T %d %d %v\\n\", slice5, len(slice5), cap(slice5), slice5) fmt.Printf(\"%-5T %d %d %v\\n\", slice6, len(slice6), cap(slice6), slice6) fmt.Printf(\"%-5T %d %d %v\\n\", slice7, len(slice7), cap(slice7), slice7) fmt.Printf(\"%-5T %d %d %v\\n\", slice8, len(slice8), cap(slice8), slice8) Result []int 5 10 [0 0 0 0 0] []int 5 100 [0 0 7 0 0] []int 5 100 [0 0 0 0 0] []int 5 100 [0 0 0 0 0] ","date":"2021-04-06","objectID":"/easy-golang-section6/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.2 Nil Slice 슬라이스에 별도의 길이와 용량을 지정하지 않으면 길이와 용량이 0인 슬라이스를 만든다. Nil Slice라고도 하며 nil과 비교하면 참을 리턴한다. var slice9 []int // int 슬라이스(길이와 용량이 0) if nil == slice9 { fmt.Println(\"This is Nil Slice!\") } Result This is Nil Slice! ","date":"2021-04-06","objectID":"/easy-golang-section6/:2:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.3 슬라이스와 배열 슬라이스의 경우 참조 타입이므로 값 변경시 원본 값도 같이 변경된다. // 배열 arr1 := [3]int{1, 2, 3} var arr2 [3]int arr2 = arr1 arr2[0] = 7 fmt.Println(\"Array Example 1 : \", arr1) fmt.Println(\"Array Example 1 : \", arr2) // 슬라이스 slice1 := []int{1, 2, 3} var slice2 []int slice2 = slice1 slice2[0] = 7 fmt.Println(\"Slice Example 2 : \", slice1) fmt.Println(\"Slice Example 2 : \", slice2) Result Array Example 1 : [1 2 3] Array Example 1 : [7 2 3] // 슬라이스는 참조 타입이므로 값 변경시 원본 값도 같이 변경된다. Slice Example 2 : [7 2 3] Slice Example 2 : [7 2 3] ","date":"2021-04-06","objectID":"/easy-golang-section6/:2:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.4 슬라이스 예외 make 함수로 슬라이스 초기화 시 길이 만큼 초기화 된다. slice3 := make([]int, 50, 100) fmt.Println(\"Example 3 : \", slice3[4]) // fmt.Println(\"Example 3 : \", slice3[50]) // Error ! 길이 만큼 초기화 된다. ","date":"2021-04-06","objectID":"/easy-golang-section6/:2:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.5 부분 슬라이스(Sub-slice) 슬라이스에서 일부를 발췌하여 부분 슬라이스를 만들 수 있다. 슬라이스[처음인덱스:마지막인덱스] : 처음인덱스는 inclusive 마지막인덱스는 exclusive slice[i:j] i -\u003e j-1 까지 추출 slice[i:] i -\u003e 마지막 까지 추출 slice[:j] 처음부터 -\u003e j-1 까지 추출 slice[:] 처음부터 -\u003e 마지막 까지 추출 slice1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} fmt.Println(\"Example 1 :\", slice1[:]) fmt.Println(\"Example 1 :\", slice1[0:]) fmt.Println(\"Example 1 :\", slice1[:5]) fmt.Println(\"Example 1 :\", slice1[0:len(slice1)]) fmt.Println(\"Example 1 :\", slice1[3:]) fmt.Println(\"Example 1 :\", slice1[1:3]) Result Example 1 : [1 2 3 4 5 6 7 8 9 10] Example 1 : [1 2 3 4 5 6 7 8 9 10] Example 1 : [1 2 3 4 5] Example 1 : [1 2 3 4 5 6 7 8 9 10] Example 1 : [4 5 6 7 8 9 10] Example 1 : [2 3] ","date":"2021-04-06","objectID":"/easy-golang-section6/:2:5","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.6 슬라이스 추가 append 배열은 고정된 크기로 그 크기 이상의 임의의 데이터를 추가할 수 없지만 슬라이스는 자유롭게 추가할 수 있다. 용량에 따라 용량(capacity)이 아직 남아 있는 경우 : 용량 내에서 슬라이스 길이(length)를 변경하여 데이터를 추가한다. 용량(capacity)을 초과하는 경우 : 현재 용량의 두 배에 해당하는 새로운 Underlying array을 생성하고 기존 배열 값들을 모두 새 배열에 복제한 후 다시 새로운 슬라이스를 할당한다. 슬라이스 끼리 병합할때 두번째 슬라이스 뒤에는 …(ellipsis) 을 붙인다. ellipsis는 해당 슬라이스의 컬렉션을 표현하는 것으로 두번째 슬라이스의 모든 요소들의 집합을 나타낸다. s1 := []int{1, 2, 3, 4, 5} s2 := []int{8, 9, 10, 11, 12} s3 := []int{13, 14, 15, 16, 17} fmt.Printf(\"[Example 1] s1 =\u003e %d\", cap(s1)) s1 = append(s1, 6, 7) s2 = append(s1, s2...) // 슬라이스 뒤에 슬라이스 삽입할 경우 ... 사용 s3 = append(s2, s3[0:3]...) // 추출 후 병합 fmt.Printf(\"[Example 1] s1 =\u003e %d\", cap(s1)) fmt.Println(\"[Example 1] s1 =\u003e\", s1) fmt.Println(\"[Example 1] s2 =\u003e\", s2) fmt.Println(\"[Example 1] s3 =\u003e\", s3) Result [Example 1] s1 =\u003e 5 [Example 1] s1 =\u003e [1 2 3 4 5 6 7] [Example 1] s2 =\u003e [1 2 3 4 5 6 7 8 9 10 11 12] [Example 1] s3 =\u003e [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] s4 := make([]int, 0, 5) for i := 0; i \u003c 15; i++ { s4 = append(s4, i) fmt.Printf(\"Example 2 -\u003e len : %d, cap: %d, value : %v\\n\", len(s4), cap(s4), s4) // 길이 및 용량 자동 증가 } Result Example 2 -\u003e len : 1, cap: 5, value : [0] Example 2 -\u003e len : 2, cap: 5, value : [0 1] Example 2 -\u003e len : 3, cap: 5, value : [0 1 2] Example 2 -\u003e len : 4, cap: 5, value : [0 1 2 3] Example 2 -\u003e len : 5, cap: 5, value : [0 1 2 3 4] Example 2 -\u003e len : 6, cap: 10, value : [0 1 2 3 4 5] Example 2 -\u003e len : 7, cap: 10, value : [0 1 2 3 4 5 6] Example 2 -\u003e len : 8, cap: 10, value : [0 1 2 3 4 5 6 7] Example 2 -\u003e len : 9, cap: 10, value : [0 1 2 3 4 5 6 7 8] Example 2 -\u003e len : 10, cap: 10, value : [0 1 2 3 4 5 6 7 8 9] Example 2 -\u003e len : 11, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10] Example 2 -\u003e len : 12, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10 11] Example 2 -\u003e len : 13, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10 11 12] Example 2 -\u003e len : 14, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10 11 12 13] Example 2 -\u003e len : 15, cap: 20, value : [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14] ","date":"2021-04-06","objectID":"/easy-golang-section6/:2:6","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.7 슬라이스 copy() copy(복사 대상, 원본) 반드시 초기화를 하여 공간을 할당한 후 복사 해야 한다. 복사 된 슬라이스 값을 변경해도 원본에는 영향이 없다. 부분적으로 슬라이스 추출은 참조 타입 func main() { // Example 1 slice1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} slice2 := make([]int, 5) slice3 := []int{} copy(slice2, slice1) // slice2 가 용량이 5이므로 5만 복사 copy(slice3, slice2) // 복사안됨 fmt.Println(\"Example 1 :\", slice2) fmt.Println(\"Example 1 :\", slice3) // Example 2 a := []int{1, 2, 3, 4, 5} b := make([]int, 5) copy(b, a) // 가변길이로 배열처럼 사용할 수 있다. b[0] = 7 b[4] = 10 fmt.Println(\"Example 2 : \", a) // 원본 값이 변경되지 않는다. fmt.Println(\"Example 2 : \", b) // Example 3 // 주의! 부분적으로 슬라이스 추출은 참조 -\u003e 원본 값이 변경된다. c := [5]int{1, 2, 3, 4, 5} d := c[0:3] d[1] = 7 fmt.Println() fmt.Println(\"Example 3 :\", c) fmt.Println(\"Example 3 :\", d) // Example 4 e := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} f := e[0:5:7] // 용량 지정 f[0] = 99 fmt.Println(\"Example 4 :\", e) fmt.Println(\"Example 4 :\", len(f), cap(f)) fmt.Println(\"Example 4 :\", f) } Result Example 1 : [1 2 3 4 5] Example 1 : [] Example 2 : [1 2 3 4 5] Example 2 : [7 2 3 4 10] Example 3 : [1 7 3 4 5] Example 3 : [1 7 3] Example 4 : [99 2 3 4 5 6 7 8 9 10] Example 4 : 5 7 Example 4 : [99 2 3 4 5] ","date":"2021-04-06","objectID":"/easy-golang-section6/:2:7","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.2.8 슬라이스 정렬 sort 패키지 → https://golang.org/pkg/sort package main import ( \"fmt\" \"sort\" ) func main() { slice2 := []int{3, 6, 10, 9, 1, 4, 5, 8, 2, 7} slice3 := []string{\"b\", \"d\", \"f\", \"a\", \"c\", \"e\"} fmt.Println(\"Example 2 : \", sort.IntsAreSorted(slice2)) // 정렬 확인 sort.Ints(slice2) // 정렬 fmt.Println(\"Example 2 :\", slice2) fmt.Println() fmt.Println(\"Example 2 : \", sort.StringsAreSorted(slice3)) sort.Strings(slice3) fmt.Println(\"Example 2 : \", sort.StringsAreSorted(slice3)) } Result Example 2 : false Example 2 : true ","date":"2021-04-06","objectID":"/easy-golang-section6/:2:8","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.3 맵 Map ","date":"2021-04-06","objectID":"/easy-golang-section6/:3:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.3.1 Map 키에 대응하는 값 value으로 자료를 저장하는 해시테이블을 구현한 자료구조 hashtable, dictionary-python reference 타입으로 참조값을 전달한다. 참조타입은 키로 사용 불가능하고 값으로 모든 타입을 사용 가능하다. make 함수와 축약(리터럴)로 초기화가 가능하다. var map1 map[string]int = make(map[string]int) // 정석 var map2 = make(map[string]int) // 자료형 생략 map3 := make(map[string]int) map4 := map[string]int{} // JSON 형태 // 리터럴을 사용한 초기화 map5 := map[string]int{ \"apple\" : 15, \"banana\" : 40, \"orange\" : 23, } 맵 선언 예제 package main import \"fmt\" func main() { // Example 1 var map1 map[string]int = make(map[string]int) // 정석 var map2 = make(map[string]int) // 자료형 생략 map3 := make(map[string]int) fmt.Println(\"Example 1 :\", map1) fmt.Println(\"Example 1 :\", map2) fmt.Println(\"Example 1 :\", map3) fmt.Println() // Example 2 map4 := map[string]int{} // JSON 형태 map4[\"apple\"] = 25 map4[\"banana\"] = 40 map4[\"orange\"] = 33 map5 := map[string]int{ \"apple\" : 15, \"banana\" : 40, \"orange\" : 23, } map6 := make(map[string]int, 10) map6[\"apple\"] = 25 map6[\"banana\"] = 40 map6[\"orange\"] = 23 fmt.Println(\"Example 2 : \", map4) fmt.Println(\"Example 2 : \", map5) fmt.Println(\"Example 2 : \", map6) fmt.Println(\"Example 2 : \", map6[\"apple\"]) fmt.Println(\"Example 2 : \", map4[\"banana\"]) } Result Example 1 : map[] Example 1 : map[] Example 1 : map[] \\ Example 2 : map[apple:25 banana:40 orange:33] Example 2 : map[apple:15 banana:40 orange:23] Example 2 : map[apple:25 banana:40 orange:23] \\ Example 2 : 25 Example 2 : 40 ","date":"2021-04-06","objectID":"/easy-golang-section6/:3:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.3.2 맵 조회 및 순회 (Iterator) Map이 가지고 있는 모든 요소를 출력하기 위해 for-range 루프를 사용할 수 있다. func main() { map1 := map[string]string { \"daum\" : \"https://www.daum.net\", \"naver\" : \"https://www.naver.com\", \"google\" : \"https://www.google.com\", } fmt.Println(\"Example 1 : \", map1[\"google\"]) fmt.Println(\"Example 1 : \", map1[\"daum\"]) fmt.Println() // Example 2 for k, v := range map1 { fmt.Println(\"Example 2 : \", k, v) } fmt.Println() for _, v := range map1 { fmt.Println(\"Example 2 : \", v) } } Result Example 1 : https://www.google.com Example 1 : https://www.daum.net Example 2 : google https://www.google.com Example 2 : daum https://www.daum.net Example 2 : naver https://www.naver.com Example 2 : https://www.daum.net Example 2 : https://www.naver.com Example 2 : https://www.google.com ","date":"2021-04-06","objectID":"/easy-golang-section6/:3:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.3.3 맵 사용 맵변수명[키] = 값 과 같이 해당 키에 값을 할당 할 수 있다. map안에 찾는 키가 존재하지 않는다면 참조 타입의 경우 nil 을 값 타입인 경우 0을 리턴한다. delete(삭제할 값의 키) 로 데이터를 삭제할 수 있다. package main import \"fmt\" func main() { map1 := map[string]string { \"daum\" : \"https://www.daum.net\", \"naver\" : \"https://www.naver.com\", \"google\" : \"https://www.google.com\", \"home1\" : \"http://127.0.0.1\", } fmt.Println(\"Example 1 : \", map1) map1[\"home2\"] = \"http://localhost\" // 추가 fmt.Println(\"Example 1 : \", map1) map1[\"home2\"] = \"http://127.0.0.1\" // 수정 fmt.Println(\"Example 1 :\", map1) // Example 2 - delete delete(map1, \"home2\") fmt.Println(\"Example 1 :\", map1) } ","date":"2021-04-06","objectID":"/easy-golang-section6/:3:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.3.4 맵 키 체크 Go에서는 map변수[키] 읽기를 수행할 때 두개의 리턴 값을 리턴한다. 첫번째는 키에 상응하는 값이고 두번째는 키가 존재하는지 아닌지를 나타내는 bool 값이다. package main import \"fmt\" func main() { // Example 1 map1 := map[string]int { \"apple\" : 25, \"banana\" : 115, \"orange\" : 1115, \"lemon\" : 0, } value1 := map1[\"lemon\"] value2, ok2 := map1[\"banana\"] value3, ok := map1[\"kiwi\"] fmt.Println(value1) fmt.Println(value2, \",\", ok2) fmt.Println(value3, \",\", ok) // 두 번째 리턴 값으로 키 존재 유무 확인 // Example 2 if value, ok := map1[\"kiwi\"]; ok { fmt.Println(\"Example 2 : \", value) } else { fmt.Println(\"Example 2 : kiwi is not exists\") } // 키가 존재하는지만 if _, ok := map1[\"kiwi\"]; !ok { fmt.Println(\"kiwi is not exists\") } } ","date":"2021-04-06","objectID":"/easy-golang-section6/:3:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.4 포인터 ","date":"2021-04-06","objectID":"/easy-golang-section6/:4:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.4.1 포인터 Go 언어는 포인터를 지원한다. 변수 지역성, 연속된 메모리 참조, 힙, 스택 … 주소의 값은 직접 변경이 불가능하다 → 잘못된 코딩으로 인한 버그 방지 *(asterisk) 로 사용한다. var a *int // pinter nil var b *int = new(int) 포인터 예제 - 1 package main import \"fmt\" // 자료형 포인터 1 func main() { var a *int // 방법1 var b *int = new(int) // 방법2 fmt.Println(a) // nil fmt.Println(b) i := 7 fmt.Println(\"Example 1 : \", i, \u0026i) a = \u0026i // 주소값을 전달 b = \u0026i // 주소값을 전달 fmt.Println(\"Example 1 : \", a, \u0026i) // i의 주소값, i의 주소값 fmt.Println(\"Example 1 : \", \u0026a) // i의 주소값이 저장되어있는 a의 주소값 fmt.Println(\"Example 1 : \", *a) // 역참조 fmt.Println() fmt.Println(\"Example 1 : \", b, \u0026i) fmt.Println(\"Example 1 : \", \u0026b) // i의 주소값이 저장되어있는 b의 주소값 fmt.Println(\"Example 1 : \", *b) // 역참조 var c = \u0026i d := \u0026i *d = 10 // 참조하고있는 값을 변경. fmt.Println() fmt.Println(\"Example 1 : \", c, \u0026i) fmt.Println(\"Example 1 : \", \u0026c) // i의 주소값이 저장되어있는 b의 주소값 fmt.Println(\"Example 1 : \", *c) // 역참조 fmt.Println() fmt.Println(\"Example 1 : \", d, \u0026i) fmt.Println(\"Example 1 : \", \u0026d) // i의 주소값이 저장되어있는 b의 주소값 fmt.Println(\"Example 1 : \", *d) // 역참조 } 포인터 예제 2 package main import \"fmt\" func main() { i := 7 p := \u0026i fmt.Println(\"Example 1 :\", i, *p, \u0026i, p) *p++ // 1증가 fmt.Println(\"Example 1 :\", i, *p, \u0026i, p) *p = 7777 // 포인터 변수 역 참조 값 변경 fmt.Println(\"Example 1 :\", i, *p, \u0026i, p) i = 77 fmt.Println(\"Example 1 :\", i, *p, \u0026i, p) } Result Example 1 : 7 7 0xc0000140e8 0xc0000140e8 Example 1 : 8 8 0xc0000140e8 0xc0000140e8 Example 1 : 7777 7777 0xc0000140e8 0xc0000140e8 Example 1 : 77 77 0xc0000140e8 0xc0000140e8 ","date":"2021-04-06","objectID":"/easy-golang-section6/:4:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"6.4.2 포인터 값 전달 함수, 메서드 호출시에 매개변수 값을 복사 전달 → 함수, 메서드 내에서는 원본 값 변경이 불가능하다. 원본 값 변경을 위해 포인터로 전달 크기가 큰 배열의 경우 복사시 시스템에 큰 부담 → 포인터로 전달 해결(슬라이스, 맵이 참조전달이기 때문) → 배열도 포인터 전달로 참조전달 할 수 있다. package main import \"fmt\" func rptc(n *int) { *n = 77 } func vptc(n int) { n = 77 } func main() { // Example var a int = 10 var b int = 10 fmt.Println(\"Example 1 : \", a) // 10 fmt.Println(\"Example 1 : \", b) // 10 fmt.Println() rptc(\u0026a) vptc(b) fmt.Println(\"Example 2 : \", a) // 77 fmt.Println(\"Example 2 : \", b) // 10 } ","date":"2021-04-06","objectID":"/easy-golang-section6/:4:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 6 : 배열, 슬라이스, 맵","uri":"/easy-golang-section6/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-22","objectID":"/easy-golang-section5/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.1 Bool boolean 타입 : 참, 거짓 조건부 논리 연산자와 주로 함께 사용한다. !, ||(or) \u0026\u0026(and) 암묵적인 형 변환은 불가능하다. 0, Nil → false 변환 불가능 예제 1 var b1 bool = true var b2 bool = false b3 := true // b4 := 1 // Error! fmt.Println(\"############ Example 1 ############\") fmt.Println(\"b1 : \", b1) // true fmt.Println(\"b2 : \", b2) // false fmt.Println(\"b3 : \", b3) // true fmt.Println(\"b3 == b3 :\", b3 == b3) // true fmt.Println(\"b1 \u0026\u0026 b3 :\", b1 \u0026\u0026 b3) // true fmt.Println(\"b1 || b2 :\", b1 || b2) // true fmt.Println(\"!b1 :\", !b1) // false // 암묵적인 형 변환은 일어나지 않는다. /*if b4 { fmt.Println(\"Example \", b4) }*/ 예제 2 // 논리연산자 fmt.Println(\"############ Example 1 ############\") fmt.Println(true \u0026\u0026 true) // true fmt.Println(true \u0026\u0026 false) // false fmt.Println(false \u0026\u0026 false) // false fmt.Println(true || true) // true fmt.Println(true || false) // true fmt.Println(false || false) // false fmt.Println(!true) // false fmt.Println(!false) // true // Example 2 비교연산자 num1 := 15 num2 := 37 fmt.Println(\"############ Example 2 ############\") fmt.Println(num1 \u003c num2) // true fmt.Println(num1 \u003e num2) // flase fmt.Println(num1 \u003e= num2) // false fmt.Println(num1 \u003c= num2) // true fmt.Println(num1 == num2) // false fmt.Println(num1 != num2) // true ","date":"2021-03-22","objectID":"/easy-golang-section5/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.2 numeric type ","date":"2021-03-22","objectID":"/easy-golang-section5/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.2.1 numeric 기초 정수, 실수, 복소수 32bit, 64bit, unsigned 정수 : 8진수 0 , 16진수 0x, 10진수 Example 1 var num1 int = 17 var num2 int = -68 var num3 int = 0631 var num4 int = 0x32fa2c75 fmt.Println(\"ex1 : \", num1) // 17 fmt.Println(\"ex1 : \", num2) // -68 fmt.Println(\"ex1 : \", num3) // 409 fmt.Println(\"ex1 : \", num4) // 855256181 Example 2 : 정수형 문자 출력 fmt.Printf : 포맷 출력 %c : 문자 %d : decimal %o : 8진수 %x : 16진 ASCII 영문 var char1 byte = 72 // byte (=uint8) var char2 byte = 0110 var char3 byte = 0x48 fmt.Printf(\"%c %c %c\\n\", char1, char2, char3) // H H H fmt.Printf(\"%d %d %d\\n\", char1, char2, char3) // 72 72 72 fmt.Printf(\"%d %o %x\\n\", char1, char2, char3) // 72 110 48 Unicode 한글 var char4 rune = 50556 // 유니코드 var char5 rune = 0142574 // 44032(8진수) var char6 rune = 0xC57C // 44032(16진수) fmt.Printf(\"%c %c %c\\n\", char4, char5, char6) // 야 야 야 fmt.Printf(\"%d %d %d\\n\", char4, char5, char6) // 50556 50556 50556 fmt.Printf(\"%d %o %x\\n\", char4, char5, char6) // 50556 142574 c57c ","date":"2021-03-22","objectID":"/easy-golang-section5/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.2.2 실수 - 부동소수점 float32 : 7자리 float64 : 15자리 var num1 float32 = 0.14 var num2 float32 = .75647 var num3 float32 = 442.0378373 var num4 float32 = 10.0 // 지수 표기법 var num5 float32 = 14e6 var num6 float64 = .156875E+3 var num7 float64 = 5.32521e-10 fmt.Println(\"Example 1 : \", num1) // 0.14 fmt.Println(\"Example 1 : \", num2) // 0.75647 fmt.Println(\"Example 1 : \", num3) // 442.03784 fmt.Println(\"Example 1 : \", num4) // 10 fmt.Println(\"Example 1 : \", num4 - 0.1) // 9.9 fmt.Println(\"Example 1 : \", float32(num4 - 0.1)) // 9.9 fmt.Println(\"Example 1 : \", float64(num4 - 0.1)) // 9.899999618530273 주의! fmt.Println(\"Example 1 : \", num5) // 1.4e+07 fmt.Println(\"Example 1 : \", num6) // 156.875 fmt.Println(\"Example 1 : \", num7) // 5.32521e-10 ","date":"2021-03-22","objectID":"/easy-golang-section5/:2:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.2.3 복소수 복소수 형 (complex number) complex64 : 32bit 실수 + 허수 complex128 : 64bit 실수 + 허수 Example 1 var num1 complex64 = 5 + 7i num2 := 8 + 1i num3 := complex(3, 2) //complex128 var num4 complex128 = 9 + 3i num5 := complex64(2 + 3i) fmt.Println(\"ex1 : \", num1) // (5+7i) fmt.Println(\"ex1 : \", num2) // (8+1i) fmt.Println(\"ex1 : \", num3) // (3+2i) fmt.Println(\"ex1 : \", num4) // (9+3i) fmt.Println(\"ex1 : \", num5) // (2+3i) Example 2 real() : 실수부 출력 imag() : 허수부 출력 fmt.Println(\"ex2 : \", num1, real(num1), imag(num1)) // (5+7i) 5 7 fmt.Println(\"ex2 : \", num2, real(num2), imag(num2)) // (8+1i) 8 1 fmt.Println(\"ex2 : \", num3, real(num3), imag(num3)) // (3+2i) 3 2 fmt.Println(\"ex2 : \", num4, real(num4), imag(num4)) // (9+3i) 9 3 fmt.Println(\"ex2 : \", num5, real(num5), imag(num5)) // (2+3i) 2 3 ","date":"2021-03-22","objectID":"/easy-golang-section5/:2:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.2.4 숫자 연산 숫자 연산에는 산술연산, 비교연산이 있다. 타입이 같아야 연산이 가능하다 → 다른 타입끼리는 반드시 형 변환하여 형을 맞춘 후 연산을 해야 한다. 형 변환이 없을 경우는 예외가 발생한다. 연산자 : +, -, *, /, %, \u003c\u003c, \u003e\u003e, \u0026, ^ Example 1 package main import ( \"fmt\" \"math\" ) func main() { // Example 1 var n1 uint8 = math.MaxUint8 var n2 uint16 = math.MaxUint16 var n3 uint32 = math.MaxUint32 var n4 uint64 = math.MaxUint64 fmt.Println(\"Example 1 \", n1) // 255 fmt.Println(\"Example 1 \", n2) // 65535 fmt.Println(\"Example 1 \", n3) // 4294967295 fmt.Println(\"Example 1 \", n4) // 18446744073709551615 fmt.Println(\"Example 1 \", math.MaxInt8) // 127 fmt.Println(\"Example 1 \", math.MaxInt16) // 32767 fmt.Println(\"Example 1 \", math.MaxInt32) // 2147483647 fmt.Println(\"Example 1 \", math.MaxInt64) // 9223372036854775807 fmt.Println(\"Example 1 \", math.MaxFloat32) // 3.4028234663852886e+38 fmt.Println(\"Example 1 \", math.MaxFloat64) // 1.7976931348623157e+308 } Example 2 n5 := 100000 // int n6 := int16(10000) // int16으로 형변환이 일어남 n7 := uint8(100) //n7 := uint8(300) // 예외발생 // fmt.Println(\"Example 2: \", n5 + n6) // ./numeric4.go:40:32: invalid operation: n5 + n6 (mismatched types int and int16) fmt.Println(\"Example 2 : \", n5 + int(n6)) // 110000 // fmt.Println(\"Example 2 : \", n6 + n7) fmt.Println(\"Example 2 : \", n6 + int16(n7)) // 10100 fmt.Println(\"Example 2 : \", n6 \u003e int16(n7)) // true 비교 연산자도 타입이 같아야 한다. fmt.Println(\"Example 2 : \", n6 - int16(n7) \u003e 5000) // true ","date":"2021-03-22","objectID":"/easy-golang-section5/:2:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.2.5 산술연산 import( \"fmt\" \"math\" ) func main() { var n1 uint8 = 125 var n2 uint8 = 90 fmt.Println(\"Example 1 :\", n1 + n2) //215 fmt.Println(\"Example 1 :\", n1 - n2) // 35 fmt.Println(\"Example 1 :\", n1 * n2) // 242 fmt.Println(\"Example 1 :\", n1 / n2) // 1 fmt.Println(\"Example 1 :\", n1 % n2) // 35 fmt.Println(\"Example 1 :\", n1 \u003c\u003c 2) // 244 fmt.Println(\"Example 1 :\", n1 \u003e\u003e 2) // 31 fmt.Println(\"Example 1 :\", ^n1) // 130 } Example 2 package main import( \"fmt\" \"math\" ) func main() { var n3 int = 12 var n4 float32 = 8.2 var n5 uint16 = 1024 var n6 uint32 = 120000 //정수형과 실수형 연산시 실수형에 맞추어 계산하는 것이 더 안전하다. // fmt.Println(\"Example 2 : \", n3 + n4 ) fmt.Println(\"Example 2 : \", float32(n3) + n4 ) // 20.2 fmt.Println(\"Example 2 : \", n3 + int(n4) ) // 20 fmt.Println(\"Example 2 : \", n5 + uint16(n6)) // 55488 } 산술 연산 - Error Case func main() { // Example 1 (overflows Error : 범위 초과) var n1 uint8 = math.MaxUint8 + 1 var n2 uint16 = math.MaxUint16 + 1 var n3 uint32 = math.MaxUint32 + 1 var n4 uint64 = math.MaxUint64 + 1 // Example 2 (overflows Error : 범위 초과) var n5 uint8 = -1 var n6 uint16 = -1 var n7 uint32 = -1 var n8 uint64 = -1 } ","date":"2021-03-22","objectID":"/easy-golang-section5/:2:5","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.3 문자열 ","date":"2021-03-22","objectID":"/easy-golang-section5/:3:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.3.1 문자열 큰 따옴표 \"\", 백스쿼트 ``` char 타입은 존재 하지 않는다 → **rune(int32)**로 문자 코드 값으로 표현한다. ’’ 로 작성 가능하다 자주 사용하는 escape : \\\\, \\', \\\", \\a(콘솔벨), \\b(백스페이스), \\f(쪽바꿈), \\n(줄바꿈),\\r(복귀),\\t(탭) - 역슬래시 이후에 등장하는 문자를 그대로 출력할 때 src/section5/string1.go package main import ( \"fmt\" \"unicode/utf8\" ) func main() { var str1 string = \"c:\\\\go_study\\\\src\\\\\" // c:\\go_study\\src\\ str2 := `c:\\go_study\\src\\` // escape 를 사용하지 않아도 된다. fmt.Println(\"##################################\") fmt.Println(\"Example 1 : \", str1) fmt.Println(\"Example 1 : \", str2) var str3 string = \"Hello, world!\" var str4 string = \"안녕하세요!\" var str5 string = \"\\ud55c\\uae00\" fmt.Println(\"############################\") fmt.Println(\"Example 2 : \", str3) fmt.Println(\"Example 2 : \", str4) fmt.Println(\"Example 2 : \", str5) // 길이(Byte 수), fmt.Println(\"############################\") fmt.Println(\"Example 3 : \", len(str3)) // 13 byte fmt.Println(\"Example 3 : \", len(str4)) // 16 byte // 길이(실제 길이) fmt.Println(\"############################\") fmt.Println(\"Example 4 : \", utf8.RuneCountInString(str3)) fmt.Println(\"Example 4 : \", utf8.RuneCountInString(str4)) fmt.Println(\"Example 4 : \", len([]rune(str4))) // utf8 패키지를 사용하지 않고도 문자열 길이를 구할 수 있다. } // result ############################# Example 1 : c:\\go_study\\src Example 1 : c:\\go_study\\src ############################ Example 2 : Hello, world! Example 2 : 안녕하세요! Example 2 : 한글 ############################ Example 3 : 13 Example 3 : 16 ############################ Example 4 : 13 Example 4 : 6 Example 4 : 6\\ ","date":"2021-03-22","objectID":"/easy-golang-section5/:3:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.3.2 문자열 표현 golang에서 문자열은 UTF-8 인코딩(유니코드 문자 집합)이며 한글 바이트는 3byte이다. src/section5/string2.go package main import \"fmt\" func main() { var str1 string = \"Golang\" var str2 string = \"World\" var str3 string = \"고프로그래밍\" fmt.Println(\"Example 1 : \", str1[0], str1[1], str1[2], str1[3], str1[4], str1[5]) fmt.Println(\"Example 1 : \", str2[0], str2[1], str2[2], str2[3], str2[4]) fmt.Println(\"Example 1 : \", str3[0], str3[1], str3[2], str3[3], str3[4], str3[5]) // Example 2 fmt.Println(\"########################################\") fmt.Printf(\"Example 2 : %c %c %c %c %c %c\\n\", str1[0], str1[1], str1[2], str1[3], str1[4], str1[5]) fmt.Printf(\"Example 2 : %c %c %c %c %c\\n\", str2[0], str2[1], str2[2], str2[3], str2[4]) fmt.Printf(\"Example 2 : %c %c %c %c %c %c\\n\", str3[0], str3[1], str3[2], str3[3], str3[4], str3[5]) // 한글깨짐 conStr := []rune(str3) fmt.Printf(\"Example 2 : %c %c %c %c %c %c\\n\", conStr[0], conStr[1], conStr[2], conStr[3], conStr[4], conStr[5]) // 한글 정상 출력 // Example 3 fmt.Println(\"########################################\") for i, char := range str1 { fmt.Printf(\"Example 3 : %c(%d)\\t\", char, i) } fmt.Println() fmt.Println(\"########################################\") for i, char := range str2 { fmt.Printf(\"Example 4 : %c(%d)\\t\", char, i) } } Example 1 : 71 111 108 97 110 103 Example 1 : 87 111 114 108 100 Example 1 : 234 179 160 237 148 132 ######################################## Example 2 : G o l a n g Example 2 : W o r l d Example 2 : ê ³ í\\ Example 2 : 고 프 로 그 래 밍 ######################################## Example 3 : G(0) Example 3 : o(1) Example 3 : l(2) Example 3 : a(3) Example 3 : n(4) Example 3 : g(5)\\ ######################################## Example 4 : W(0) Example 4 : o(1) Example 4 : r(2) Example 4 : l(3) Example 4 : d(4) %\\ ","date":"2021-03-22","objectID":"/easy-golang-section5/:3:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"5.3.3 문자열 연산 문자열 추출 package main import \"fmt\" func main() { var str1 string = \"Golang\" var str2 string = \"World\" fmt.Println(\"Example 1 : \", str1[0:2], str1[0]) fmt.Println(\"Example 1 : \", str2[3:], str2[0]) fmt.Println(\"Example 1 : \", str2[:4]) fmt.Println(\"Example 1 : \", str1[1:3]) } Example 1 : Go 71 Example 1 : ld 87 Example 1 : Worl Example 1 : ol 문자열 비교 package main import \"fmt\" func main() { str1 := \"Golang\" str2 := \"World\" fmt.Println(\"Example 1 : \", str1 == str2) fmt.Println(\"Example 2 : \", str1 != str2) fmt.Println(\"Example 3 : \", str1 \u003e str2) fmt.Println(\"Example 4 : \", str1 \u003c str2) // Go 문자열 -\u003e 아스키 코드에 대한 사전식 비교 } Example 1 : false Example 2 : true Example 3 : false Example 4 : true 문자열 결합 문자열 결합연산은 java와 비슷하다. (일반연산보다 StringBuffer 를 쓰는 것 처럼) package main import ( \"fmt\" \"strings\" ) func main() { // Example 1 (결합 : 일반연산) // Java 와 비슷 - Java의 경우에도 문자열 일반연산보다 StrnigBuffer 쓰는거와 비 str1 := \"This document demonstrates the development of a simple Go package inside a module and introduces the go tool\" + \"the standard way to fetch, build, and install Go modules, packages, and commands.\\n\\n\" + \"Note: This document assumes that you are using Go 1.13 or later and the GO111MODULE environment variable is not set. If you are looking for the older,\" + \"pre-modules version of this document, it is archived here.\" str2 := \"This document demonstrates the development of a simple Go package\" fmt.Println(\"Example \", str1 + str2) var strSet []string //슬라이스 선언 strSet = append(strSet, str1) strSet = append(strSet, str2) fmt.Println(\"Example 2 :\", strings.Join(strSet, \"-----\")) } ","date":"2021-03-22","objectID":"/easy-golang-section5/:3:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 5 : Go 데이터 타입","uri":"/easy-golang-section5/"},{"categories":["Elasticsearch"],"content":"개요 파일비트를 사용하여 웹 서버(nginx) 로그 파일을 수집하고 Elasticsearch Cloud에 전송한다. Cloud에서 생성한 Kibana 사이트에 접속하면 여러 플랫폼에서 데이터를 수집할 수 있는 예시 파일을 참고 할 수 있다. ","date":"2021-03-21","objectID":"/nginx-log-es-cloud/:1:0","tags":["Elastic Cloud","NGINX","Elasticsearch"],"title":"[Elastic Cloud] nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/nginx-log-es-cloud/"},{"categories":["Elasticsearch"],"content":"파일비트 설치 파일비트는 수집할 로그가 쌓이는 서버에 설치했다. cd /usr/local/src sudo curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.11.1-linux-x86_64.tar.gz tar xzvf filebeat-7.11.1-linux-x86_64.tar.gz cd filebeat-7.11.1-linux-x86_64 ","date":"2021-03-21","objectID":"/nginx-log-es-cloud/:1:1","tags":["Elastic Cloud","NGINX","Elasticsearch"],"title":"[Elastic Cloud] nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/nginx-log-es-cloud/"},{"categories":["Elasticsearch"],"content":"Elastic Cloud 인증정보 설정 Elastic Cloud 접속을 위하여 filebeat.yml의 관련항목의 주석을 해제하고 인증정보를 설정한다. 그 외 필요한 설정 정보는 아래 링크를 참조한다. Configuration filebeat.yml filebeat.yml # =============================== Elastic Cloud ================================ # These settings simplify using Filebeat with the Elastic Cloud (https://cloud.elastic.co/). # The cloud.id setting overwrites the `output.elasticsearch.hosts` and # `setup.kibana.host` options. # You can find the `cloud.id` in the Elastic Cloud web UI. cloud.id: \"\u003cCLOUD_ID\u003e\" # The cloud.auth setting overwrites the `output.elasticsearch.username` and # `output.elasticsearch.password` settings. The format is `\u003cuser\u003e:\u003cpass\u003e`. cloud.auth: \"\u003cCLOUD_USER\u003e:\u003cCLOUD_PASS\u003e\" cloud.id : 연결하려는 elastic cloud 아이디를 복사하여 넣는다. cloud id는 메인화면에서 확인 가능하다. cloud.auth : 항목에는 “user:pass” 형태로 basic authentication 형태로 작성한다. ","date":"2021-03-21","objectID":"/nginx-log-es-cloud/:1:2","tags":["Elastic Cloud","NGINX","Elasticsearch"],"title":"[Elastic Cloud] nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/nginx-log-es-cloud/"},{"categories":["Elasticsearch"],"content":"filebeat input 설정 엘라스틱서치로 전송할 input 파일 정보를 설정한다. 특별한 설정을 하지 않고 filebeat의 nginx 모듈을 활성화 한 경우 nginx의 기본 로그 폴더가 자동으로 설정된다. /var/log/nginx/access.log*, /var/log/nginx/error.log* 등 특정 로그 디렉토리를 설정하려면 직접 input 설정에 경로를 지정해야 한다. filebeat.yml # ============================== Filebeat inputs =============================== filebeat.inputs: # Each - is an input. Most options can be set at the input level, so # you can use different inputs for various configurations. # Below are the input specific configurations. - type: log # Change to true to enable this input configuration. enabled: true # Paths that should be crawled and fetched. Glob based paths. paths: - /home/riley/logs/*.log - /home/riley/logs/tomcat/*.log #- c:\\programdata\\elasticsearch\\logs\\* # Exclude lines. A list of regular expressions to match. It drops the lines that are # matching any regular expression from the list. #exclude_lines: ['^DBG'] # Include lines. A list of regular expressions to match. It exports the lines that are # matching any regular expression from the list. #include_lines: ['^ERR', '^WARN'] # Exclude files. A list of regular expressions to match. Filebeat drops the files that # are matching any regular expression from the list. By default, no files are dropped. #exclude_files: ['.gz$'] # Optional additional fields. These fields can be freely picked # to add additional information to the crawled log files for filtering #fields: # level: debug # review: 1 ### Multiline options # Multiline can be used for log messages spanning multiple lines. This is common # for Java Stack Traces or C-Line Continuation # The regexp Pattern that has to be matched. The example pattern matches all lines starting with [ #multiline.pattern: ^\\[ # Defines if the pattern set under pattern should be negated or not. Default is false. #multiline.negate: false # Match can be set to \"after\" or \"before\". It is used to define if lines should be append to a pattern # that was (not) matched before or after or as long as a pattern is not matched based on negate. # Note: After is the equivalent to previous and before is the equivalent to to next in Logstash #multiline.match: after filebeat.inputs.enabled : true 로 설정 filebeat.inputs.path : 사용자 지정 nginx 로그 경로 형식을 작성한다. ","date":"2021-03-21","objectID":"/nginx-log-es-cloud/:1:3","tags":["Elastic Cloud","NGINX","Elasticsearch"],"title":"[Elastic Cloud] nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/nginx-log-es-cloud/"},{"categories":["Elasticsearch"],"content":"Output 설정 filebeat.yml # ================================== Outputs =================================== # Configure what output to use when sending the data collected by the beat. # ---------------------------- Elasticsearch Output ---------------------------- output.elasticsearch: # Array of hosts to connect to. hosts: [\"\u003cENDPOINT\u003e\"] # Protocol - either `http` (default) or `https`. protocol: \"https\" 파일은 Elasticsearch Cloud로 전송할 것이기 때문에 Elasticsearch 정보를 설정한다. host : Elasticsearch cloud의 endpoint protocol : endpoint가 ssl이 적용되어있는 경우 https로 설정한다. ","date":"2021-03-21","objectID":"/nginx-log-es-cloud/:1:4","tags":["Elastic Cloud","NGINX","Elasticsearch"],"title":"[Elastic Cloud] nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/nginx-log-es-cloud/"},{"categories":["Elasticsearch"],"content":"filebeat 설정 적용 및 실행 filebeat nginx 모듈 활성화 sudo ./filebeat modules enable nginx filebeat 실행 sudo ./filebeat -e 403 ERROR 일 경우 ","date":"2021-03-21","objectID":"/nginx-log-es-cloud/:1:5","tags":["Elastic Cloud","NGINX","Elasticsearch"],"title":"[Elastic Cloud] nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/nginx-log-es-cloud/"},{"categories":["Elasticsearch"],"content":"Kibana 실행 Cloud에 있는 Kibana를 실행하게 되면 파일비트로 전송된 nginx Log를 확인 할 수 있다. filebeat-* 형식으로 인덱스 패턴이 자동으로 등록된다. ","date":"2021-03-21","objectID":"/nginx-log-es-cloud/:1:6","tags":["Elastic Cloud","NGINX","Elasticsearch"],"title":"[Elastic Cloud] nginx 로그를 Elasticsearch Cloud로 수집하기","uri":"/nginx-log-es-cloud/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-19","objectID":"/easy-golang-section4/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 4 : Go 패키지 기초","uri":"/easy-golang-section4/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"4.1 Go 패키지 Go의 패키지는 코드 구조화(모듈화) 및 재사용 기능을 제공한다. 응집도, 결합도를 느슨하게 해야 유지보수가 쉽고 가독성이 좋아진다. 클린코드 Go는 패키지를 사용해서 작은 단위의 컴포넌트를 작성하고 이러한 작은 패키지를 결합해서 프로그램을 작성할 것을 권고하고 있다. 패키지이름 = 디렉토리 이름 같은 패키지 내 소스파일들은 디렉토리명을 패키지명으로 사용한다. 네이밍 규칙 : 소문자 private 대문자 public Go에서 main 패키지는 특별하게 인식된다 → 컴파일러에서는 프로그램의 시작점 start point로 인식한다. package main // 선언 방법1 /*import \"fmt\" import \"os\"*/ // 선언 방법2 import ( \"fmt\" \"os\" ) func main() { var name string fmt.Println(\"이름은 ? : \") fmt.Scanf(\"%s\", \u0026name) fmt.Fprintf(os.Stdout, \"Hi! %s\\n\", name) } ","date":"2021-03-19","objectID":"/easy-golang-section4/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 4 : Go 패키지 기초","uri":"/easy-golang-section4/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"4.1.1 패키지 사용 section4/lib/lib.go package lib import \"fmt\" // 변수 초기화 func init() { fmt.Println(\"lib Package \u003e init Start!!\") } func CheckNum(c int32) bool { return c \u003e 10 } section4/package2.go package main import ( \"fmt\" \"section4/lib\" ) func main () { fmt.Println(\"10보다 큰 수 ? \", lib.CheckNum(4)) } ","date":"2021-03-19","objectID":"/easy-golang-section4/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 4 : Go 패키지 기초","uri":"/easy-golang-section4/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"4.2 접근제어 및 Alias ","date":"2021-03-19","objectID":"/easy-golang-section4/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 4 : Go 패키지 기초","uri":"/easy-golang-section4/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"4.2.1 패키지 접근 제어 변수, 상수, 함수, 메서드, 구조체 등 식별자 첫글자 대문자 : 패키지 외부에서 접근 가능 첫글자 소문자 : 패키지 외부에서 접근 불가. 해당 패키지 내에서만 접근 가능 section4/lib2/lib.go package lib2 func CheckNum1(c int32) bool { return c \u003e 100 } func CheckNum2(c int32) bool { return c \u003e 1000 } section4/access1.go package main import ( \"fmt\" \"section4/lib2\" ) func main() { fmt.Println(\"100 보다 큰 수 ?\", lib2.CheckNum1(101)) fmt.Println(\"1000 보다 큰 수 ?\", lib2.CheckNum2(999)) } ","date":"2021-03-19","objectID":"/easy-golang-section4/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 4 : Go 패키지 기초","uri":"/easy-golang-section4/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"4.2.2 별칭 사용 및 빈 식별자 사용 package main import ( \"fmt\" checkUp \"section4/lib\" _ \"section4/lib2\" ) func main() { fmt.Println(\"10보다 큰 수? : \", checkUp.CheckNum(11)) } ","date":"2021-03-19","objectID":"/easy-golang-section4/:2:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 4 : Go 패키지 기초","uri":"/easy-golang-section4/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"4.3 초기화 메소드 init ","date":"2021-03-19","objectID":"/easy-golang-section4/:3:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 4 : Go 패키지 기초","uri":"/easy-golang-section4/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"4.3.1 init 패키지 로드시에 가장 먼저 호출 된다. 가장 먼저 초기회 되는 작업 작성 시 유용하다. package main import ( \"fmt\" ) func init() { fmt.Println(\"Init Method Start!\") } func main() { fmt.Println(\"Main Method Start!\") } ","date":"2021-03-19","objectID":"/easy-golang-section4/:3:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 4 : Go 패키지 기초","uri":"/easy-golang-section4/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"4.3.2 초기화 메소드 실행 순서 section4/lib/lib.go package lib import \"fmt\" // 변수 초기화 func init() { fmt.Println(\"lib Package \u003e init Start!!\") } func CheckNum(c int32) bool { return c \u003e 10 } init 메소드는 여러개 지정할 수 있다. (보통은 잘 사용하지 않음) 다른 패키지에서 imort 할 때 init 메소드가 실행된다. package main import ( \"fmt\" _ \"section4/lib\" ) func init() { fmt.Println(\"Init1 Method Start! \") } func init() { fmt.Println(\"Init2 Method Start! \") } func init() { fmt.Println(\"Init3 Method Start! \") } func init() { fmt.Println(\"Init4 Method Start! \") } func main() { fmt.Println(\"Main Method Start!\") } ## 결과 lib Package \u003e init Start!! Init1 Method Start! Init2 Method Start! Init3 Method Start! Init4 Method Start! Main Method Start! ","date":"2021-03-19","objectID":"/easy-golang-section4/:3:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 4 : Go 패키지 기초","uri":"/easy-golang-section4/"},{"categories":["Elasticsearch"],"content":"개요 Elastic Cloud로 데이터 마이그레이션하기 A to Z filebeat, logstash 는 데이터 소스가 있는 시스템에 설치하고, Elasticsearch, Kinaba 는 Elastic Cloud 로 세팅하여 사용한다. 엘라스틱서치 운영 모니터링 까지 Elastic Cloud 에서 모두 지원하기 때문에 따로 구성하지 않아도 된다. ","date":"2021-03-17","objectID":"/es-cloud/:1:0","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"Elastic Cloud 구조 ","date":"2021-03-17","objectID":"/es-cloud/:1:1","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"작업 목표 On-promise로 구성되어 있는 검색어 키워드를 Elastic Cloud 환경으로 이관한다. 추후에 맵으로 시각화 할 수 있도록 기존 데이터에 location(latitude, longitude)를 추가한다. ","date":"2021-03-17","objectID":"/es-cloud/:2:0","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"현재 시스템 구성 현재 구성되어 있는 검색어 키워드 인덱스 명 → wini_srch_kwrd_hist-yyyymm ES_MASTER 서버에서 로그스태시가 매일 09:00 마다 키워드 테이블을 조회하여 엘라스틱서치에 저장시키고 있다. 현재 로그스태시 및 구성 문서 : 기간별 키워드 검색 추가를 위한 선행 작업(링크) ","date":"2021-03-17","objectID":"/es-cloud/:3:0","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"작업 진행 내용 ","date":"2021-03-17","objectID":"/es-cloud/:4:0","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"1. Raw 데이터 검색 쿼리 - 전일 키워드 히스토리를 가져오는 SQL ","date":"2021-03-17","objectID":"/es-cloud/:4:1","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"2. ES 템플릿을 등록한다 v_countrycd의 경우 사실 keyword 필드는 필요없다. (현재 반영되어 있는게 v_countrcyd.keyword 필드를 바라보고 있어서 따로 수정은 못함) location은 lat, lon 의 Object 형태의 goe_point로 설정한다. template 생성 JSON PUT _template/keyword_template { \"index_patterns\": [\"kwrd_hist-*\"], \"settings\": { \"index\" : { \"analysis\" : { \"filter\" : { \"english_stop\" : { \"type\" : \"stop\", \"stopwords\" : \"_english_\" }, \"filter_shingle\" : { \"max_shingle_size\" : \"3\", \"token_separator\" : \" \", \"output_unigrams\" : true, \"type\" : \"shingle\" } }, \"normalizer\": { \"default_normalizer\": { \"type\" : \"custom\", \"filter\" : [\"lowercase\", \"asciifolding\"] } }, \"analyzer\" : { \"default_analyzer\" : { \"type\" : \"custom\", \"tokenizer\" : \"standard\", \"filter\" : [\"lowercase\", \"filter_shingle\", \"asciifolding\"] } } } } }, \"mappings\": { \"properties\": { \"seq\" : { \"type\" : \"long\" }, \"v_countrycd\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\", \"fields\": { \"keyword\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\" } } }, \"v_keyword\" : { \"type\" : \"text\", \"analyzer\" : \"default_analyzer\", \"search_analyzer\": \"default_analyzer\", \"fields\": { \"keyword\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\" } } }, \"v_usercd\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\" }, \"v_userid\" : { \"type\" : \"keyword\", \"normalizer\": \"default_normalizer\" }, \"location\" : { \"type\" : \"geo_point\" }, \"reg_dtm\" : { \"type\" : \"date\" } } } } ","date":"2021-03-17","objectID":"/es-cloud/:4:2","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"iso_alpha2 데이터를 가지고 lat, lon 정보를 세팅하는 dictionary 파일을 생성한다. 데이터 소스에서 국가코드는 2자리로만 수집하고 있다.(V_COUNTRYCD) 이 국가코드로 특정 위치를 알아내기 위해 국가코드를 키로하고 값으로 lat, lon 정보를 Object로 갖는 사전을 구성해야 한다. JSON은 더블 쿼테이션이나 형식이 복잡해지므로 간결하게 yml로 구성하였다. --- AD: iso_alpha2: AD iso_alpha3: AND latitude: 42.546245 longitude: 1.601554 country_name: Andorra AE: iso_alpha2: AE iso_alpha3: ARE latitude: 23.424076 longitude: 53.847818 country_name: United Arab Emirates AF: iso_alpha2: AF iso_alpha3: AFG latitude: 33.93911 longitude: 67.709953 country_name: Afghanistan .... (생략) // 내용이 많아 파일로 첨부 ","date":"2021-03-17","objectID":"/es-cloud/:4:3","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"4. 데이터를 가공하여 Elastic Cloud로 전송하도록 로그스태시를 설정한다. 최초 데이터 ~ 어제 데이터까지 한 번만 인입하는 로그 스태시 설정 input { jdbc { jdbc_validate_connection =\u003e true jdbc_connection_string =\u003e \"오라클접속정보\" jdbc_user =\u003e \"생략\" jdbc_password =\u003e \"생략\" jdbc_driver_library =\u003e \"/usr/share/logstash/lib/ojdbc6.jar\" jdbc_driver_class =\u003e \"Java::oracle.jdbc.driver.OracleDriver\" #use_column_value =\u003e true #schedule =\u003e \"0 9 * * *\" statement_filepath =\u003e \"쿼리 파일 위치\" last_run_metadata_path =\u003e \"/elastic/logstash/.meta\" } } filter { mutate { copy =\u003e {\"seq\" =\u003e \"[@metadata][_id]\"} copy =\u003e {\"target_yymm\" =\u003e \"[@metadata][target_yymm]\"} remove_field =\u003e [\"@version\", \"target_yymm\"] } # 국가코드로 lat, lon 정보 세팅 translate { field =\u003e \"v_countrycd\" destination =\u003e \"mapdata\" dictionary_path =\u003e \"/home/elastic/data/country_dic.yml\" fallback =\u003e nil } if [mapdata][latitude] and [mapdata][longitude] { mutate { add_field =\u003e [\"[location][lat]\", \"%{[mapdata][latitude]}\"] add_field =\u003e [\"[location][lon]\", \"%{[mapdata][longitude]}\"] remove_field =\u003e [\"mapdata\"] convert =\u003e [\"[location][lat]\", \"float\"] convert =\u003e [\"[location][lon]\", \"float\"] } } } output { stdout { codec =\u003e \"rubydebug\" } elasticsearch { cloud_id =\u003e [\"생략\"] } } ","date":"2021-03-17","objectID":"/es-cloud/:4:4","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"filter \u003e translate plugin translate { field =\u003e \"v_countrycd\" destination =\u003e \"mapdata\" dictionary_path =\u003e \"/home/elastic/data/country_dic.yml\" fallback =\u003e nil } v_countrycd 값을 가지고 country_dic.yml 데이터를 참고하여 latitude값과 longitude 값을 가져와mapdata라는 임시 필드에 저장시킨다. fallback 에는 매핑되지 못했을 경우 nill 값으로 리턴한다. ","date":"2021-03-17","objectID":"/es-cloud/:4:5","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"filter \u003e mutate if [mapdata][latitude] and [mapdata][longitude] { mutate { add_field =\u003e [\"[location][lat]\", \"%{[mapdata][latitude]}\"] add_field =\u003e [\"[location][lon]\", \"%{[mapdata][longitude]}\"] remove_field =\u003e [\"mapdata\"] convert =\u003e [\"[location][lat]\", \"float\"] convert =\u003e [\"[location][lon]\", \"float\"] } } 사전데이터에 존재하는 데이터의 경우 location 오브젝트의 lat 값에 latitude를 lon 값에 longitude 값을 저장한다. 임시 필드 mapdata는 삭제한다. 필드 데이터 타입을 float로 변경해준다. ","date":"2021-03-17","objectID":"/es-cloud/:4:6","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"output output { stdout { codec =\u003e \"rubydebug\" } elasticsearch { cloud_id =\u003e [\"클라우드아이디\"] } } output에는 Elastic Cloud 정보를 적어준다. cloud_id cloud_auth on-promise 에서는 host를 적었는데 cloud의 경우는 cloud id와 인증정보만 추가하면 된다. cloud_auth에서 : 형식이므로 password를 적지 않도록 keystore를 생성해서 처리하는 방식을 검색해보았지만 잘 안나와서 기본 예제에 따름… ","date":"2021-03-17","objectID":"/es-cloud/:4:7","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"5. 로그스태시 실행 ","date":"2021-03-17","objectID":"/es-cloud/:4:8","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"매일 오전 9시마다 데이터 수집하도록 logstash 설정 추가 ","date":"2021-03-17","objectID":"/es-cloud/:5:0","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"스케쥴링 용 logstash Config 파일 추가 # 아래 부분만 주석 해제 schedule =\u003e \"0 9 * * *\" ","date":"2021-03-17","objectID":"/es-cloud/:5:1","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"pipeline.yml 수정 이전 on-promise의 경우 -f 옵션을 주어 하나의 config 파일을 실행하였는데, 당분간은 on-promise 와cloud에 각각 데이터를 쌓아야 하 기 때문에 pipeline.yml을 이용하여 로그스태시를 실행 시키도록 한다. ","date":"2021-03-17","objectID":"/es-cloud/:5:2","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"데이터 실행 쉘 스크립트 수정 f 옵션을 제거하고 pipelines.yml을 기준으로 로그스태시를 실행 시킬 수 있도록 실행 옵션을 추가한다. /home/elastic/logstash-datapump/tmp/script/logstash-service.shCOMMAND='/home/elastic/logstash-datapump/bin/logstash --path.settings=/home/elastic/logstash- datapump/config' 적재 데이터 확인 키바나에서 어제까지의 데이터가 들어와 있음 성공^ᄋ^ ","date":"2021-03-17","objectID":"/es-cloud/:6:0","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"Alias 등록을 위한 스크립트 설정 검색 이력 인덱스는 “인덱스명-yyyyMMdd” 형태로 관리되고 있다. 별칭으로 전체 기간의 인덱스를 조회할 수 있도록 설정해야한다. 00시마다 크론탭에 의해 월이 넘어갔을때 신규인덱스에 별칭을 추가하도록 한다. 이전에 기록했던 설정 정보 : ALIAS 등록 스크립트 이전 스크립트에 elastic cloud 정보를 추가하도록 한다. ","date":"2021-03-17","objectID":"/es-cloud/:7:0","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"1. alias API 사용 권한을 갖는 API 키 발행 Kibana \u003e Management \u003e Dev Tools 에서 API Key를 추가한다. index는 alias에 등록될 인덱스 패턴과 별칭명도 추가해주어야 하는 것같다. privileges는 manage 로 설정한다. POST /_security/api_key { \"name\" : \"APIKey 이름\", \"role_descriptors\": { \"es-manager\" : { \"cluster\" : [\"all\"], \"index\" : [ { \"names\" : [\"인덱스 패턴\", \"별칭명\"], \"privileges\" : [\"manage\"]} ] } } } Kiabana \u003e Stack Management \u003e API Keys 키가 추가가 잘되었는지 확인 ","date":"2021-03-17","objectID":"/es-cloud/:7:1","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["Elasticsearch"],"content":"2. 크론스크립트에 Cloud로 API를 요청하는 로직을 추가 #!/bin/bash # 2020.07.22 Riley # 2021.03.17 Riley : Add Elastic Cloud Setting FILE_LAST_MONTH=/home/elastic/logstash-datapump/tmp/last-alias-month.txt FILE_LAST_MONTH_CLOUD=/home/elastic/logstash-datapump/tmp/last-alias-month-cloud.txt THIS_MONTH=$(date '+%Y%m') LAST_MONTH=THIS_MONTH # Elastic Cloud LAST_MONTH=THIS_MONTH if [ ! -f \"$FILE_LAST_MONTH_CLOUD\" ]; then touch \"$FILE_LAST_MONTH_CLOUD\"; echo $(date '+%Y%m' --date=\"1 months ago\") \u003e $FILE_LAST_MONTH_CLOUD; fi while read TMP2; do LAST_MONTH=$TMP2; done \u003c $FILE_LAST_MONTH_CLOUD; if [ $((LAST_MONTH)) -lt $((THIS_MONTH)) ]; then RES_CODE=$(curl -o /dev/null -w \"%{http_code}\" -d \"{\\\"actions\\\":[{\\\"add\\\":{\\\"index\\\":\\\" 인덱스명-${THIS_MONTH}\\\",\\\"alias\\\":\\\"별칭명\\\"}}]}\" \\ -H \"Content-Type: application/json\" -H \"Authorization: ApiKey\u003c 여기에 API Key넣기\u003e \" -X POST https://엘라스틱 클라우드 주소/_aliases) echo $RES_CODE if [ $RES_CODE -eq 200 ]; then echo $THIS_MONTH \u003e $FILE_LAST_MONTH_CLOUD; fi fi ","date":"2021-03-17","objectID":"/es-cloud/:7:2","tags":["Elastic Cloud","Elasticsearch"],"title":"[Elastic Cloud] Elastic Cloud로 이관 작업","uri":"/es-cloud/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-17","objectID":"/easy-golang-section3/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.1 조건문 ","date":"2021-03-17","objectID":"/easy-golang-section3/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.1.1 조건문 IF if 문은 반드시 Boolean 형으로 검사해야 한다. 다른 언어처럼 1, 0 으로 조건문을 사용할 수 없다 → 자동 형변환 불가 소괄호는 사용하지 않는다. func main() { var a int = 20 b := 20 if a \u003e= 15 { fmt.Println(\"15 이상이다\") } if b \u003e= 25 { fmt.Println(\"25 이상이다\") } if c := 40; c \u003e= 35 { fmt.Println(\"35 이상\") } } Error Case // 에러 발생 1 if b \u003e= 25 { } // 에러 발생 2 if b \u003e= 25 fmt.Println(\"25이상\") ","date":"2021-03-17","objectID":"/easy-golang-section3/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.1.2 else func main() { var a int = 50 b := 70 // 예제 1 if a \u003e= 65 { fmt.Println(\"65 이상\") } else { fmt.Println(\"65 미만\") } if b \u003e= 70 { fmt.Println(\"70 이상\") } else { fmt.Println(\"70 미만\") } } ","date":"2021-03-17","objectID":"/easy-golang-section3/:1:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.1.3 else if func main() { i := 100 // if - else if 예제 1 if i \u003e= 120 { fmt.Println(\"120 이상\") } else if i \u003e= 100 \u0026\u0026 i \u003c 120 { fmt.Println(\"100 이상 120 미만\") } else if i \u003c 100 \u0026\u0026 i \u003e= 50 { fmt.Println(\"50 이상 100 미만\") } else { fmt.Println(\"50 미만\") } } ","date":"2021-03-17","objectID":"/easy-golang-section3/:1:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.2 조건문 switch switch 뒤 표현식은 생략이 가능하다. case 뒤 표현식 사용 가능 자동 break 때문에 fallthrough 존재 Type 분기 → 값이 아닌 변수 type 으로 분기 가능하다. ","date":"2021-03-17","objectID":"/easy-golang-section3/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"Switch 기본사용법 func main() { a := -7 switch { case a \u003c 0: fmt.Println(a, \"는 음수\") case a == 0: fmt.Println(a, \"는 0\") case a \u003e 0: fmt.Println(a, \"는 양수\") } } // 결과 // -7는 음수 func main() { switch b := 27; { case b \u003c 0: fmt.Println(b, \"는 음수\") case b == 0: fmt.Println(b, \"는 0\") case b \u003e 0: fmt.Println(b, \"는 양수\") } } // 결과 // 27는 양수 func main() { switch c := \"go\"; c { case \"go\": fmt.Println(\"Go!\") case \"java\" : fmt.Println(\"Java!\") default: fmt.Println(\"일치하는 값 없음\") } } // 결과 // Go! func main() { switch c := \"go\"; c + \"lang\" { case \"golang\": fmt.Println(\"Go lang\") case \"java\": fmt.Println(\"java\") default: fmt.Println(\"none\") } } // 결과 // Go lang func main() { switch i, j := 20, 30; { case i \u003c j : fmt.Println(\"i는 j보다 작다.\") case i == j : fmt.Println(\"i는 j는 같다.\") case i \u003e j : fmt.Println(\"i와 j보다 크다.\") } } // 결과 // i는 j보다 작다. ","date":"2021-03-17","objectID":"/easy-golang-section3/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"랜덤 값을 가지고 switch 문으로 범위 출력하기 package main import ( \"fmt\" \"math/rand\" \"time\" ) func main() { // Example 1 rand.Seed(time.Now().UnixNano()) switch i := rand.Intn(100); { case i \u003e= 50 \u0026\u0026 i \u003c 100: fmt.Println(\"i -\u003e \", i, \" 50 이상 100 미만\") case i \u003e= 25 \u0026\u0026 i \u003c 50: fmt.Println(\"i -\u003e \", i, \" 25 이상 50 미만\") default: fmt.Println(\"i -\u003e \", i, \" 기본 값\") } } ","date":"2021-03-17","objectID":"/easy-golang-section3/:2:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"Example 3 package main import \"fmt\" func main() { // Example 1 a := 30 / 15 switch a { case 2, 4, 6: // i가 2, 4, 6 인 경우 fmt.Println(\"a -\u003e \", a, \"는 짝수\") case 1, 3, 5: fmt.Println(\"a -\u003e \", a, \"는홀수\") } } ","date":"2021-03-17","objectID":"/easy-golang-section3/:2:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"fallthrough fallthrough를 사용하면 하나의 case 문을 거친 뒤, 그 다음 case 문 내용을 이어서 실행하는 동작이 가능하다. func main() { switch e := \"go\"; e { case \"java\": fmt.Println(\"Java!\") fallthrough case \"go\": fmt.Println(\"go!\") fallthrough case \"python\": fmt.Println(\"python!\") case \"ruby\": fmt.Println(\"ruby!\") fallthrough case \"c\": fmt.Println(\"c!\") } } // 결과 // go! // python! ","date":"2021-03-17","objectID":"/easy-golang-section3/:2:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.3 반복문 for Go에서 for는 유일하게 제공하는 반복문이다. ","date":"2021-03-17","objectID":"/easy-golang-section3/:3:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.1 반복문 사용법 반복문 기본 사용법 for i := 0; i \u003c 5; i++ { fmt.Println(\"EX1 : \", i) } 무한 루프 // java -\u003e while(true) {} for { fmt.Println(\"EX2 : Hello Go Lang \") fmt.Println(\"EX2 : Infinite Loop! \") } Range 사용하기 loc := []string {\"Seoul\", \"Busan\", \"Incheon\"} for index, name := range loc { // 첫번째 인자 - 인덱스, 두번째 인자 - 값 fmt.Println(\"EX 3 : \", index, name) } // index를 생략하고 싶으면 for _, name := range loc { fmt.Println(\"EX 3 : \", name) } ","date":"2021-03-17","objectID":"/easy-golang-section3/:3:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.2 반복문의 여러가지 사용 패턴 Example 1 sum1 := 0 for i := 0; i \u003c= 100; i++ { sum1 += 1 // sum := sum + 1 } fmt.Println(\"EX1 : \", sum1) // 결과 // EX1 : 101 Example 2 // Example 2 sum2, i := 0, 0 for i \u003c= 100 { sum2 += i i++ // j := i++ (X) GO 에서는 후치연산은 반환이 안된다. } fmt.Println(\"EX2 : \", sum2) // 결과 // EX2 : 5050 j := i++ Go에서는 후치연산은 반환이 안되기 때문에 j에 i++ 값을 대입할 수 없다. ","date":"2021-03-17","objectID":"/easy-golang-section3/:3:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.3 while 처럼 사용하기 sum3, i := 0, 0 for { // while 형태와 비 if i \u003e 100 { break } sum3 += i i++ } fmt.Println(\"EX3 : \", sum3) // 결과 // EX3 : 5050 for i, j := 0, 0; i \u003c= 10; i, j = i + 1, j + 10 { fmt.Println(\"EX4 : \", i, j) } // 결과 // EX4 : 1 10 // EX4 : 2 20 // EX4 : 3 30 // .... // Ex4 : 10 100 ","date":"2021-03-17","objectID":"/easy-golang-section3/:3:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"3.4 GO 문법 특징 ","date":"2021-03-17","objectID":"/easy-golang-section3/:4:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"GO 문법 특징 1 모호하거나, 애매한 문법 금지 후치(후위) 연산자는 허용하나 i++ 전치(전위) 연산자는 비허용 ++i (X) 증감연산자는 반환값이 없음 sum := i++ (X) 포인터를 허용한다. 포인터 연산은 비허용 주석 // , /**/ func main() { // Example 1 sum, i := 0, 0 for i \u003c= 100 { // sum += i++ // 예외 발생 sum += i i++ // ++i (전위증감 비허용) } fmt.Println(\"Example 1 : \", sum) } ","date":"2021-03-17","objectID":"/easy-golang-section3/:4:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"GO 문법 특징 2 문장 끝 세미콜론 ; 주의 자동으로 Go 컴파일러가 끝에 세미콜론을 삽입 두 문장을 한 문장으로 표현할 경우 명시적으로 세미콜론을 사용 - (권장하지 않는다.) 반복문 및 제어문(조건문) if, for를 사용할 경우 주의 해야 한다. func main() { // Example 1 for i := 0; i \u003c= 10; i++ { // fmt.Println(\"Example 1 : \", i);fmt.Println(\"i\") fmt.Print(\"Example 1 : \") fmt.Println(i) } // Example 2 for j := 10; j \u003e= 0; j-- { fmt.Println(\"Example 2 : \", j) } } ","date":"2021-03-17","objectID":"/easy-golang-section3/:4:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"GO 문법 특징 3 코드 서식을 지정해주는 유틸을 내장하고 있다. 한 사람이 코딩한 것 같은 일관성을 유지해준다. 코드 스타일을 유지해준다. # 사용법 gofmt -h # 원본 파일에 코드 스타일을 반영 gofmt -w ","date":"2021-03-17","objectID":"/easy-golang-section3/:4:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 3 : Go 제어문 및 반복문","uri":"/easy-golang-section3/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-13","objectID":"/easy-golang-section2/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"2.1 변수 및 상수 ","date":"2021-03-13","objectID":"/easy-golang-section2/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"변수 선언 GO 언어는 자료형을 정적으로 검사하므로 변수에 자료형이 정해져 있다. 정적 자료형을 지원하지만 자료형 선언 할당하는 번거로움을 벗어나게 해주는 자료형 추론 기능이 있다. 정수 타입 0, 실수 0.0, 문자열 “”, boolean (true, false) 변수 명의 첫 글자는 숫자로 시작해서는 안된다. 대소문자는 구분하며 문자, 숫자, 밑줄, 특수기호로 변수명 선언이 가능하다. var a int var b string var c, d, e int var f, g, h int = 1, 2, 3 var i float32 = 11.4 var j string = \"Hi! Golang!\" var k = 4.74 // 선언과 동시 초기화 var l = \"Hi Seoul!\" var m = true a = 4 b = \"Hello Go!\" e = 77 ","date":"2021-03-13","objectID":"/easy-golang-section2/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"여러 변수 동시 선언 // 변수 여러개를 선언 var ( name string = \"machine\" height int32 weight float32 isRunning bool ) height = 250 weight = 350.56 isRunning = true ","date":"2021-03-13","objectID":"/easy-golang-section2/:1:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"자료형 추론(짧은 선언) Go 언어에서는 자료형이 무엇인지 알 수 있는 경우에는 자료형을 쓰지 않아도 된다. 함수 내에서만 사용 가능하다 → 전역으로는 사용 불가 주로 제한된 범위의 함수에서 사용할 경우 코드의 가독성을 높일 수 있다. func main() { shortVar1 := 3 shortVar2 := \"Test\" shortVar3 := false // shortVar :=3 true // 예외 발생 } ","date":"2021-03-13","objectID":"/easy-golang-section2/:1:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"IF 문에서 짧은 선언 사용시 // Example if i := 10; i \u003c 11 { fmt.Println(\"Short Variable Test Success\") } ","date":"2021-03-13","objectID":"/easy-golang-section2/:1:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"상수 상수는 변수와 달리 한 번 선언 후에는 값을 변경할 수 없다. 고정 된 값을 관리할 때 사용한다. 상수는 선언과 동시에 할당이 되어야 한다. ","date":"2021-03-13","objectID":"/easy-golang-section2/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"상수를 선언하는 방법 const a string = \"Test1\" const b = \"Test2\" const c int32 = 10 * 10 // const d = getHeight() // 함수 결과값을 할당하는 경우 예외 발생. 함수 사용할 수 없다. const e = 35.6 const f = false /* 에러 발생이 되는 경우 const g string g = \"Test3\" // 상수는 선언과 동시에 할당이 되어야 한다. */ ","date":"2021-03-13","objectID":"/easy-golang-section2/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"여러 상수 동시 선언 const a, b int = 10, 99 const c, d, e = true, 0.84, \"test\" const ( x, y int16 = 50, 90 i, k = \"Data\", 7776 ) ","date":"2021-03-13","objectID":"/easy-golang-section2/:2:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"열거형 - Enumeration 열거형은 상수를 사용하는 일정한 규칙에 따라 숫자를 계산 및 증가시키는 묶음이다. func main() { const ( Jan = 1 Feb = 2 Mar = 3 Apr = 4 May = 5 Jun = 6 ) fmt.Println(Jan, Feb, Mar, Apr, May, Jun) // Output // 1 2 3 4 5 6 } ","date":"2021-03-13","objectID":"/easy-golang-section2/:3:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"iota 키워드 iota는 상수 선언에서 사용할 수 있는 예약어로 연속적인 정수 상수 0, 1, 2, … 를 나타낸다. 시작값은 0이고 이후부터는 +1 증가된 값으로 선언된다. func main() { const ( A = iota * 10 B C ) fmt.Println(A, B, C) // Output: // 0 10 20 } ","date":"2021-03-13","objectID":"/easy-golang-section2/:3:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"중간 값 스킵하기 중간 값을 스킵하려면 _ 를 사용하여 중간 값을 스킵할 수 있다. func main() { const ( _ = iota A _ C ) fmt.Println(A, C) // Output // 1 3 const ( _ = iota + 0.75 * 2 DEFAULT SILVER _ PLATINUM ) fmt.Println(\"D : \", DEFAULT) fmt.Println(\"S : \", SILVER) // fmt.Println(\"G : \", GOLD) // 사용하는 코드는 수정해야 한다. fmt.Println(\"P : \", PLATINUM) // Output // D : 2.5 // S : 3.5 // P : 5.5 } ","date":"2021-03-13","objectID":"/easy-golang-section2/:3:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 2 : Go 기초 문법","uri":"/easy-golang-section2/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":" 인프런 쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정 강의 정리 ","date":"2021-03-08","objectID":"/easy-golang-section1/:0:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"1. 개발 환경 설정하기 The Go Programming Language ","date":"2021-03-08","objectID":"/easy-golang-section1/:1:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"설치 단계 Golang 설치 하기 (Golang, Git) IDE 툴 설치 (atom) GOPATH Setting 설정 및 프로젝트 디렉토리 생성 Go 설치 확인하기 ","date":"2021-03-08","objectID":"/easy-golang-section1/:1:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"1.1 Golang 설치하기 https://golang.org/에서 인스톨러로 설치한다. ","date":"2021-03-08","objectID":"/easy-golang-section1/:1:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"1.2 IDE 툴 설치 - ATOM https://atom.io 로 Editor 를 설치한다. Shell Commands 를 설정하여 터미널 어디서나 atom 명령어로 atom을 실행 command + i : 실행 opriton + d : go doc을 쉽게 ","date":"2021-03-08","objectID":"/easy-golang-section1/:1:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"1.3 환경 변수 등록하기 GOROOT : GO가 설치 된 실제 경로. 기본적으로 /usr/local/go 로 설정되어 있음 GOPATH : GO 프로젝트가 저장될 경로 GOBIN : 실행가능한 파일들이 지정되는 경로 vi ~/.bash_profile # go export GOPATH=$HOME/study/go export GOBIN=$GOPATH/bin export PATH=/usr/local/go/bin:$GOPATH:$GOPATH/bin:$PATH # 적용 source ~/.bash_profile ","date":"2021-03-08","objectID":"/easy-golang-section1/:1:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"1.4 GO 설치 확인하기 go env ","date":"2021-03-08","objectID":"/easy-golang-section1/:1:5","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"2. 작업 공간 설정하기 Git으로 작업 공간 설정하기 작업 디렉터리(GOPATH) 작성하기 작업 공간 내의 실행 파일들에 PATH 설정하기 패키지와 라이브러리 설치하기 ","date":"2021-03-08","objectID":"/easy-golang-section1/:2:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"2.1 Git 설치하기 기본적으로 제공되는 도구들을 내려받으려면 git이 필요하다. golang.org 아래에 있는 소스들이 git으로 접근하기 때문 ","date":"2021-03-08","objectID":"/easy-golang-section1/:2:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"2.2 작업 디렉터리(GO PATH) 작성하기 mkdir -p ~/study/go cd ~/study/go bin : 실행가능한 파일이 저장되는 곳. install 을 했을 때 실행가능한 파일이 생성된다. pkg : 패키지 오브젝트 파일이 들어간다. 소스가 컴파일된 후의 코드들이 여기에 위치. 실행가능한 파일들을 아니며 라이브러리들이 들어간다고 생각하면 된다. src : 소스 코드들이 들어간다. bin 디렉터리에 대한 PATH 추가하기 ","date":"2021-03-08","objectID":"/easy-golang-section1/:2:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"2.3 ATOM 설정 유용한 패키지 설치하기 go-plus platformio-ide-terminal script File \u003e Add Proejct Folder … 프로젝트로 작업할 디렉터리 선택 ","date":"2021-03-08","objectID":"/easy-golang-section1/:2:3","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"2.4 내 컴퓨터에서 코드 작성해보기 mkdir -p $GOPATH/src/section1 nano $GOPATH/src/section1/helloworld.go package main import \"fmt\" func main() { fmt.Println(\"Hello world!!\") } go run 바로 실행 ","date":"2021-03-08","objectID":"/easy-golang-section1/:2:4","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"go build 실행 가능한 파일을 생성 단위 테스트 할 때 유용 go install install 할 경우 의존과 관련된 모든 라이브러리들을 포함하여 bin 디렉토리에 실행 가능한 파일을 생성한다. ","date":"2021-03-08","objectID":"/easy-golang-section1/:2:5","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"패키지와 라이브러리 하나의 패키지는 메인 패키지 혹은 라이브러리 패키지가 될 수 있다. 메인 패키지의 경우 실행 파일이 bin 아래에 생성된다. ","date":"2021-03-08","objectID":"/easy-golang-section1/:3:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"패키지를 import 하기 import \"github.com/riley817/gogo/hanoi\" 패키지 안에 대문자로 시작하는 함수는 모두 hanoi.Move 와 같이 접근이 가능하다 다른 패키지에서 함수를 이용할 수 없게 하려면 첫 글자를 소문자로 작성한다. ","date":"2021-03-08","objectID":"/easy-golang-section1/:3:1","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"예제1 src/github.com/riley817/gogo/seq/seq.go // Package seq implements functions for well-known sequences like Fibonacci. package seq // Fib returns nth (from 0th) Fibonacci number. func Fib(n int) int { p, q := 0, 1 for i := 0; i \u003c n; i++ { p, q = q, p+q } return p } /src/github.com/riley817/gogo/seq/cmd/fib/fib.go package main import( \"fmt\" \"github.com/riley817/gogo/seq\" ) func main() { fmt.Println(seq.Fib(6)) } go run fib.go no required module provides package github.com/riley817/gogo/seq: working directory is not part of a module 메세지와 함께 빌드가 되지 않았다… github.com/riley817/gogo/seq 해당 의존성을 찾지 못해 빌드가 되지 못했고 go get 명령어를 통해 의존성을 받아온다. go get go run fib.go ","date":"2021-03-08","objectID":"/easy-golang-section1/:3:2","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"라이브러리 정렬 및 코드 규칙 여러 패키지들이 들어 있을 때 gofmt 가 자동으로 알파벳 순서로 정렬을 하며 중간에 빈 칸으로 구분되어 있으면 따로 정렬이 일어난다. 패키지 이름은 소문자로만 간결하게 붙이도록 한다. 패키지 내 함수 이름도 간결하게 붙인다. util과 같은 일반적인 이름도 피하는 것이 좋다. https://blog.golang.org/package-names ","date":"2021-03-08","objectID":"/easy-golang-section1/:4:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"도구 사용하기 godoc : Go 프로그램의 문서를 볼 수 있는 도구 Oracle : 소스 코드에 대하여 여러 가지를 물어볼 수 있는 강력한 도구 Vet : 소스 코드 검사 도구 Fix : 이미 변경된 옛 API 호출 등을 자동으로 고쳐주는 도구 Test : 테스트를 수행하는 도구 ","date":"2021-03-08","objectID":"/easy-golang-section1/:5:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"godoc godoc 은 Go 프로그램의 문서를 볼 수 있는 도구이다. command에서 확인할 수 있고 웹서버로 확인할 수도 있다. -src 를 붙이면 패키지나 함수의 소스 코드도 볼 수 있다. go doc fmt go doc fmt Printf go doc cmd/go go doc -src fmt go doc -src fmt Printf -http 옵션을 주면 웹 서버를 돌릴 수 있다. godoc -http=:6060 ","date":"2021-03-08","objectID":"/easy-golang-section1/:6:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"GO 오픈소스의 문서를 모아둔 사이트 Home · pkg.go.dev ","date":"2021-03-08","objectID":"/easy-golang-section1/:7:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정"],"content":"Oracle Oracle은 소스 코드에 대하여 여러 가지를 물어볼 수 있는 매우 강력한 도구이다. 사용법이 어렵기 때문에 편집기와 연동하여 쓰는 것을 권장한다. ","date":"2021-03-08","objectID":"/easy-golang-section1/:8:0","tags":["GO"],"title":"[쉽고 빠르게 끝내는 GO언어 프로그래밍 핵심 기초 입문 과정] Section 1 : 개발 환경 설정","uri":"/easy-golang-section1/"},{"categories":["Elasticsearch"],"content":"VM 세팅 ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:1:0","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Elasticsearch"],"content":"리소스 그룹 생성 --location 으로 리젼을 선택할 수 있다. # 리젼 코드 조회하기 az account list-locations -o table # elastic Resource Group 생성 az group create --name elastic --location koreasouth ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:1:1","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Elasticsearch"],"content":"VM 생성하기 elastic 그룹에 VM 을 생성한다. yoon@Azure:~$ az vm create \\ \u003e --resource-group elastic \\ \u003e --name rileyVM \\ \u003e --image UbuntuLTS \\ \u003e --admin-username riley \\ \u003e --generate-ssh-keys 빠른 시작: Azure CLI를 사용하여 Linux VM 만들기 - Azure Virtual Machines ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:1:2","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Elasticsearch"],"content":"SSH 접속 세팅 VM 생성 시 --generate-ssh-ke 의 옵션을 주어 SSH Key를 생성하였다. SSH Private Key 다운로드방법 클라우드 쉘을 실행 후 명령어 창에 파일 다운로드를 선택한다. /.ssh/id_rsa PK 가 저장된 위치를 입력 후 다운로드 버튼 클릭한다. 접속 시 private Key를 사용하여 접속하도록 설정한다. Moba X Term ~/.ssh/config 설정 Host riley-azure HostName {IP 주소} User {유저명} Port {SSH 포트} PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_azure ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:1:3","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Elasticsearch"],"content":"VM에 Elasticsearch 와 Kibana 를 설치하기 Azure 레퍼런스에 잘 정리되어 있다. 👻 Azure의 개발 가상 머신에서 ElasticSearch 배포 - Azure Virtual Machines ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:2:0","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Elasticsearch"],"content":"Elasticsearch, Kibana 보안설정하기 Elasticsearch와 Kibana를 외부에서도 접근하고 싶다면 보안 설정을 해주어야 한다. ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:3:0","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Elasticsearch"],"content":"Elasticsearch와 Kibana host 설정 외부 IP로 접근이 가능하도록 host를 0.0.0.0 로 설정한 후 각각 서비스를 restart 한다. ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:3:1","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Elasticsearch"],"content":"elasticsearch.yml 설정 /etc/elasticsearch/elasticsearch.yml node.name에 노드 이름을 지어준다. network.host: 0.0.0.0 으로 설정해야 외부 IP에서 방화벽이 열려있는 경우 접근 할 수 있다. cluster.initial_master_nodes: [\"node-1\"] 엘라스틱서치를 여러개 돌릴경우 각각의 노드이름을 지정해주어야 한다. # ======================== Elasticsearch Configuration ========================= # # NOTE: Elasticsearch comes with reasonable defaults for most settings. # Before you set out to tweak and tune the configuration, make sure you # understand what are you trying to accomplish and the consequences. # # The primary way of configuring a node is via this file. This template lists # the most important settings you may want to configure for a production cluster. # # Please consult the documentation for further information on configuration options: # https://www.elastic.co/guide/en/elasticsearch/reference/index.html # # ---------------------------------- Cluster ----------------------------------- # # Use a descriptive name for your cluster: # #cluster.name: my-application # # ------------------------------------ Node ------------------------------------ # # Use a descriptive name for the node: # node.name: node-1 # # Add custom attributes to the node: # #node.attr.rack: r1 # # ----------------------------------- Paths ------------------------------------ # # Path to directory where to store the data (separate multiple locations by comma): # path.data: /var/lib/elasticsearch # # Path to log files: # path.logs: /var/log/elasticsearch # # ----------------------------------- Memory ----------------------------------- # # Lock the memory on startup: # #bootstrap.memory_lock: true # # Make sure that the heap size is set to about half the memory available # on the system and that the owner of the process is allowed to use this # limit. # # Elasticsearch performs poorly when the system is swapping the memory. # # ---------------------------------- Network ----------------------------------- # # Set the bind address to a specific IP (IPv4 or IPv6): # network.host: 0.0.0.0 # # Set a custom port for HTTP: # #http.port: 9200 # # For more information, consult the network module documentation. # # --------------------------------- Discovery ---------------------------------- # # Pass an initial list of hosts to perform discovery when this node is started: # The default list of hosts is [\"127.0.0.1\", \"[::1]\"] # discovery.seed_hosts: [\"127.0.0.1\"] # # Bootstrap the cluster using an initial set of master-eligible nodes: # cluster.initial_master_nodes: [\"node-1\"] # # For more information, consult the discovery and cluster formation module documentation. # # ---------------------------------- Gateway ----------------------------------- # # Block initial recovery after a full cluster restart until N nodes are started: # #gateway.recover_after_nodes: 3 # # For more information, consult the gateway module documentation. # # ---------------------------------- Various ----------------------------------- # # Require explicit names when deleting indices: # #action.destructive_requires_name: true ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:3:2","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Elasticsearch"],"content":"kibana.yml 설정 /etc/kibana/kibana.yml server.host에 0.0.0.0으로 설정해준다. # Kibana is served by a back end server. This setting specifies the port to use. #server.port: 5601 # Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values. # The default is 'localhost', which usually means remote machines will not be able to connect. # To allow connections from remote users, set this parameter to a non-loopback address. server.host: \"0.0.0.0\" ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:3:3","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Elasticsearch"],"content":"Azure 인바운드 설정하기 홈 \u003e 가상 머신 \u003e {가상머신 이름} \u003e 설정 \u003e 네트워킹 특정 IP에서만 접근 가능하도록 IP 추가 지정할 포트가 여러개인 경우 , 로 여러개를 나열하면 된다. ","date":"2021-01-22","objectID":"/azure-vm-elastic-stack/:3:4","tags":["Azure","Elasticsearch","Elastic Cloud","FileBeat"],"title":"Azure VM에 Elastic Stack 설정","uri":"/azure-vm-elastic-stack/"},{"categories":["Docker/Kubernetes"],"content":"docker 다운로드 및 이미지 생성 docker에서 내려 받을 수 있는 mysql 버전 확인 : https://hub.docker.com/_/mysql/ 버전을 명시 하지 않으면 가장 최신 버전을 다운로드하게 됨 # docker pull sudo docker pull mysql:8 # docker 이미지 확인 sudo docker images docker Mysql 컨테이너 생성 및 실행 # mysql 컨테이너 생성 및 실행 sudo docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=PASSWORD --name mysql8 -v /usr/riley/datadir:/var/lib/mysql mysql:8 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci # 실행된 컨테이너 확인 sudo docker ps -a MySql 컨테이너 bash 쉘 접속하여 MySQL 에 접속하기 # 컨테이너 bash 쉘 접속 sudo docker exec -it mysql8 bash # mysql 접속 mysql -u root -p 데이터베이스의 유저를 생성하고 권한 부여 % : 모든 접속을 허용. mysql\u003e CREATE USER 'riley'@'%' IDENTIFIED BY '패스워드'; Query OK, 0 rows affected (0.01 sec) mysql\u003e GRANT ALL PRIVILEGES ON *.* TO 'riley'@'%'; Query OK, 0 rows affected (0.00 sec) mysql\u003e flush privileges; Query OK, 0 rows affected (0.00 sec) ","date":"2020-05-30","objectID":"/docker-mysql/:0:1","tags":["Docker"],"title":"[Doker] Doker로 MySQL 설치하기","uri":"/docker-mysql/"},{"categories":["Git"],"content":"git submodule 삭제하기 1. .gitmodules를 열어 해당 서브 모듈이 정의된 부분을 제거하거나 파일을 지운다. .gitmodules에 불필요한 모듈만 제거하거나 .gitmodules 파일이 불필요하다면 아예 삭제해 버린다. 2. .git/config 파일을 열어 불필요한 서브 모듈을 삭제한다. vi PROJECT_ROOT/.git/config 3. 해당 저장소의 캐시를 제거한다. # git rm --cached path_to_submodule git rm --cached spring-module-common 4. .git/modules/path_to_submodule 파일을 삭제한다. cd PROJECT_ROOT/.git/modules rm --rf spring-module-common 5. 변경된 사항을 커밋 한다. ","date":"2020-05-24","objectID":"/git-submodule/:1:0","tags":["Git"],"title":"[Git] git submodule 삭제하기","uri":"/git-submodule/"},{"categories":["Git"],"content":"참고 https://git.wiki.kernel.org/index.php/GitSubmoduleTutorial#Removal ","date":"2020-05-24","objectID":"/git-submodule/:2:0","tags":["Git"],"title":"[Git] git submodule 삭제하기","uri":"/git-submodule/"},{"categories":["Git"],"content":".gitignore .gitignore에 의도적으로 추적을 원하지 않는 파일을 무시하도록 지정할 수 있다. 그러나 git이 이미 추적을 한 파일은 영향을 받지 않는다. 이미 한번 추적이 된 파일을 .gitignore 파일에 적용하려면 아래와 같이 캐시를 삭제해 주어야 한다. git rm -r --cached . git add . git commit -m \"Apply .gitignore\" git push ","date":"2020-05-11","objectID":"/git-ignore/:1:0","tags":["Git"],"title":"[Git] gitignore 적용하기","uri":"/git-ignore/"},{"categories":["Etc"],"content":"nginx 컴파일 설치하기 CentOS 7에서 NGINX를 컴파일 버전으로 설치한다. 컴파일 설치를 하기 위해서는 몇 가지 라이브러리가 필요하다. 필요 의존 라이브러리는 openssl, pcre, zlib 등이 필요하므로 먼저 설치한다. ","date":"2020-05-06","objectID":"/nginx-compile/:1:0","tags":["NGINX"],"title":"[NGINX] CentOS 7에서 nginx 컴파일 설치하기","uri":"/nginx-compile/"},{"categories":["Etc"],"content":"컴파일을 위한 라이브러리 설치 # pcre 라이브러리 설치 yum install pcre* # gzip 압축을 사용하기 위해서 설치 yum install zlib zlib-devel # open ssl 설치 yum install openssl openssl-devel # gcc 설치 yum install gcc ","date":"2020-05-06","objectID":"/nginx-compile/:1:1","tags":["NGINX"],"title":"[NGINX] CentOS 7에서 nginx 컴파일 설치하기","uri":"/nginx-compile/"},{"categories":["Etc"],"content":"nginx 소스 파일을 다운로드 최신 버전 경로는 아래 url에 접속하여 원하는 버전 링크를 복사한다. http://nginx.org/en/download.html cd /usr/local/src # 원하는 버전 다운로드 wget http://nginx.org/download/nginx-1.14.0.tar.gz # 압축해제 tar xzf nginx-1.14.0.tar.gz ","date":"2020-05-06","objectID":"/nginx-compile/:1:2","tags":["NGINX"],"title":"[NGINX] CentOS 7에서 nginx 컴파일 설치하기","uri":"/nginx-compile/"},{"categories":["Etc"],"content":"컴파일 –prefix에 nginx 루트 경로를 설정한다. 자세한 컴파일 옵션은 nginx Document를 참고한다. http://nginx.org/en/docs/configure.html ./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_gzip_static_module --with-http_flv_module --with-http_mp4_module --with-http_realip_module --with-http_v2_module --user=riley --group=riley # 컴파일 후 인스톨 make \u0026\u0026 make install ","date":"2020-05-06","objectID":"/nginx-compile/:1:3","tags":["NGINX"],"title":"[NGINX] CentOS 7에서 nginx 컴파일 설치하기","uri":"/nginx-compile/"},{"categories":["Etc"],"content":"실행 스크립트 생성 # nginx-start.sh #!/bin/sh /usr/local/nginx/sbin/nginx # nginx-stop.sh #!/bin/sh /usr/local/nginx/sbin/nginx -s stop # nginx-reload.sh #!/bin/sh /usr/local/nginx/sbin/nginx -s reload chmod +x nginx-*.sh ","date":"2020-05-06","objectID":"/nginx-compile/:1:4","tags":["NGINX"],"title":"[NGINX] CentOS 7에서 nginx 컴파일 설치하기","uri":"/nginx-compile/"},{"categories":["Etc"],"content":"nginx CORS 활성화 하기 nginx에서 CORS(Cross-Origin Resource Sharing) 설정을 활성화한다. ","date":"2020-05-06","objectID":"/nginx-cors/:1:0","tags":["NGINX"],"title":"[NGINX] nginx CORS 활성화 하기","uri":"/nginx-cors/"},{"categories":["Etc"],"content":"nginx 설정파일 # # Wide-open CORS config for nginx # location / { if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; # # Custom headers and headers various browsers *should* be OK with but aren't # add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'; # # Tell client that this pre-flight info is valid for 20 days # add_header 'Access-Control-Max-Age' 1728000; add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; return 204; } if ($request_method = 'POST') { add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'; add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range'; } if ($request_method = 'GET') { add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'; add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range'; } } ","date":"2020-05-06","objectID":"/nginx-cors/:1:1","tags":["NGINX"],"title":"[NGINX] nginx CORS 활성화 하기","uri":"/nginx-cors/"},{"categories":["Java"],"content":" 자바 기본 잊지 않게 정리하기! 🤔 ","date":"2020-04-19","objectID":"/thread/:0:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"프로세스와 스레드 프로세스(process) : 운영체제에서 실행 중인 하나의 애플리케이션을 의미 멀티 태스킹(multi tasking) 운영 체제에서 두 가지 이상의 다중 작업(프로세스)를 동시에 처리하는 것을 의미. 운영 체제에서는 멀티 태스킹을 할 수 있도록 CPU 및 메모리 자원을 적절히 할당하고 병렬로 실행시킨다. 할당받은 메모리를 가지고 실행하기 때문에 독립적이다. ","date":"2020-04-19","objectID":"/thread/:1:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"메인 스레드 자바 애플리케이션은 메인 스레드(main thread)가 main() 메소드를 실행 하면서 시작. 메인 스레드는 필요에 따라 작업 스레드를 만들어 병렬로 실행 가능하다. 싱글 스레드에서는 메인 스레드가 종료되면 프로세스가 종료되지만, 멀티 스레드 애플리케이션에서는 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다. ","date":"2020-04-19","objectID":"/thread/:2:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"작업 스레드 생성과 실행 자바에서는 스레드도 객체(클래스)로 생성된다. ","date":"2020-04-19","objectID":"/thread/:3:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"implements runnable Runnable : 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체 인터페이스 타입이므로 run()을 재정의하여 실행 코드를 작성 Thread thread = new Thread(Runnable target); start() : 작업스레드는 매개값으로 받은 Runnable의 run() 메소드를 실행한다. Runnable task = new Task(); Thread thread = new Thread(task); /* Ruunable 익명 객체 */ Thread thread = new Thread(new Runnable() { @Override public void run() { // 스레드가 실행할 코드 } }); /* Java8 람다식 */ Thread thread = new Thread(() -\u003e { // 스레드가 실행할 코드 }); // 작업 스레드 실행 thread.start(); ","date":"2020-04-19","objectID":"/thread/:3:1","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"extends thread Thread 클래스를 상속한 후 run 메소드를 재정의(overriding)해서 스레드가 실행할 코드를 작성 public class WorkerThread extends Thread { @Override public void run() { // 스레드가 실행할 코드 } } Thread thread = new WorkerThread(); /* 익명의 자식 객체로 생성 */ Thread thread = new Thread() { @Override public void run() { // 스레드가 실행할 코드 } }; ","date":"2020-04-19","objectID":"/thread/:3:2","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"implements Runnable vs extends Thread 자바에서는 다중 상속을 허용하지 않기 때문에 extends Thread의 경우 다른 클래스의 상속을 받을 수 없다. 인터페이스의 경우 다중 상속이 가능하기 때문에 다른 클래스를 상속 받을 수 있다. 그러므로 implements Runnable을 통해 재 정의하여 확장하는 경우가 많다. ","date":"2020-04-19","objectID":"/thread/:4:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"스레드의 이름 스레드는 자신의 이름을 setName()로 변경한다. 스레드 객체의 참조가 필요한 경우 Thread.currentThread()로 코드를 실행하는 현재 스레드의 참조를 얻을 수 있다. Thread thread = Thread.currentThread(); ","date":"2020-04-19","objectID":"/thread/:5:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"스레드의 스케줄링 동시성(Concurrency) : 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질 병렬성(Parallelism) : 멀티 코어에서 개별 스레드를 동시에 실행하는 성질 스레드의 개수가 코어의 수보다 많을 경우, 스레드를 어떤 순서에 의해 동시성으로 실행할 것 인가를 결정해야 한다. 이것을 스레드 스케줄링 이라고 한다. ","date":"2020-04-19","objectID":"/thread/:6:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"자바의 스레드 스케줄링 방식 우선순위(Priority)방식 우선순위가 높은 스레드가 실행 기회를 더 많이 갖는다. 스레드 객체에 우선순위 번호를 부여할 수 있어 개발자가 코드를 제어할 수 있다. 우선순위는 동시성에서만 의미가 있다고 볼 수 있다. 순환할당(Round-Robin)방식 시간 할당량 Time Slice을 정해서 하나의 스레드를 정해진 시간만큼 실행한다. ","date":"2020-04-19","objectID":"/thread/:6:1","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"스레드 우선순위 우선순위는 1에서부터 10까지 부여. 1이 가장우선순위가 낮고 10이 가장 높음. Thread 클래스 상수로도 지정할 수 있다. 만약 쿼드 코어일 경우 4개의 스레드가 병렬성으로 실행 될 수 있기 때문에 4개 이하의 스레드를 실행할 경우 우선순위 방식이 크게 영향을 미치지 못함. thread.setPriority(Thread.MAX_PRIORITY); // 10 thread.setPriority(Thread.NORM_PRIORITY); // 5 thread.setPriority(Thread.MIN_PRIORITY); // 1 ","date":"2020-04-19","objectID":"/thread/:6:2","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"동기화 메소드와 동기화 블록 ","date":"2020-04-19","objectID":"/thread/:7:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"공유 객체를 사용할 때 주의할 점 멀티 스레드에서는 스레드들이 객체를 공유해서 작업해야 하는 경우가 있음. 스레드 A를 사용하던 객체가 스레드 B에 의해 상태가 변경될 수 있기 때문에 의도했던 것과 다른 결과를 산출 될 수 있다. ","date":"2020-04-19","objectID":"/thread/:7:1","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"synchronized 임계 영역(critical section) : 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역 자바는 임계영역을 지정하기 위해 동기화(synchronize) 메소드와 블록을 제공. 스레드가 객체 내부의 동기화 메소드 또는 블록에 들어가면 즉시 객체에 잠금을 걸어 다른 스레드가 임계 영역 코드를 실행하지 못하도록 한다. synchronized 키워드는 인스턴스와 정적 메소드 어디든 붙일 수 있다. public synchronized void method() { // 임계 영역; } public void method() { // 여러 스레드가 실행 가능한 영역 ... synchronized(공유객체) { /*동기화 블록*/ // 임계 영역 } // 여러 스레드가 실행 가능한 영역 ... } ","date":"2020-04-19","objectID":"/thread/:7:2","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"스레드 상태 스레드 객체를 생성하고 start() 메소드를 호출하면 실행 대기 상태가 된다. 실행 대기란 아직 스케줄링이 되지 않아 실행을 기다리고 있는 상태를 의미한다. 실행 대기 상태에 있는 스레드 중 스레드 스케줄링에 의해 CPU를 점유하고 run() 메소드를 실행한다. 일시 정지 상태 : WAITING, TIMED_WAITING, BLOCKED ","date":"2020-04-19","objectID":"/thread/:8:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"Thread.State 열거 상수 상태 열거 상수 설명 객체 생성 NEW 스레드 객체 생성. 아직 start() 메소드 호출 전. 실행 대기 RUNNABLE 실행 상태로 언제든지 갈 수 있는 상태. 일시 정지 WAITING 다른 스레드가 통지(Notify)할 때까지 기다리는 상태 일시 정지 TIMED_WAITING 주어진 시간 동안 기다리는 상태 일시 정지 BLOCKED 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태 종료 TERMINATED 실행을 마친 상태 ","date":"2020-04-19","objectID":"/thread/:8:1","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Java"],"content":"스레드 상태 제어 스레드 상태 제어 : 실행 중인 스레드의 상태를 변경하는 것 멀티 스레드 환경에서는 정교한 스레드 상태 제어가 필요하며, 스레드의 상태 변화를 가져오는 메소드를 파악해야 한다. ","date":"2020-04-19","objectID":"/thread/:9:0","tags":["Java"],"title":"[Java Fundamental] Multi Thread","uri":"/thread/"},{"categories":["Issue Note"],"content":"이슈 해당 정보를 입력하고 연결정보를 클릭시 아래와 같은 에러가 발생하였다. Database \"/Users/riley/test\" not found, and IFEXISTS=true, so we cant auto-create it [90146-199] 90146/90146 ","date":"2020-03-20","objectID":"/h2-database-not-found/:1:0","tags":["H2","Database"],"title":"[Issue Note] H2 Database ~ not found, and IFEXISTS=true, so we cant auto-create it [90146-199]","uri":"/h2-database-not-found/"},{"categories":["Issue Note"],"content":"문제 해결 단계 아래 링크를 통하여 test 라는 이름의 새로운 데이터베이스를 생성해줌으로써 해결하였다. http://www.h2database.com/html/tutorial.html#creating_new_databases # 설치경로로 이동 cd /Users/riley/Utils/h2/bin 이동하면 h2-버전명 jar 파일이 있다. h2 쉘을 아래와 같이 실행해준다. java -cp h2-1.4.199.jar org.h2.tools.Shell URL 은 jdbc:h2:~/test 로 지정하였다. jdbc:h2:~/test 로 접속 URL 을 설정하였지만 어플리케이션에서 접속시 URL 은 jdbc:h2:tcp://localhost/~/test 로 접속해야한다. ","date":"2020-03-20","objectID":"/h2-database-not-found/:2:0","tags":["H2","Database"],"title":"[Issue Note] H2 Database ~ not found, and IFEXISTS=true, so we cant auto-create it [90146-199]","uri":"/h2-database-not-found/"},{"categories":["AWS"],"content":" 목표 😁😁😁 AWS에서 Cent OS 7로 테스트 서버를 구축한다. 콘솔접속경로 ","date":"2020-03-20","objectID":"/build-aws-centos7/:0:0","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"AWS EC2 인스턴스 추가하기 ","date":"2020-03-20","objectID":"/build-aws-centos7/:1:0","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"1. 콘솔 대시보드에서 인스턴스 시작을 선택한다. ","date":"2020-03-20","objectID":"/build-aws-centos7/:1:1","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"2. Amazon Machine Image(AMI)에서 인스턴스 템플릿을 선택한다. 검색 창에 centos를 검색 후 원하는 버전을 선택한다. ","date":"2020-03-20","objectID":"/build-aws-centos7/:1:2","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"3. 인스턴스 유형 선택 페이지에서 하드웨어 구성을 선택한다. 일단 난 프리티어니깐… t2.micro를 선택 🤔 ","date":"2020-03-20","objectID":"/build-aws-centos7/:1:3","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"4. 🤷🏻‍♀️ 검토 후 시작(Review and Launch) 버튼을 클릭하여 구성을 완료한다. ","date":"2020-03-20","objectID":"/build-aws-centos7/:1:4","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"5. 보안 그룹 구성 ","date":"2020-03-20","objectID":"/build-aws-centos7/:1:5","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"6. 인스턴스 시작 검토 페이지에서 시작을 선택한다. ","date":"2020-03-20","objectID":"/build-aws-centos7/:1:6","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"7. 키 페어 생성화면에서 키 페어를 생성한다. 프라이빗 키 파일(*.pem)을 다운로드한다. 해당 키로 EC2 인스턴스 액세스할 수 있다. 키 페어가 없이 처음에는 인스턴스에 연결할 수 없으므로 꼭 다운로드 한다. 준비가 완료되면 인스턴스 시작을 선택한다.👏🏻👏🏻👏🏻 ","date":"2020-03-20","objectID":"/build-aws-centos7/:1:7","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"Mac 접속 설정하기 centos AMI의 경우 접속계정은 centos이다. Linux 인스턴스 연결시 각 OS별 계정정보 참고 PuTTY를 사용하여 Windows에서 Linux 인스턴스에 연결 ","date":"2020-03-20","objectID":"/build-aws-centos7/:2:0","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"SSH 접속 Config 설정 ~/.ssh/config Host riley-aws HostName \"publicIP\" User centos Port 22 IdentityFile ~/.ssh/riley.pem .pem로 ssh 접속시 bad permissions 오류가 발생할 때 chmod 400 \u003cyour\u003e.pem ","date":"2020-03-20","objectID":"/build-aws-centos7/:2:1","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"root 계정의 직접 접속 차단하기 Linux의 ssh 기본 설정에는 root 로그인이 허용되어 있다. 포트스캐닝을 통해 ssh 포트가 열려 있는게 확인되면 해커에 의해 무작위로 root 계정으로 ssh 접속을 시도 할 수 있다. 그러므로 root 계정으로 직접 접속을 차단하는 것이 좋다. $ sudo vi /etc/ssh/sshd_config #LoginGraceTime 2m PermitRootLogin no #StrictModes yes #MaxAuthTries 6 #MaxSessions 10 # 아무출력도 없으면 잘된거임 sudo systemctl restart sshd.service ","date":"2020-03-20","objectID":"/build-aws-centos7/:2:2","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["AWS"],"content":"계정 생성 및 패스워드 설정 root password 설정 sudo passwd root 사용자 추가하기 su -root adduser kai 새로 생성한 계정의 패스워드 설정하기 sudo passwd kai 새로 생성한 계정에 root 권한을 사용할 수 있도록 설정 sudo visudo ## Next comes the main part: which users can run what software on ## which machines (the sudoers file can be shared between multiple ## systems). ## Syntax: ## ## user MACHINE=COMMANDS ## ## The COMMANDS section may have other options added to it. ## ## Allow root to run any commands anywhere root ALL=(ALL) ALL kai ALL=(ALL) ALL ","date":"2020-03-20","objectID":"/build-aws-centos7/:2:3","tags":["AWS","AWS EC2","devops"],"title":"AWS CentOS 7 테스트 서버 구축하기","uri":"/build-aws-centos7/"},{"categories":["Docker/Kubernetes"],"content":" 시작하세요! 도커/쿠버네티스 책 정리 🐳🐳🐳 도커(docker)는 리눅스 컨테이너에 여러 기능을 추가함으로써 애플리케이션을 컨테이너로서 좀 더 쉽게 사용할 수 있게 만들어진 오픈소스 프로젝트이다. GO 언어로 작성되어 있으며 2013년 3월에 첫 번째 릴리스가 발표된 이후 지금까지 꾸준히 개발되고 있다. 도커와 관련된 프로젝트 Docker Compose Private Registry Docker Machine Kitematic 도커라고 하면 Docker Engine 혹은 도커와 관련된 모든 프로젝트를 의미한다. 도커 생태계에 있는 여러 프로젝트들은 도커 엔진을 좀 더 효율적으로 사용하기 위한 것에 불과하며 핵심이 되는 것은 도커 엔진이다. ","date":"2019-08-02","objectID":"/chapter1-docker/:0:0","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"1.1 가상 머신과 도커 컨테이너 ","date":"2019-08-02","objectID":"/chapter1-docker/:1:0","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"기존의 가상화 기술 [그림] 가상 머신 구조 하이퍼바이저를 이용해 여러 개의 운영체제를 하나의 호스트에서 생성해 사용하는 방식 여러 운영체제는 가상 머신이라는 단위로 구분되며 각 가상머신에는 Ubuntu, CentOS 등의 운영체제가 설치되어 사용되어짐. Guest OS : 하이퍼바이저에 의해 생성되고 관리되는 운영체제. 각 게스트 운영체제는 다른 게스트 운영체제와 완전히 독립된 공간과 시스템 자원을 할당받게 됨. Host OS : 서버를 부팅할 때 실행되는 운영체제 대표적인 가상화 툴 : VirtualBox, VMware 등 ","date":"2019-08-02","objectID":"/chapter1-docker/:1:1","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"기존의 가상화 기술의 문제점 하이퍼바이저를 반드시 거치기 때문에 일반 호스트 OS에 비해 성능이 손실이 발생 게스트 OS를 운영하기 위한 라이브러리, 커널 등을 전부 포함하기 때문에 가상머신의 이미지 크기가 클 수밖에 없음 ","date":"2019-08-02","objectID":"/chapter1-docker/:1:2","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"도커 컨테이너 [그림] 도커 컨테이너 구조 [출처] https://www.docker.com/resources/what-container ","date":"2019-08-02","objectID":"/chapter1-docker/:1:3","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"도커 컨테이너의 장점 성능 손실이 적다 가상화된 공간을 생성하기 위해 리눅스 자체 기능인 chroot, name space, cgroup을 사용함으로써 프로세스 단위의 격리 환경을 만들기 때문에 성능 손실이 없음. 이미지 용량이 가상머신에 비해 줄어들어 이미지를 만들고 배포하는 시간이 빠르다 컨테이너 필요한 커널은 호스트의 커널을 공유해 사용하고, 컨테이너 안에 애플리케이션 구동하는 데 필요한 라이브러리 및 실행 파일만 존재하므로 이미지 용량이 가상 머신에 비해 대폭 줄어듬. ","date":"2019-08-02","objectID":"/chapter1-docker/:1:4","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"1.2 도커를 시작해야 하는 이유 도커는 컨테이너 생태계에서 사실상 표준으로 사용 쿠버네티스, 메소스와 같은 오픈소스 프로젝트에서도 도커를 기준으로 개발 ","date":"2019-08-02","objectID":"/chapter1-docker/:2:0","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"1.2.1 애플리케이션의 개발과 배포가 편하다 도커 컨테이너는 호스트 OS 위에서 실행되는 격리 공간이기 때문에 독립된 개발 환경을 보장받을 수 있다. 도커 이미지라고 하는 일종의 패키지로 만들어서 관리하기 때문에 설치 작업 없이 복제를 통하여 간편하게 통합 환경 구성이 가능하다. ","date":"2019-08-02","objectID":"/chapter1-docker/:2:1","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"1.2.2 여러 애플리케션의 독립성과 확장성이 높아진다. 모놀리스(Monolith) 애플리케이션 소프트웨어의 여러 모듈이 상호 작용하는 로직을 하나의 프로그램에서 구동시키는 방식. 서비스의 기능이 복잡해지고 거대하질수록 확장성과 유연성이 줄어든다. 마이크로서비스(Micro-service) 여러 모듈을 독립된 형태로 구성하기 때문에 언어에 종속되지 않고 변화에 빠르게 대응 할 수 있고 각 모듈의 관리가 쉬워진다. 도커 컨테이너는 수 초 내로 생성과 시작이 가능하고 여러 모듈을 독립된 환경을 동시에 제공할 수 있어 마이크로서비스 구조에서 가장 많이 사용. 웹 서비스는 데이터베이스 컨테이너와 서버 컨테이너로 분리할 수 있으며, 웹 서비스에 부하가 발생할 시 마이크로서비스 구조의 웹 서버 컨테이너만을 동적으로 늘려서 부하를 분산할 수 있다. 웹 서버와 데이터베이스의 이미지를 독립적으로 관리하기 때문에 유지 보수도 용이 마이크로서비스는 개발자가 직접 구현하기보다 도커 스웜 모드, 쿠버네티스 등 컨테이너 오케스트레이션 플랫폼을 통해 사용하는 것이 일반적 ","date":"2019-08-02","objectID":"/chapter1-docker/:2:2","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"1.3 도커 엔진 설치 도커는 리눅스 컨테이너를 제어는 API를 Go 언어로 구현한 libcontainer를 사용하기 때문에 대부분 리눅스 운영체제에서 사용할 수 있다. 마이크로소프트 윈도우, 맥 OS X 에서도 도커를 사용할 수 있지만 윈도우 10, 맥 OS X 10.10.3 Yosemite 이전 버전을 사용한다면 도커를 사용하기 위해 별도의 가상화 공간을 생성해야 한다. ","date":"2019-08-02","objectID":"/chapter1-docker/:3:0","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"1.3.1 도커 엔진의 종류 및 버전 EE(Docker Enterprise Edition) 인 유료버전과 CE(Community Edition) 인 무료 버전으로 구분되어 제공 버전은 (출시 년도)-(출시 월)-(도커 엔진 종류) 의 형태 EE와 CE 부가적인 서비스 지원 수준에 차이만 있을 뿐 핵심적인 컨테이너 기술을 CE에서도 동일하게 사용가능 ","date":"2019-08-02","objectID":"/chapter1-docker/:3:1","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"1.3.2 리눅스 도커 엔진 설치 확인사항 최신 버전의 커널을 사용하고 있는지 확인한다. 호스트 운영체제가 최소한 3.10 버전 이상을 사용해야 도커가 정상적으로 사용 가능 uname -r 명령어를 통해 커널 버전을 확인한다. 지원 기간 내에 있는 배포 판인지 확인한다. 일부 오래된 리눅스 배포판은 업데이트 등의 지원을 받지 못할 수 있음. 64비트 리눅스 인지 확인 도커는 64비트에 최적화 되어 있으며 32비트 버전에서 도커를 실행하는 방법은 권장하지 않음 sudo 명령어를 통해 설치하거나 root 권한을 소유한 계정에서 설치를 진행해야 한다. 도커 설치 가이드 Install Docker Engine CentOS 7, RHEL7 sudo yum install -y yum-utils sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io sudo systemctl start docker # docker 가 정상동작하는지 확인하기 sudo docker info Ubuntu 14.04, 16.04, 18.04 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" apt-get update apt-get install docker-ce ","date":"2019-08-02","objectID":"/chapter1-docker/:3:2","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"1.3.3 윈도우, 맥 OS 도커 설치 이전에는 윈도우와 맥 OS X에서 도커를 설치하려면 도커 툴박스라는 패키지를 설치해야 했음. 최근에는 자체 가상화 기술을 사용한 도커가 설치되어 버추얼박스에 의존하지 않고 도커를 설치할 수 있다. Docker for Windows는 Hyper-V, Docker for Mac OS X 는 xhyve 기술을 이용한다. Docker for Windows WSL2 설정 Windows WSL2 리눅스 가상환경에서 도커를 실행할 경우 해당 옵션을 선택하면 된다. (Installer 실행시 꼭 관리자권한으로 실행…) WSL 2에서 Docker 원격 컨테이너 시작 General \u003e Use the WSL 2 based engine Resources \u003e WSL INTEGRATION \u003e Enable integration with my default WSL distro ","date":"2019-08-02","objectID":"/chapter1-docker/:3:3","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":["Docker/Kubernetes"],"content":"Trouble Shooting centos 7.3 docker-engine conflicts with docker-common-2 ","date":"2019-08-02","objectID":"/chapter1-docker/:4:0","tags":["Docker","Kubernetes"],"title":"[시작하세요! 도커/쿠버네티스] Chapter 1. 도커","uri":"/chapter1-docker/"},{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":" 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2019-01-13","objectID":"/jpa-programming6-2/:0:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 일대다","uri":"/jpa-programming6-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"6.2 일대다 일대다 관계는 엔티티를 하나 이상 참조할 수 있으므로 자바 컬렉션 (Collection, List, Set, Map ) 중 하나를 사용한다. ","date":"2019-01-13","objectID":"/jpa-programming6-2/:1:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 일대다","uri":"/jpa-programming6-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"6.2.1 일대다 단방향 [1:N] 일대다 단방향 관계는 JPA 2.0 부터 지원한다. 일대다 단방향의 경우 반대편에서 테이블의 외래키를 관리하는 특이한 모습이 나타난다. Team.java @Entity public class Team { @Id @GeneratedValue @Column(name = \"TEAM_ID\") private String id; private String name; @OneToMany @JoinColumn (name = \"TEAM_ID\") // MEMBER 테이블의 TEAM_ID (FK) private List\u003cMember\u003e members = new ArrayList\u003cMember\u003e(); } Member.java @Entity public class Member { @Id @GeneratedValue @Column(name = \"MEMBER_ID\") private Long id; private String username; // Getter, Setter... } 일대다 단방향 관계를 매핑할때는 @JoinColumn 을 명시. ","date":"2019-01-13","objectID":"/jpa-programming6-2/:1:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 일대다","uri":"/jpa-programming6-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"일대다 단방향 매핑의 단점 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점. public void testSave() { Member member1 = new Member(\"member1\"); Member member2 = new Member(\"member2\"); Team team1 = new Tema(\"team1\"); team1.getMembers().add(member1); team2.getMembers().add(member2); em.persist(member1); em.persist(member2); em.persist(team1); } ","date":"2019-01-13","objectID":"/jpa-programming6-2/:1:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 일대다","uri":"/jpa-programming6-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":" 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2019-01-10","objectID":"/jpa-programming6-1/:0:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/jpa-programming6-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"다양한 연관관계 다루기 ","date":"2019-01-10","objectID":"/jpa-programming6-1/:1:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/jpa-programming6-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"엔티티의 연관관계를 매핑할때 고려할점 다중성 단방향, 양방향 연관관계의 주인 ","date":"2019-01-10","objectID":"/jpa-programming6-1/:1:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/jpa-programming6-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"다중성 다대일(@ManyToOne), 일대다(@OneToMany), 일대일(@OneToOne), 다대다(@ManyToMany) 다중성을 판단하기 어려울 때는 반대방향을 생각해보자. 보통 다대일과 일대다 관계를 가장 많이 사용하고 다대다 관계는 실무에서는 거의 사용하지 않음. ","date":"2019-01-10","objectID":"/jpa-programming6-1/:1:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/jpa-programming6-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"단방향, 양방향 객체 관계에서 한쪽만 참고하는 것을 단방향 관계라고하며, 양쪽이 서로 참조하는 것을 양방향 관계라 한다. ","date":"2019-01-10","objectID":"/jpa-programming6-1/:1:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/jpa-programming6-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"연관관계의 주인 외래 키를 가진 테이블과 매핑한 엔티티가 외래키를 관리하는게 효율적이므로 보통 이곳을 연관관계의 주인으로 선택한다. 연관관계의 주인이 아니면 mappedBy 속성을 사용하며, 연관관계 주인의 필드 이름을 값으로 입력한다. ","date":"2019-01-10","objectID":"/jpa-programming6-1/:1:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/jpa-programming6-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"6.1 다대일 다대일 관계에서 외래키는 항상 다(N) 쪽에 있다. 객체 양방향 관계에서 연관관계의 주인은 항상 다쪽이다. ","date":"2019-01-10","objectID":"/jpa-programming6-1/:2:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/jpa-programming6-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"6.1.1 다대일 단방향 [N:1] @Entity public class Member { @Id @GeneratedValue @Column(name = \"MEMBER_ID\") private Long id; private String username; // 연관관계 매핑 @ManyToOne @JoinColumn(name = \"TEAM_ID\") private Team team; // Getter, Setter... } Team.java @Entity public class Team { @Id @GeneratedValue @Column(name = \"TEAM_ID\") private Long id; private String name; // Getter, Setter ... } 회원은 Member.team 으로 팀 엔티티를 참조할 수 있다. (반대로 팀에는 회원을 참조하는 필드가 없다.) @JoinColumn(name = \"TEAM_ID\") : TEAM_ID 외래키와 매핑했다. ","date":"2019-01-10","objectID":"/jpa-programming6-1/:2:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/jpa-programming6-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"6.1.2 다대일 양방향 [N:1, 1:N] @Entity public class Member { @Id @GeneratedValue @Column(name = \"MEMBER_ID\") private Long id; private String username; // 연관관계 매핑 @ManyToOne @JoinColumn(name = \"TEAM_ID\") private Team team; // 연관관계 설정 public void setTeam(Team team) { this.team = team; // 무한 루프에 빠지지 않도록 체크 if (!team.getMembers().contains(this)) { team.getMembers().add(this); } } // Getter, Setter... } Team.java @Entity public class Team { @Id @GeneratedValue @Column(name = \"TEAM_ID\") private String id; private String name; @OneToMany(mappedBy = \"team\") private List\u003cMember\u003e members = new ArrayList\u003cMember\u003e(); public void addMember(Member member) { this.members.add(member); if (member.getTeam() != this) { member.setTeam(this); } } } 양방향은 외래 키가 있는 쪽이 연관관계의 주인 양방향 연관관계를 항상 서로를 참조해야 한다. 항상 서로를 참조하게 하려면 연관관계 편의 메소드를 작성하는 것이 좋다. (양쪽에 다 작성할 경우 무한루프에 빠지므로 주의. 또한 양쪽에 다 작성한 경우 둘 중 하나만 호출해도 된다.) ","date":"2019-01-10","objectID":"/jpa-programming6-1/:2:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 6장 다양한 연관관계 매핑 - 다대일","uri":"/jpa-programming6-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":" 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-30","objectID":"/jpa-programming5-2/:0:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.3 양방향 연관관계 일대다 관계에서는 여러 건과 연관관계를 맺을 수 있으므로 컬렉션(Collection, Set, Map, List ..) 을 사용한다. ","date":"2018-12-30","objectID":"/jpa-programming5-2/:1:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.3.1 양방향 연관관계 매핑 Member.java 회원 엔티티에는 변경할 사항이 없다. @Entity public class Member { @Id @Column(name = \"MEMBER_ID\") private String id; private String username; // 연관관계 매핑 @ManyToOne @JoinColumn(name = \"TEAM_ID\") private Team team; // 연관관계 설정 public void setTeam(Team team) { this.team = team; } // Getter, Setter... } Team.java @Entity public class Team { @Id @Column(name = \"TEAM_ID\") private String id; private String name; @OneToMany (mappedBy = \"team\") private List\u003cMember\u003e members = new ArrayList\u003cMember\u003e(); // Getter, Setter ... } 팀과 회원은 1:N 이며 해당 다중성을 매핑하기 위하여 @OneToMany 매핑 정보를 사용한다. 또한 mappedBy 속성은 양방향 매핑일 때 사용하며, 반대쪽 매핑되는 필드의 이름을 값으로 설정하면 된다. ","date":"2018-12-30","objectID":"/jpa-programming5-2/:1:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.3.2 일대다 컬렉션 조회 public static void biDirection(EntityManager em) { Team team = em.find(Team.class, \"team1\"); List\u003cMember\u003e members = team.getMembers(); // 팀 -\u003e 회원 방향으로 객체 그래프를 탐색한다. for (Member member : members) { System.out.println(\"member.username : \" + member.getUsername()); } } ","date":"2018-12-30","objectID":"/jpa-programming5-2/:1:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.4 연관관계 주인 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리하지만, 객체의 경우 엔티티를 양방향으로 매핑하기 위해서는 객체의 참조를 통해서 서로 참조해야만 한다. (ex 회원-\u003e팀, 팀-\u003e회원) 엔티티를 양방향 연관관계로 설정하면 객체 참조는 둘인데 외래키는 하나이므로 둘 사이에 차이가 발생 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데 이것을 연관관계의 주인 이라고 한다. ","date":"2018-12-30","objectID":"/jpa-programming5-2/:2:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.4.1 양방향 매핑의 규칙 : 연관관계의 주인 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록, 수정, 삭제) 할 수 있다. 주인이 아닌 쪽은 읽기만 가능하다. 주인은 mappedBy 속성을 사용하지 않는다. 연관관계의 주인을 정한다는 것 -\u003e 외래키 관리자를 선택하는 것 ","date":"2018-12-30","objectID":"/jpa-programming5-2/:2:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.4.2 연관관계의 주인은 외래 키가 있는 곳 연관관계의 주인만 데이터베이스 연관관계와 매핑되며, 외래키를 관리할 수 있다. 주인이 아닌 반대편 (inverse, non-owning side) 은 읽기만 가능 외래키를 변경하지는 못한다. N:1, 1:N 에서는 항상 N 쪽이 외래 키를 갖는다. @ManyToOne 은 항상 연관관계의 주인이 되므로, mappedBy 속성이 존재하지 않는다. ","date":"2018-12-30","objectID":"/jpa-programming5-2/:2:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.6 양방향 연관관계의 주의점 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌곳에만 입력하는 실수를 유의해야 한다. public static void testSave(EntityManager em) { // 회원1 저장 Member member1 = new Member(\"member1\", \"회원1\"); em.persist(member1); // 회원2 저장 Member member2 = new Member(\"member2\", \"회원2\"); em.persist(member2); // 팀1 저장 Team team1 = new Team(\"team1\", \"팀1\"); // 주인이 아닌곳에 연관관계 설정 team1.getMembers().add(member1); team1.getMembers().add(member2); em.persist(team1); } 예제코드에서 Member 가 연관관계의 주인인데 Member.team 의 연관관계에 대해서 설정하지 않았다. 따라서 TEAM_ID 외래키의 값도 null 이 저장된다. ","date":"2018-12-30","objectID":"/jpa-programming5-2/:3:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.6.1 순수한 객체까지 고려한 양방향 연관관계 객체 관점에서 양쪽 방향에 참조 값을 입력해 주는 것이 가장 안전하다. Member.team : 연관관계의 주인. 이 값으로 외래키를 관리 Team.members : 연관관계 주인 아님. 따라서 저장시에는 사용되지 않음. 결론 : 객체의 양방향 연관관계는 양쪽 모두 관계를 맺어주자. // 양방향 연관관계 사용하여 저장 public static void testORM_양방향(EntityManager em) { Team team2 = new Team(\"team2\", \"팀2\"); em.persist(team2); Member member3 = new Member(\"member3\", \"회원3\"); member3.setTeam(team2); team2.getMembers().add(member3); // 연관관계 설정 member1 -\u003e team2 em.persist(member3); // 연관관계 설정 team2 -\u003e member1 Member member4 = new Member(\"member4\", \"회원4\"); member4.setTeam(team2); // 연관관계 설정 member4 -\u003e team2 team2.getMembers().add(member4); // 연관관계 설정 team2 -\u003e member4 em.persist(member4); } ","date":"2018-12-30","objectID":"/jpa-programming5-2/:3:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.6.2 연관관계 편의 메소드 양방향 연관관계는 양쪽 다 신경 써야 한다. 그러나 각각 호출하다보면 실수로 둘 중 하나만 호출해서 양방향이 깨질 수 있다. setTeam() 메소드 하나로 양방향 모두를 설정하도록 변경한다. 한 번에 양항뱡 관계를 설정하는 메소드를 연관관계 편의 메소드라고 한다. // Member.java 의 setTema() 메소드 수정 public void setTeamNew(Team team) { this.team = team; team.getMembers().add(this); } public static void testORM_양방향_리펙토링(EntityManager em) { Team team3 = new Team(\"team3\", \"팀3\"); em.persist(team3); Member member5 = new Member(\"member5\", \"회원5\"); member5.setTeam(team3); em.persist(member5); Member member6 = new Member(\"member6\", \"회원6\"); member6.setTeam(team3); em.persist(member6); } ","date":"2018-12-30","objectID":"/jpa-programming5-2/:3:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.6.3 연관관계 편의 메소드 작성 시 주의 사항 연관관계를 변경할 경우 기존 연관관계를 삭제하는 코드를 추가해야 한다. 객체에서 양방향 연관관계를 사용하려면 로직을 견고하게 작성해야 한다. // 연관관계 편의 메소드 public void setTeam(Team team) { // 기존 팀과 관계를 제거 if(this.team != null) { this.team.getMembers().remove(this); } this.team = team; team.getMembers().add(this); } ","date":"2018-12-30","objectID":"/jpa-programming5-2/:3:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.7 정리 단방향 매핑과 비교했을때 양방향 매핑은 복잡하고, 연관관계의 주인도 정해야하고 단방향 연관관계를 양방향으로 만들기 위해 로직도 잘 관리해야한다. 양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가 된것 뿐이다. 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야한다. ","date":"2018-12-30","objectID":"/jpa-programming5-2/:4:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"연관관계의 주인을 정하는 기준 비즈니스 로직의 중요도가 크다고 해서 무조건 연관관계의 주인이 되는 것은 아니다. 비즈니스 중요도를 배제하고 단순히 외래 키 관리자 정도의 의미만 부여해야 한다. 연관관계의 주인은 외래키의 위치와 관련해서 정해야 한다. ","date":"2018-12-30","objectID":"/jpa-programming5-2/:5:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 양방향 연관관계","uri":"/jpa-programming5-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":" 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 단방향 연관관계 객체는 참조(주소) 를 사용해서 관계를 맺고, 테이블을 외래 키를 사용해서 관계를 맺는다. 방향(Direction) : 단방향과 양방향이 있으며 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향 이다. 다중성(Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다 (N:N) 연관관계 주인 (owner) : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다. ","date":"2018-12-26","objectID":"/jpa-programming5-1/:0:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.1 단방향 연관관계 ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"객체 연관관계 회원 객체와 팀 객체는 단방향 관계 다. 회원은 Member.team 필드를 통해서 팀을 알 수 있지만 반대로 팀은 회원을 알 수 없다. ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"테이블 연관관계 회원 테이블과 팀 테이블은 양방향 관계 다. 회원 테이블의 TEAM_ID 외래키를 통해 회원팀과 조인 할 수 있고 반대로 팀과 회원도 조인할 수 있다. SELECT * FROM MEMBER M JOIN TEAM T ON M.TEAM_ID = T.ID; SELECT * FROM TEAM T JOIN MEMBER M ON T.ID = M.TEAM_ID; ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"정리 참조를 사용하는 객체의 연관관계는 단방향이다. A -\u003e B (a.b) 외래키를 사용하는 테이블의 연관관계는 양방향이다. A JOIN B 도 가능 하고 B JOIN A 도 가능하다. 객체를 양항뱡으로 참조하려면 단방향 연관관계를 2개 만들어야 한다. A-\u003eB (a.b) B-\u003eA (b.a) ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.1.1 순수한 객체 연관관계 객체그래프 : 객체는 참조를 사용해서 연관관계를 탐색할 수 있다. // 객체그래프 탐색 동작코드 public static void main(String[] args) { Member member1 = new Member (\"member1\", \"회원1\"); Member member2 = new Member (\"member2\", \"회원2\"); Team team1 = new Team (\"team1\", \"팀1\"); member1.setTeam(team1); member2.setTeam(team1); // 참조를 사용하여 연관관계를 탐색한다. Team findTeam = member1.getTeam(); } ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.1.2 테이블 연관관계 조인 : 데이터베이스는 외래 키를 사용해서 연관관계를 탐색할 수 있다. ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:5","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"테이블 생성 -- MEMBER CREATE TABLE MEMBER ( MEMBER_ID VARCHAR(255) NOT NULL, TEAM_ID VARCHAR(255), USERNAME VARCHAR(255), PRIMARY KEY (MEMBER_ID) ); -- TEAM CREATE TABLE TEAM( TEAM_ID VARCHAR(255) NOT NULL, NAME VARCHAR(255), PRIMARY KEY (TEAM_ID) ); ALTER TABLE MEMBER ADD CONSTRAINT FK_MEMBER_TEAM FOREIGN KEY (TEAM_ID) REFERENCES TEAM ; SQL 을 통하여 연관관계를 정의하기 INSERT INTO TEAM (TEAM_ID, NAME) VALUES ('team1', '팀1'); INSERT INTO MEMBER (MEMBER_ID, TEAM_ID, USERNAME) VALUSE ('member1', 'team1', '회원1'); INSERT INTO MEMBER (MEMBER_ID, TEAM_ID, USERNAME) VALUSE ('member2', 'team1', '회원2'); ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:6","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.1.3 JPA 로 객체 관계매핑 Member.java @Entity public class Member { @Id @Column(name = \"MEMBER_ID\") private String id; private String username; // 연관관계 매핑 @ManyToOne @JoinColumn(name = \"TEAM_ID\") private Team team; // 연관관계 설정 public void setTeam(Team team) { this.team = team; } // Getter, Setter... } Team.java @Entity public class Team { @Id @Column(name = \"TEAM_ID\") private String id; private String name; // Getter, Setter ... } @ManyToOne : 다대일(N:1) 관계 매핑 정보를 나타낸다. 회원객체를 기준으로 팀객체와는 다대일 관계. @JoinColumn(name = \"TEAM_ID\") : 조인 컬럼은 외래키를 매핑할 때 사용. ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:7","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.1.4 @JoinColumn 속성 기능 기본값 name 매핑할 외래 키 이름 필드명 + _ + 참조하는 테이블의 기본키 컬럼명 referencedColumnName 외래 키가 참조하는 대상 테이블의 컬럼명 참조하는 테이블의 키 컬럼명 foreignKey(DDL) 테이블 생성시 사용. 외래키를 직접 지정 가능 unique, nullable, inserable, updateable, columnDefinition, table @Column 속성과 동일 ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:8","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.1.5 @ ManyToOne 속성 기능 기본값 optional false 로 설정시 연관된 엔티티가 항상 있어야 한다. true fetch 글로벌 페치 전략 @ManytoOne = FetchType.EAGER, @OneToMany=FetchType.LAZY cascade 영속성 전이 기능 사용 targetEntity 연관된 엔티티 타입 정보를 설정. (이 기능은 거의 사용 안함) @OneToMany private List\u003cMember\u003e members; // 제네릭타입으로 정보를 알 수 있다. ","date":"2018-12-26","objectID":"/jpa-programming5-1/:1:9","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.2 연관관계 사용 ","date":"2018-12-26","objectID":"/jpa-programming5-1/:2:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.2.1 저장 public static void testSave(EntityManager em) { // 팀1 저장 Team team1 = new Team(\"team1\", \"팀1\"); em.persist(team1); // 회원1 저장 Member member1 = new Member(\"member1\", \"회원1\"); member1.setTeam(team1); // 연관관계 설정 member1 -\u003e team1 em.persist(member1); // 회원2 저장 Member member2 = new Member(\"member2\", \"회원2\"); member2.setTeam(team1); em.persist(member2); } JPA 는 참조한 팀의 식별자 (Team.id) 를 외래 키로 사용해서 적절한 등록 쿼리를 생성 ","date":"2018-12-26","objectID":"/jpa-programming5-1/:2:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.2.2 조회 연관관계가 있는 엔티티를 조회하는 방법 객체 그래프 탐색 (객체 연관관계를 사용한 조회) 객체 지향 쿼리 사용 (JPQL) 객체그래프 탐색 member.getTeam() 을 사용하여 Member 와 연관된 Team 객체를 조회할 수 있다. Member member = em.find(Member.class, \"member1\"); Team team = member.getTeam(); // 객체 그래프 탐색 객체지향 쿼리 사용 public static void queryLogicJoin(EntityManager em) { String jpql = \" SELECT m from Member m JOIN m.team t WHERE t.name = :teamName\"; List\u003cMember\u003e resultList = em.createQuery(jpql, Member.class) .setParameter(\"teamName\", \"팀1\") .getResultList(); for (Member member : resultList) { System.out.println(\"[query] member.username = \" + member.getUsername()); } } ","date":"2018-12-26","objectID":"/jpa-programming5-1/:2:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.2.3 수정 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다. 이것은 연관관계를 수정할 때도 동일하며, 참조하는 대상만 변경하면 나머지는 JPA 에서 자동으로 처리한다. public static void updateRelation(EntityManager em) { // 새로운 팀 Team team2 = new Team(\"team2\", \"팀2\"); em.persist(team2); // 회원1 을 팀2로 설정한다. Member member = em.find(Member.class, \"member1\"); member.setTeam(team2); // 플러시 발생시 자동으로 업데이트 } ","date":"2018-12-26","objectID":"/jpa-programming5-1/:2:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.2.4 연관관계 제거 private static void deleteRelation(EntityManager em) { Member member1 = em.find(Member.class, \"member1\"); member1.setTeam(null); } ","date":"2018-12-26","objectID":"/jpa-programming5-1/:2:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"5.2.5 연관된 엔티티 삭제 연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다. member1.setTeam(null); // 회원1 연관관계 제거 member2.setTeam(null); // 회원2 연관관계 제거 em.remove(team); // 팀 삭제 ","date":"2018-12-26","objectID":"/jpa-programming5-1/:2:5","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 5장 연관관계 매핑 기초 - 단방향 연관관계","uri":"/jpa-programming5-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":" 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-23","objectID":"/jpa-programming4/:0:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"JPA 의 매핑 어노테이션 객체와 테이블 매핑 : @Entity, @Table 기본 키 매핑 : @Id 필드와 컬럼 매핑 : @Column 연관관계 매핑 : @ManyToOne, @JoinColumn ","date":"2018-12-23","objectID":"/jpa-programming4/:1:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.1 @Entity 테이블을 매핑할때 @Entity 어노테이션을 필수로 붙어야 한다. 속성 기능 기본값 name JPA 에서 사용할 엔티티 이름을 지정한다. 보통 기본값인 클래스 이름을 사용한다. 설정하지 않으면 클래스 이름을 그대로 사용. ","date":"2018-12-23","objectID":"/jpa-programming4/:2:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"@Entity 적용시 주의할 점 매개변수가 없는 기본 생성자는 필수. final, enum, interface, inner 클래스에는 사용할 수 없다. 저장할 필드에 final 을 사용하면 안된다. ","date":"2018-12-23","objectID":"/jpa-programming4/:2:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.2 @Table @Table 은 엔티티와 매핑할 테이블을 지정한다. 속성 기능 기본값 name 매핑할 테이블 이름 엔티티 이름을 사용. catalog catalog 기능이 있는 데이터베이스에서 catalog 를 매핑 schema shcema 기능이 있는 데이터베이스에서 schema 를 매핑 uniqueConstrains(DDL) DDL 생성 시 유니크 제약조건을 만든다. 2개 이상의 복합 유니크 제약조건도 만들 수 있다. 이 기능은 스키마 자동생성 기능을 사용해서 DDL 를 만들때만 사용 ","date":"2018-12-23","objectID":"/jpa-programming4/:3:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.3 다양한 매핑 사용 ","date":"2018-12-23","objectID":"/jpa-programming4/:4:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.4 데이터베이스 스키마 자동생성 JPA 는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원 스키마 자동생성 기능을 사용하려면 persistence.xml 에 다음 속성을 추가해야 한다. \u003cproperty name=\"hibernate.hbm2ddl.auto\" value=\"create\" /\u003e 위 속성을 추가하면 애플리케이션 실행 시점에 데이터베이스 테이블을 자동으로 생성. 자동으로 생성되는 DDL 은 지정한 데이터베이스 방언에 따라 달라진다. ","date":"2018-12-23","objectID":"/jpa-programming4/:5:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"장점 개발자가 테이블을 직접 생성하는 수고를 덜 수 있다. ","date":"2018-12-23","objectID":"/jpa-programming4/:5:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"주의사항 운영 서버에서 create, create-drop, update 처럼 DDL 을 수정하는 옵션은 절대 사용하면 안됨. [표] hibernate.hbm2ddl.auto 속성 옵션 기능 create 기존 테이블을 삭제하고 새로 생성. (DROP + CREATE) create-drop create 속성에 추가로 어블리케이션을 종료할때 생성한 DDL 제거 update 데이터베이스를 테이블과 엔티티 매핑정보를 비교해서 변경 사항만 수정 validate 데이터베이스 테이블과 엔티티 매핑정보를 비교. 차이가 있으면 경고를 남기고 어플리케이션을 실행하지 않음. 이 설정은 DDL 을 수정하지 않는다. none 자동생성 기능을 사용하지 않음. (none 은 사실 유요하지 않은 옵션 값) ","date":"2018-12-23","objectID":"/jpa-programming4/:5:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"개발 환경에 따른 추천 전략 개발 초기 단계는 create 또는 update 초기화 상태로 자동화된 테스트 진행시 개발자 환경과 CI 서버는 create 또는 create-drop 테스트 서버는 update 또는 validate 스테이징과 운영 서버는 validate 또는 none ","date":"2018-12-23","objectID":"/jpa-programming4/:5:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"이름 매핑 전략 변경하기 단어와 단어를 구분시 자바 언어는 관례상 카멜(Camel) 표기법을 사용하고 데이터베이스는 언더스코어(_) 를 주로 사용하기 때문에 엔티티를 매핑하려면 @Column.name 속성을 명시해야 함. hiberante.ejb.naming_strategy 속성을 사용하면 이름 매핑 전략을 변경 할 수 있다. 하이버네이트에서는 org.hibernate.cfg.ImprovedNamingStrategy 클래스를 제공. 위 클래스는 테이블 명이나 컬럼 명이 생략되면 자바의 카멜 표기법을 테이블의 언더스코어 표기법으로 매핑. \u003cproperty name=\"hibernate.ejb.naming_strategy\" value=\"org.hibernate.cfg.ImprovedNamingStrategy\"/\u003e ","date":"2018-12-23","objectID":"/jpa-programming4/:5:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.5 DDL 생성 기능 @Column 매핑정보에 nullable 속성 값을 false 로 지정하여 NOT NULL 제약 조건 추가. length 를 지정하면 문자의 크기를 지정할 수 있다. // Member.java 추가 @Column(name = \"NAME\", nullable = false, length = 10) private String username; ","date":"2018-12-23","objectID":"/jpa-programming4/:6:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"유니크 제약조건 @Table 에 uniqueConstraints 속성을 지정. // Member.java @Entity @Table(name = \"MEMBER\", uniqueConstraints = { @UniqueConstraint (name = \"NAME_AGE_UNIQUE\", columnNames = {\"NAME\", \"AGE\"}) }) public class Member {...} DDL 을 자동생성할 때만 사용하고 JPA 의 실행 로직에는 영향을 주지 않는다. ","date":"2018-12-23","objectID":"/jpa-programming4/:6:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.6 기본키 매핑 데이터베이스마다 기본키를 생성하는 방식이 다르기때문에 JPA 에서는 기본 키 생성전략을 제공한다. ","date":"2018-12-23","objectID":"/jpa-programming4/:7:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"JPA 에서 제공하는 데이터베이스 기본 키 생성 전략 직접할당 : 기본 키를 애플리케이션에 직접 입력 자동생성 : 대리 키 사용 방식 IDENTITY : 기본 키 생성을 데이터베이스에 위임 SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본키 할당 TABLE : 키 생성 테이블 사용. ","date":"2018-12-23","objectID":"/jpa-programming4/:7:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"주의사항 키 생성 전략을 사용하려면 persistence.xml 에 hibernate.id.new_generator_mapping=true 속성을 반드시 추가 해야 한다. 기존 하이버네이트 시스템을 유지보수 하는 것이 아니라면 반드시 true 로 설정할것. true 로 설정하면 키 생성을 최적화하는 allocationSize 속성을 사용하는 방식이 달라진다. persistence.xml \u003cproperty name=\"hibernate.id.new_generator_mappings\" value=\"true\" /\u003e \u003c!-- 키 생성 최적화 전략 --\u003e ","date":"2018-12-23","objectID":"/jpa-programming4/:7:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.6.1 기본 키 직접 할당 전략 기본키를 직접 할당하려면 @Id 로 매핑하면 된다. @Id 의 적용 가능 자바 타입 자바 기본형 자바 Wrapper 형 String java.util.Date java.sql.Date java.math.BigDecimal java.math.BigInteger // 기본키직접할당 Board board = new Board(); board.setId(\"id\"); em.persistence(board); ","date":"2018-12-23","objectID":"/jpa-programming4/:7:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.6.2 IDENTITY 전략 IDENTITY 전략은 기본 키 생성을 데이터베이스에 위임하는 전략이다. 주로 Mysql, PostgreSQL, SQL Server, DB2 에서 사용한다. Mysql 의 AUTO_INCREMENT 기능 @Entity public class Board { @Id @GeneratedValue(starategy = GenerationType.IDENTITY) private Long id; } @GeneratedValue 어노테이션을 사용하고 식별자 생성 전략을 명시한다. ","date":"2018-12-23","objectID":"/jpa-programming4/:7:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"참고 IDENTIY 전략은 데이터베이스에 INSERT 후에 기본 키 값을 조회할 수 있다. JDBC3 의 Statement.getGeneratedKeys() 를 사용하면 데이터를 저장하면서 동시에 생성된 키 값도 얻어 올 수 있다. 엔티티가 영속상태가 되려면 반드시 식별자가 필요한데, IDENTITY 전략의 경우 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다. ","date":"2018-12-23","objectID":"/jpa-programming4/:7:5","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.6.3 SEQUENCE 전략 데이터베이스의 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터 베이스 오브젝트이다. -- SEQUENCE DDL CREATE TABLE BOARD ( ID BIGINT NOT NULL PRIMARY KEY, DATE VARCHAR(255) ) -- 시퀀스 생성 CREATE SEQUENCE BOARD_SEQ START WITH 1 INCREMENT BY 1; SEQUENCE 전략은 em.persist() 를 호출할 때 먼저 데이터베이스 시퀀스를 사용해 식별자를 조회한다. 조회한 식별자를 엔티티에 할당한 후 엔티티를 영속성 컨텍스트에 저장 트랜잭션 커밋해서 플러시가 일어나면 엔티티를 데이터베이스에 저장 ","date":"2018-12-23","objectID":"/jpa-programming4/:7:6","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"@SequenceGenerator 속성 기능 기본값 name 식별자 생성기 이름 필수 sequenceName 데이터베이스에 등록되어 있는 시퀀스 이름 hibernate_sequence initialValue DDL 생성 시에만 사용. 시퀀스 DDL 을 생성할 때 처음 시작하는 수를 지정 1 allocationSize 시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용) 50 catalog, schema 데이터베이스 catalog, schema 이름 ","date":"2018-12-23","objectID":"/jpa-programming4/:7:7","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"SequenceGenerator.allocationSize SequenceGenerator.allocationSize 기본값이 50 이다. JPA 는 시퀀스에 접근하는 횟수를 줄이기 위해 allocationSize 사용한다. 여기에서 설정한 값만큼 한 번에 시퀀스 값을 증가시키고 나서 그만큼 메모리에 시퀀스 값을 할당한다. 이방법은 시퀀스 값을 선점하므로 JVM 이 동시에 접근해서 데이터를 등록시 시퀀스 값이 한번에 증가하는 점을 염두. INSERT 성능이 중요하지 않거나 시퀀스가 많이 증가하는 게 부담될 경우 allocationSize 를 1로 설정한다. ","date":"2018-12-23","objectID":"/jpa-programming4/:7:8","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.6.4 TABLE 전략 TABLE 전략은 키 생성 전용 테이블을 하나 만들고 이름과 값으로 사용할 컬럼을 만들어 데이터 시퀀스처럼 사용하는 전략이다. 이 전략은 모든 데이터베이스에 적용이 가능하다. -- TABLE 전략 시퀀스 테이블 DDL create table MY_SEQUENCES ( sequence_name varchar(255) not null, next_val bigint, primary key (sequence_name) ) ","date":"2018-12-23","objectID":"/jpa-programming4/:7:9","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"@TableGenerator 속성 기능 기본값 name 식별자 생성기 이름 필수 table 키생성 테이블명 hibernate_sequence pkColumnName 시퀀스 컬럼명 sequence_name valueColumnName 시퀀스 값 컬럼명 next_val initialValue 초기 값, 마지막으로 생성된 값이 기준이다 0 allocationSize 시퀀스 한 번 호출에 증가하는 수 (성능최적화 이용) 50 catalog, schema 데이터베이스 catalog, schema 이름 uniqueConstrains(DDL) 유니크 제약 조건을 지정할 수 있다. ","date":"2018-12-23","objectID":"/jpa-programming4/:7:10","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.6.5 AUTO 전략 GenerationType.AUTO 는 선택한 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택. AUTO 는 데이터베이스를 변경해도 코드를 수정할 필요가 없는 장점이 있다. ","date":"2018-12-23","objectID":"/jpa-programming4/:7:11","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.6.6 기본 키 매핑 정리 영속성 컨텍스트는 엔티티를 식별자 값으로 구분하므로 반드시 식별자 값이 있어야 한다. 권장하는 식별자 전략 null 값은 허용하지 않는다. 유일해야 한다. 변해서는 안된다. 테이블의 기본 키를 선택하는 전략은 크게 2 가지가 있다. 자연키 (natural key) : 비즈니스에 의미가 있는 키. ex) 주민등록번호, 이메일, 전화번호 대리키 (surrogate key) : 비즈니스와 관련없는 임의로 만들어진 키. ex) 오라클 시퀀스, auto_increment, 키생성 테이블 자연키보다는 대리 키를 권장한다. ","date":"2018-12-23","objectID":"/jpa-programming4/:7:12","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.7 필드와 컬럼 매핑 : 레퍼런스 ","date":"2018-12-23","objectID":"/jpa-programming4/:8:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.7.1 @Column @Column 은 객체 필드를 테이블 컬럼에 매핑한다. 자바 기본 타입에 @Column 을 사용하면, nullable=false 로 지정하는 것이 안전하다. 속성 기능 기본값 name 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름 nullable(DDL) null 값의 허용 여부 설정. false 로 설정시 not null 제약조건 true unique(DDL) 한 컬럼에 간단한 유니크 제약조건을 걸 때 사용 columnDefinition(DDL) 데이터베이스 컬럼 정보를 직접 줄 수 있다. length(DDL) 문자 길이 제약조건, String 타입에만 사용 255 precision, scale(DDL) BigDecimal/BigInteger 타입에서 사용. precision 은 소수점을 포함한 전체 자리수, scale 은 소수의 자리수 precision = 19, scale = 2 ","date":"2018-12-23","objectID":"/jpa-programming4/:8:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.7.2 @Enumerated 자바의 enum 타입을 매핑할 때 사용한다. EnumType.ORDINAL : enum 에 정의된 순서대로 데이터베이스에 저장된다. 장점 : 저장되는 데이터 크기가 작다. 단점 : 이미 저장된 enum 순서를 변경할 수 없다. EnumType.STRING : enum 이름을 데이터베이스에 저장. (권장) 장점 : 저장된 enum 순서가 바뀌거나 enum이 추가되어도 안전 단점 : 데이터베이스에 저장되는 크기가 ORINAL 에 비해 크다. ","date":"2018-12-23","objectID":"/jpa-programming4/:8:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.7.3 @Temporal 날짜 타입 (java.util.Date, java.util.Calendar) 을 매핑할 때 사용. TemporalType.DATE, TemporalType.TIME, TemporalType.TIMESTAMP ","date":"2018-12-23","objectID":"/jpa-programming4/:8:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.7.4 @Lob 데이터베이스의 BLOB, CLOB 타입과 매핑된다. @Lob 에는 속성을 지정할 수 없으므로, 매핑하는 필드 타입이 문자면 CLOB, 나머지는 BLOB 으로 매핑한다. @Lob private String lobString; // CLOB @Lob private byte[] lobByte; // BLOB CLOB : String, char[], java.sql.CLOB BLOB : byte[], java.sql.BLOB ","date":"2018-12-23","objectID":"/jpa-programming4/:8:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.7.5 @Transient 데이터베이스에 저장하지도 조회하지도 않는다. 객체에 어떤 값을 임시로 보관하고 싶을 때 사용한다. ","date":"2018-12-23","objectID":"/jpa-programming4/:8:5","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"4.7.6 @Access JPA 가 엔티티 데이터에 접근하는 방식을 지정 필드접근 : AccessType.FIELD 로 지정한다. 필드에 직접 접근하며, 필드 접근 권한이 private 이어도 접근 가능하다. 프로퍼티 접근 : AccessType.PROPERTY 로 지정. 접근자를 사용한다. ","date":"2018-12-23","objectID":"/jpa-programming4/:8:6","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 4장 엔티티 매핑","uri":"/jpa-programming4/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":" 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-18","objectID":"/jpa-programming3-2/:0:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/jpa-programming3-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.5 플러시 플러시(flush()) 는 영속성 컨텍스트의 내용을 데이터베이스에 반영한다. 영속성 컨텍스트의 변경 내용을 데이터베이스와 동기화 하는 것이 플러시이다. 플러시를 실행하면 변경 감지가 동작하여 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. =\u003e 수전된 엔티티는 수정 쿼리를 만들어 쓰기지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다. 플러시 방법 em.flush() 로 직접 호출. 트랜잭션 커밋 시 플러시 자동 호출 JPA 는 트랜잭션을 커밋할 때 플러시를 자동으로 호출한다. JPQL 쿼리 실행시 플러시 자동 호출 JPQL 이나 Criteria 같은 객체 지향 쿼리를 통하여 실행할때 플러시를 자동으로 호출한다. 식별자를 기준으로 조회하는 find() 메소드를 호출할 때는 플러시가 실행되지 않는다. // JPQL 시 자동 플러시 em.persist(memberA); em.persist(memberB); em.persist(memberC); // 중간에 JPQL 실행 // 조회시 memberA, memberB, memberC 도 쿼리결과에 포함된다. query = em.createQuery(\" SELECT m FROM Member m \", Member.class); List\u003cMember\u003e members = query.getResultList(); ","date":"2018-12-18","objectID":"/jpa-programming3-2/:1:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/jpa-programming3-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.5.1 플러시 모드 옵션 javax.persistence.FlushModeType 사용 FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시값 (별도로 지정하지않으면 기본값) FlushModeType.COMMIT : 커밋할때만 플러시 em.setFlushMode(FlushModeType.COMMIT); // 플러시모드 직접 설정 ","date":"2018-12-18","objectID":"/jpa-programming3-2/:1:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/jpa-programming3-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.6 준영속 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 된 것을 준영속 상태라고 한다. 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다. 개발자가 직접 준영속 상태로 만드는 일은 드물다. 준영속 상태를 만드는방법 em.detach(엔티티) : 특정 엔티티만 준영속 상태로 전환 em.clear() : 영속성 컨텍스트를 완전히 초기화 em.close() : 영속성 컨텍스트를 종료 ","date":"2018-12-18","objectID":"/jpa-programming3-2/:2:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/jpa-programming3-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.6.1 엔티티를 준영속 상태로 전환 : detach() 1차 캐시부터 쓰기 지연 SQL 저장소 까지 해당 엔티티를 관리하기 위한 모든 정보가 제거 ","date":"2018-12-18","objectID":"/jpa-programming3-2/:2:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/jpa-programming3-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.6.2 영속성 컨텍스트 초기화 : clear() 영속성 컨텍스트의 모든 것이 초기화 되버린다. 영속성 컨텍스트를 제거하고 새로 만든 것과 같다. ","date":"2018-12-18","objectID":"/jpa-programming3-2/:2:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/jpa-programming3-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.6.3 영속성 컨텍스트 종료 : clese() 영속성 컨텍스트가 종료되었다. ","date":"2018-12-18","objectID":"/jpa-programming3-2/:2:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/jpa-programming3-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.6.4 준영속 상태의 특징 거의 비영속 상태에 가깝다. : 1차캐시, 쓰기지연, 변경감지, 지연로딩을 포함한 영속성 컨텍스트의 기능이 동작하지 않는다. 식별자 값을 가지고 있다. : 준영속 상태에서는 이미 한 번 영속 상태였으므로 식별자 값을 가지고 있다. 지연 로딩을 할 수 없다. ","date":"2018-12-18","objectID":"/jpa-programming3-2/:2:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/jpa-programming3-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.6.5 병합 : merge() 준영속 상태의 엔티티를 다시 영속 상태로 변경 할 때 사용한다. 병합은 파라미터로 넘어온 엔티티의 식별자 값으로 영속성 컨텍스트를 조회하고 찾는 엔티티가 없으면 데이터베이스를 조회하며, 데이터베이스에도 조회하지 못하면 새로운 엔티티를 생성해 병합한다. 병합은 준영속, 비영속을 신경 쓰지 않는다. 병합은 save or update 의 기능을 수행한다. 준영속 병합 비영속 병합 병합은 비영속 엔티티도 영속상태로 만들 수 있다. Member member = new Member(); Member newMember = em.merge(member); tx.commit(); [이미지 출처] http://ptgmedia.pearsoncmg.com/images/chap8_9780131587564/elementLinks/08fig01.jpg ","date":"2018-12-18","objectID":"/jpa-programming3-2/:2:5","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - 플러시, 준영속","uri":"/jpa-programming3-2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":" 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-17","objectID":"/jpa-programming3-1/:0:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"JPA 가 제공하는 기능 엔티티와 테이블을 매핑하는 설계 부분 매핑하는 엔티티를 실제 사용하는 부분 ","date":"2018-12-17","objectID":"/jpa-programming3-1/:1:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.1 엔티티 매니저 팩토리와 엔티티 매니저 ","date":"2018-12-17","objectID":"/jpa-programming3-1/:2:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"EntityManagerFactory EntityManagerFactory 는 이름 그대로 EntityManager 를 만드는 공장이다. 공장을 만드는 비용은 상당히 크다. 그러므로 한 개만 만들어서 애플리케이션 전체에 공유하도록 설계해야 한다. EntityManagerFactory 는 여러 스레드에서 동시에 접근해도 안전하므로 서로 다른 스레드간 공유해도 된다. JPA 구현체들은 EntityManagerFactory 생성시 커넥션 풀을 만든다. // MET-INF/persistence.xml 의 정보를 바탕으로 생성한다. EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"jpabook\"); ","date":"2018-12-17","objectID":"/jpa-programming3-1/:2:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"EnitityManager EntityManager 의 경우 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간 절대 공유해서는 안된다. 엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. (ex. 트랜잭션을 시작할 때 커넥션을 획득한다.) // 공장에서 엔티티 매니저 생성, 비용이 거의 들지 않는다. EntityManager em = emf.createEntityManager(); ","date":"2018-12-17","objectID":"/jpa-programming3-1/:2:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.2 영속성 컨텍스트 영속성 컨텍스트 (persistence context) 는 엔티티를 영구 저장하는 환경 이다. 영속성 컨텍스트는 엔티티를 조회, 보관 등 관리하는 곳으로 눈에 보이지 않는 논리적인 개념이다. 엔티티 매니저를 생성할 때 하나 만들어지며 엔티티 매니저를 통해 영속성 컨텍스트에 접근 및 관리 할 수 있다. // 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다. em.persist(member); 여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근 할 수도 있다. ","date":"2018-12-17","objectID":"/jpa-programming3-1/:3:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.3 엔티티의 생명주기 ","date":"2018-12-17","objectID":"/jpa-programming3-1/:4:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"엔티티의 4가지 상태 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태 영속 (managed) : 영속성 컨텍스트에 저장된 상태 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제 (removed) : 삭제된 상태 [그림] 엔티티 생명주기 ","date":"2018-12-17","objectID":"/jpa-programming3-1/:4:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"비영속 비영속 상태는 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다. // 객체를 생성한 상태(비영속) Member member = new Member(); member.setId(\"memberId\"); member.setUsername(\"홍길동\"); ","date":"2018-12-17","objectID":"/jpa-programming3-1/:4:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"영속 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태. 영속성 컨텍스트가 관리하는 엔티티를 영속 상태 라 한다. em.find() 나 JPQL 을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태다. // 객체를 저장한 상태(영속) em.persist(member); ","date":"2018-12-17","objectID":"/jpa-programming3-1/:4:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"준영속 영속성 컨텍스트가 관리하던 영속상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다. 준영속 상태로 만들려면 em.detach() 나 em.close() 를 호출하여 영속성 컨텍스트를 닫거나 또는 em.clear() 영속성 컨텍스트를 초기화 하는 방법이 할때 준영속 상태가 된다. // 회원 엔티티를 영속성 컨텍스트에서 분리 (준영속 상태) em.detach(member); ","date":"2018-12-17","objectID":"/jpa-programming3-1/:4:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"삭제 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다. // 객체를 삭제한 상태(삭제) em.remove(member); ","date":"2018-12-17","objectID":"/jpa-programming3-1/:4:5","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.4 영속성 컨텍스트의 특징 영속성 컨텍스트와 식별자 값 영속상태는 식별자 값이 반드시 있어야 한다. 영속성 컨텍스트는 엔티티를 식별자 값(@Id 로 테이블의 기본키와 매핑한 값) 으로 구분한다. 영속성 컨텍스트와 데이터 베이스 저장 JPA 는 보통 트랜잭션을 commit 하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터 베이스에 반영한다. 이것을 플러시(flush) 라고 한다. 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다. 1차 캐시 동일성 보장 트랜잭션을 지원하는 쓰기 지연 변경 감지 지연 로딩 ","date":"2018-12-17","objectID":"/jpa-programming3-1/:5:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.4.1 엔티티 조회 영속성 컨텍스트는 내부에 캐시를 가지고 있으며 이것을 1차 캐시라고 한다. 영속 상태의 엔티티는 모두 이곳에 저장된다. 영속성 컨텍스트 내부에 Map 이 하나 있는데 키는 @Id 로 매핑한 식별자고 값은 엔티티 인스턴스 이다. 1차 캐시의 키는 식별자 값이며 기본적으로 데이터베이스의 기본키와 매핑되어 있다. 영속성 컨텍스트 1차 캐시 회원 엔티티는 아직 데이터베이스에 저장되지 않았다. // 엔티티를 생성한 상태 (비영속) Member member = new Member(); member.setId(\"member1\"); member.setUserName(\"회원\"); em.persist(member); // 엔티티를 영속 1차 캐시에서 조회 em.find() 를 호출하면 우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다. Member findMember = em.find(Member.class, \"member1\"); 데이터베이스에서 조회 // 1차 캐시에 없는 member2 인스턴스를 조회 Member findMember2 = em.find(Member.class, \"member2\"); 만약 em.find() 를 호출했는데 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터 베이스를 조회하여 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후 반환한다. em.find(Member.class, \"member2\") 를 실행 member2 가 1차 캐시에 없으므로 데이터베이스에서 조회 조회한 데이터로 member2 엔티티를 생성하여 1차 캐시에 저장 (영속상태) 조회한 엔티티 인스턴스를 반환 영속성 엔티티의 동일성 보장 Member a = em.find(Member.class, \"member1\"); Member b = em.find(Member.class, \"member1\"); // 결과값은 true. System.out.println(a == b); em.find(Member.class, \"member1\") 를 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다. ","date":"2018-12-17","objectID":"/jpa-programming3-1/:5:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.4.2 엔티티 등록 // 엔티티 매니저 생성 EntityManager em = emf.createEntityManager(); // 트랜잭션 기능 획득 EntityTransaction transaction = em.getTransaction(); transaction.begin(); // 트랜잭션 시작 em.persist(memberA); em.persist(memberB); // 이때까지는 INSERT SQL 을 데이터베이스에 보내지 않는다. // 커밋하는 순간 INSERT SQL 을 보낸다. transaction.commit(); // 트랜잭션 커밋 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL 을 모아둔다. 그리고 트랜잭션을 커밋할때 모아둔 커밋을 데이터 베이스로 보낸다. 트랜잭션을 커밋할때 데이터베이스에 flush 가 되며 이것을 쓰기 지연transactional write-behind 이라 한다. flush 란 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 작업이며 이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다. 트랜잭션을 지원하는 쓰기 지연이 가능한 이유 등록 쿼리를 그때 그때 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 데이터베이스에 반영되지 않는다. 어떻게든 커밋 직전에만 데이터베이스에 SQL 을 전달해도 되기 때문에 쓰기 지연이 가능하다. 내부 쿼리 저장소에 저장한 쿼리를 데이터베이스에 한 번에 전달함으로써 성능을 최적화 할 수 있다. ","date":"2018-12-17","objectID":"/jpa-programming3-1/:5:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.4.3 엔티티 수정 엔티티의 변경사항을 감지하여 데이터베이스에 자동으로 반영하는 기능을 변경감지dirty checking 이라고 한다. // 엔티티 매니저 생성 EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); // 영속 엔티티 조회 Member memberA = em.find(Member.class, \"memberA\"); memberA.setUsername(\"riley\"); memberA.setAge(10); // em.update(memberA); // 이런 코드는 필요하지 않다. transaction.commit(); JPA 는 엔티티를 영속성 컨텍스트에 보관할때, 최초 상태를 복사해서 저장해며 이것을 스냅샷 이라고 한다. 플러시 시점에 스냅샷과 엔티티를 비교하여 변경된 엔티티를 찾는다. 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티만 적용된다. JPA 를 통하여 모든 필드를 업데이트 했을때 데이터베이스에 보내는 데이터 전송량이 증가하는 단점이 있다. 모든 필드를 사용하면 수정쿼리가 항상 같다. (물론 바인딩되는 데이터는 다름) 따라서 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용이 가능하다. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스에서는 이전에 파싱한 쿼리를 재사용한다. 필드가 많거나 저장되는 내용이 너무 크다면 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성하는 전략을 사용한다. // org.hibernate.annotations.DynamicUpdate @Entity @org.hibernate.annotations.DynamicUpdate @Table(name = \"Memeber\") public class Member {...} org.hibernate.annotations.DynamicUpdate 어노테이션을 사용하면 수정된 데이터만 사용해서 동적으로 UPDATE SQL 을 생성한다. 저장할때 데이터가 존재하는 필드만 INSERT SQL 을 동적으로 생성시에는 @DynamicInsert 를 사용한다. ","date":"2018-12-17","objectID":"/jpa-programming3-1/:5:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"3.4.4 엔티티 삭제 // 엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다. Member memberA = em.find(Member.class, \"memberA\"); em.remove(memberA); 엔티티 삭제도 엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 데이터베이스에 삭제 쿼리를 전달한다. em.remove(memberA) 를 호출하는 순간 memberA 는 영속성 컨텍스트에서 제거된다. ","date":"2018-12-17","objectID":"/jpa-programming3-1/:5:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"이미지 출처 http://ptgmedia.pearsoncmg.com/images/chap8_9780131587564/elementLinks/08fig01.jpg ","date":"2018-12-17","objectID":"/jpa-programming3-1/:6:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 3장 영속성 관리 - EntityManagerFactory, EntityManager, 영속성컨텍스트, 엔티티 생명주기, 영속성컨텍스트의 특징","uri":"/jpa-programming3-1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":" 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-15","objectID":"/jpa-programming2/:0:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"2.2 H2 데이터베이스 설치 H2DB 는 자바 기반의 오픈소스 관계형 데이터 베이스이다. 별도의 설치과정이 필요하지 않고 용량도 1.7M 로 가볍다. SQL 문법은 다른 DBMS 와 마찬가지로 표준 SQL 이 대부분 지원된다. ","date":"2018-12-15","objectID":"/jpa-programming2/:1:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"H2 데이터 베이스 설치방법 아래 링크에서 zip 파일을 내려받아 압축을 푼다. 링크 - http://www.h2database.com/html/main.html 압축을 푼 곳에서 bin/h2.sh 를 실행한다. 실행이 완료되면 http://localhost:8082 로 접속하면 H2에 접속할 수 있는 화면이 나온다. -- 회원테이블을 생성 CREATE TABLE MEMBER ( ID VARCHAR(255) NOT NULL, -- 아이디(기본키) NAME VARCHAR(255), -- 이름 AGE INTEGER NOT NULL, -- 나이 PRIMARY KEY (ID) ) ","date":"2018-12-15","objectID":"/jpa-programming2/:1:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"2.3 라이브러리와 프로젝트 구조 ","date":"2018-12-15","objectID":"/jpa-programming2/:2:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"JPA 구현체인 하이버네이트 사용을 위한 라이브러리 hibernate-core : 하이버네이트 라이브러리 hibernate-entitymanager : 하이버네이트가 JPA 구현체로 동작하도록 JPA 표준을 구현한 라이브러리. 이 라이브러리를 지정하면 hibernate-core 와 hibernate-jpa-2.1-api 라이브러리도 함께 내려 받는다. hibernate-jpa-2.1-api : JPA 2.1 표준 API를 모아둔 라이브러리 build.gradle dependencies { // h2 접속을 위한 라이브러리 implementation ('com.h2database:h2:1.4.199') implementation ('org.hibernate:hibernate-entitymanager:5.4.3.Final') testCompile group: 'junit', name: 'junit', version: '4.12' } ","date":"2018-12-15","objectID":"/jpa-programming2/:2:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"2.4 객체 매핑 @Entity : 엔티티 클래스를 나타내며 이 클래스를 테이블과 매핑한다고 JPA 에 알려준다. @Table : 엔티티 클래스에서 매핑할 테이블 정보를 명시한다. name 속성을 사용하여 매핑할 수 있으며, 이 어노테이션을 생략할 경우 클래스 이름을 테이블 이름으로 매핑한다. @Id : 엔티티 클래스 필드의 테이블 기본키 Primary Key 에 매핑한다. 이렇게 @Id 가 사용된 필드를 식별자 필드라 한다. @Column : 필드를 컬럼에 매핑한다. 매핑정보가 없는 필드 : 매핑 어노테이션을 생략하면 필드명을 사용해서 컬럼명을 매핑한다. 만약 대소문자를 구분하는 데이터베이스를 사용하면 명시적으로 매핑해야만 한다. package jpabook.start; // JPA 가 제공하는 매핑 어노테이션을 추가 import javax.persistence.*; @Entity @Table(name = \"MEMBER\") public class Member { @Id @Column(name = \"ID\") private String id; // 아이디 @Column(name = \"NAME\") private String username; // 이름 private Integer age; // 나이 // Getter, Setter // ... } ","date":"2018-12-15","objectID":"/jpa-programming2/:3:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"2.5 persistence.xml 설정 JPA 는 persistence.xml 을 사용해서 필요한 설정정보를 관리한다. 이 설정 파일이 META-INF/persistence.xml 클래스 패스 경로에 있으면 별도의 설정없이 JPA 가 인식할 수 있다. \u003cpersistence-unit name=\"jpabook\"\u003e JPA 설정은 영속성 유닛 persistence-unit 이라는 것부터 시작하는데 일반적으로 연결할 데이터베이스당 하나의 영속성 유닛을 등록한다. ","date":"2018-12-15","objectID":"/jpa-programming2/:4:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"데이터베이스 방언 JPA 는 특정 데이터베이스에 종속적이지 않은 기술이다. 각 데이터베이스는 데이터 타입, 제공 함수명, 페이징처리 등 제공하는 SQL 문법과 함수가 조금씩 다르다. SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능을 JPA 에서는 방언Dialect 라 한다. 하이버에니트를 포함한 대부분의 JPA 구현체들은 다양한 데이터베이스 방언 클래스를 제공한다. ","date":"2018-12-15","objectID":"/jpa-programming2/:4:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"각 데이터베이스별 방언클래스 https://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html_single/#configuration-optional-dialects ","date":"2018-12-15","objectID":"/jpa-programming2/:4:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"2.6 애플리케이션 개발 ","date":"2018-12-15","objectID":"/jpa-programming2/:5:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"2.6.1 엔티티 매니저 설정 엔티티 매니저 팩토리 생성 JPA 를 시작하기 위해서는 persistence.xml 설정 정보를 사용하여 엔티티 매니저 팩토리를 생성해야한다. 엔티티 매니저 팩토리는 persistence.xml설정 정보를 읽어 JPA 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서 커넥션 풀도 생성한다. 엔티티 매니저 팩토리는 생성 비용이 매우크므로 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다. 엔티티 매니저 생성 JPA 대부분의 기능을 엔티티 매니저에서 제공한다. 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 등록/수정/삭제/조회 할 수 있다. 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관련이 있으므로 스레드 간 공유하거나 재사용하면 안된다. 종료 사용이 끝난 엔티티 매니저와 엔티티 매니저 팩토리는 종료해야 한다. ","date":"2018-12-15","objectID":"/jpa-programming2/:5:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"2.6.2 트랜잭션 관리 JPA 를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션을 시작하려면 엔티티 매니저 에서 트랜잭션 API 를 받아와야 한다. 트랜잭션 API 를 사용하여 비즈니스 로직이 정상 동작하면 트랜잭션을 커밋 commit 하고 예외가 발생하면 rollback 한다. // 트랜잭션 기능 획득 EntityTransaction tx = em.getTransaction(); ","date":"2018-12-15","objectID":"/jpa-programming2/:5:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"2.6.4 JPQL JPA 는 SQL 을 추상화한 JSQP 이라는 객체 지향 쿼리 언어를 제공한다. JPQL 은 SQL 과 문법이 거의 유사하다. 차이점 JPQL 은 엔티티 객체 를 대상으로 쿼리한다. SQL 은 데이터베이스 테이블 을 대상으로 쿼리한다. // 목록 조회 TypedQuery\u003cMember\u003e query = em.createQuery(\" SELECT m FROM Member m \", Member.class); List\u003cMember\u003e members = query.getResultList(); ","date":"2018-12-15","objectID":"/jpa-programming2/:5:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 2장 JPA 시작","uri":"/jpa-programming2/"},{"categories":["Python"],"content":"파이썬의 변수와 객체 C 와 같은 언어에서 변수는 메모리 상 저장공간에 직접 값을 할당한다면, 파이썬에서 변수는 메모리상에 생성된 객체를 참조 하는 개념이다. \u003e\u003e\u003e x = 100 \u003e\u003e\u003e y = 100 \u003e\u003e\u003e x is y True # 257 부터는 서로 다른 객체로 생성됨. \u003e\u003e\u003e x = 257 \u003e\u003e\u003e y = 257 \u003e\u003e\u003e x is y False 위의 예제에서는 x 와 y 는 100 이라는 메모리상 같은 객체를 가리키고 있다.(= 같은 메모리 주소를 가리킨다.) 파이썬에서는 자주 사용하는 정수 범위(0-256) 는 메모리에 한 번만 올려두고 여러 변수가 가리키게 함으로써 메모리를 효과적으로 사용하고 있다. 자바에서 기본타입(Primitive Type) 을 wrapper class 를 사용하여 객체로 다루는 것과 비슷하게 동작한다. (하지만 자바의 경우는 100 이라는 값을 갖는 새로운 메모리 주소를 생성할 수 있다.) ","date":"2018-12-14","objectID":"/python-data-type/:1:0","tags":["Python"],"title":"[Python] Python의 자료형","uri":"/python-data-type/"},{"categories":["Python"],"content":"파이썬의 숫자 자료형 파이썬에서는 숫자를 정수(int), 실수(float), 복소수(complex) 로 구분한다. ","date":"2018-12-14","objectID":"/python-data-type/:2:0","tags":["Python"],"title":"[Python] Python의 자료형","uri":"/python-data-type/"},{"categories":["Python"],"content":"1. 정수형 (Integer) 정수를 표현하는 자료형으로 10 진수 이외에도 2진수, 8진수, 16진수 로도 표현 할 수 있다. \u003e\u003e\u003e a = 0o177 # 8진수 (Oo 또는 0O 시작) \u003e\u003e\u003e b = 0x8ff # 16진수 (Ox 시작) 파이썬에서는 정수 자료형에 오버플로우가 없다 ","date":"2018-12-14","objectID":"/python-data-type/:2:1","tags":["Python"],"title":"[Python] Python의 자료형","uri":"/python-data-type/"},{"categories":["Python"],"content":"2. 실수형 (Floating-point) 파이썬에서 실수형은 소수점이 포함된 숫자를 의미한다. 정수부가 0 인 소수는 0 을 생략 할 수 있다. \u003e\u003e\u003e .1 0.1 컴퓨터에서는 표준에 따라 부동소수점 방식으로 표현한다. (IEEE 부동 소수점방식) 부동소수점 방식에는 숫자를 정수로 된 유효숫자와 정수로 된 지수의 곱으로 표현한다. \u003e\u003e\u003e 123e2 # 123.0 x 100 = 12300.0 12300.0 💻 컴퓨터에서 부동 소수점에 의한 실수 표현은 오차가 존재한다. ","date":"2018-12-14","objectID":"/python-data-type/:2:2","tags":["Python"],"title":"[Python] Python의 자료형","uri":"/python-data-type/"},{"categories":["Python"],"content":"3. 복소수 (complex) 파이썬에서는 허수를 표시하려면 i 가 아닌 j 를 사용한다. \u003e\u003e\u003e a = 3 + 3j \u003e\u003e\u003e type(a) \u003cclass 'complex'\u003e \u003e\u003e\u003e a = complex(3, 3) \u003e\u003e\u003e a (3+3j) ","date":"2018-12-14","objectID":"/python-data-type/:2:3","tags":["Python"],"title":"[Python] Python의 자료형","uri":"/python-data-type/"},{"categories":["Python"],"content":"연산자 ","date":"2018-12-14","objectID":"/python-data-type/:3:0","tags":["Python"],"title":"[Python] Python의 자료형","uri":"/python-data-type/"},{"categories":["Python"],"content":"파이썬에서 사용하는 연산자 연산자 설명 + 덧셈 - 뺄셈 * 곱셈 / 나눗셈 // 나눗셈의 몫 % 나누셈의 나머지 ** 지수 연산자 +value 단항덧셈 -value 단항뺄셈 \u003e\u003e\u003e 2 + 2 4 \u003e\u003e\u003e 50 - 5 * 6 20 \u003e\u003e\u003e (50 - 5*6) / 4 5.0 \u003e\u003e\u003e 8 / 5 1.6 \u003e\u003e\u003e / 연산자의 경우 python2 에서는 항목에 따라 정수형으로 나누어 떨어지지 않을경우 소수점을 버림으로써 정수형을 유지하는 반면, python3 에서는 정수형으로 나누어 떨어지지 않을경우 자동으로 소수형으로 형 변환된 결과를 출력한다. Python 2.7.15 (default, Mar 14 2019, 22:47:06) [GCC 7.3.0] on linux2 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e 8 / 5 1 Python 3.7.0 (default, Mar 13 2019, 22:44:23) [GCC 7.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e 8 / 5 1.6 / 의 연산자는 항상 float 를 리턴함으로 정수형 결과를 리턴받고 싶다면 // 연산자를 이용하면 된다. ","date":"2018-12-14","objectID":"/python-data-type/:3:1","tags":["Python"],"title":"[Python] Python의 자료형","uri":"/python-data-type/"},{"categories":["Python"],"content":"인터프리터 환경에서 _ 활용 파이썬 인터프리터에서는 마지막으로 실행된 결과값이 _ 라는 변수에 저장된다. \u003e\u003e\u003e tax = 12.5 / 100 \u003e\u003e\u003e price = 100.50 \u003e\u003e\u003e price * tax 12.5625 \u003e\u003e\u003e price + _ 113.0625 \u003e\u003e\u003e round(_, 2) 113.06 ","date":"2018-12-14","objectID":"/python-data-type/:4:0","tags":["Python"],"title":"[Python] Python의 자료형","uri":"/python-data-type/"},{"categories":["Python"],"content":"문자열 파이썬의 문자열 표현식 : ''(Single quotes) 또는 \"\" (double quotes) 이스케이프 (\\) 를 사용하여 문자열 리터럴 내에 이스케이프 혹은 연속된 3개 이상의 따옴표 표현 할 수 있다. \u003e\u003e\u003e 'spam eggs' # single quotes 'spam eggs' \u003e\u003e\u003e 'doesn\\'t' # use \\' to escape the single quote... \"doesn't\" \u003e\u003e\u003e \"doesn't\" # ...or use double quotes instead \"doesn't\" 문자열은 + 로 연결할 수 있고 * 연산자로 반복시킬 수 있다. 두 개이상의 문자열 리터럴이 연속으로 나타나면 자동으로 이어 붙여준다. 변수들 끼리 혹은 변수와 리터럴을 이어 붙이려면 + 연산자를 사용해야 한다. \u003e\u003e\u003e 3 * 'un' + 'ium' 'unununium' \u003e\u003e\u003e 'Py''thon' 'Python' # 변수와 리터럴을 이어 붙이려면 + 사용 \u003e\u003e prefix = 'Py' \u003e\u003e\u003e prefix + 'thon' 'Python' ","date":"2018-12-14","objectID":"/python-data-type/:5:0","tags":["Python"],"title":"[Python] Python의 자료형","uri":"/python-data-type/"},{"categories":["Python"],"content":"pyenv? pyenv 는 하나의 시스템에서 여러 다양한 버전의 Python 을 관리하기 위한 관리 도구이다. 파이썬 버전을 사용자 단위 혹은 프로젝트별로 각각 다른 버전을 사용할 수 있다. ruby 의 rvm, Node.js 의 nvm 와 같은 역할을 하는 Version Manager 이다. https://github.com/pyenv/pyenv ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:1:0","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"pyenv 설치 ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:2:0","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"python 을 설치하는데 필요한 패키지 설치 $ sudo apt install curl git-core gcc make zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev libssl-dev ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:2:1","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"pyenv 소스 다운로드 Gibhub 저장소에서 최신 pyenv 소스를 클론하여 ~/.pyenv 경로에 설치한다. $ git clone https://github.com/pyenv/pyenv.git ~/.pyenv ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:2:2","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"환경변수 등록 사용하는 Shell 맞추어 환경변수 설정한다. bash shell 을 사용하는 경우 ~/.bash_profile 또는 ~/.bashrc $ echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.zshrc $ echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.zshrc $ echo -e 'if command -v pyenv 1\u003e/dev/null 2\u003e\u00261; then\\n eval \"$(pyenv init -)\"\\nfi' \u003e\u003e ~/.zshrc # 변경 사항 적용을 위한 Shell 재기동 $ exec \"$SHELL\" ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:2:3","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"pyenv 사용하기 ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:3:0","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"pyenv 설치 가능한 버전 확인 python 버전을 설치하기 전에 이 명령으로 설치 가능한 버전을 확인 할 수 있다. $ pyenv install --list # 설치가능한 python 버전을 보여준다. Available versions: 2.1.3 2.2.3 2.3.7 2.4.0 2.4.1 2.4.2 ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:3:1","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"install 명령어로 설치 $ pyenv install 3.7.2 Downloading Python-3.7.2.tar.xz... -\u003e https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tar.xz Installing Python-3.7.2... ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:3:2","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"설치된 모든 python 버전 보기 $ pyenv versions # 설치된 파이썬 버전이 출력 pyenv versions system 3.7.0 * anaconda3-5.3.1 (set by /home/riley/.pyenv/version ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:3:3","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"pyenv 명령어를 사용하여 전역 파이썬 버전 설정하기 $ pyenv global 3.7.0 $ python -V # 변경된 버전 출력 $ Python 3.7.0 ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:3:4","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"💡 오류 해결 ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:4:0","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"빌드 설치시 ModuleNotFoundError: No module named _ctypes 로 파이썬 빌드가 안될때 libffi-dev 를 설치한다. https://stackoverflow.com/a/35460842 # libffi-dev $ apt-get install -y libffi-dev ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:4:1","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Python"],"content":"참고 및 출처 리눅스에서 파이썬 설치 및 파이썬 버전관리하기 ","date":"2018-12-13","objectID":"/start-python-using-pyenv/:5:0","tags":["Python","pyenv"],"title":"[Python] pyenv를 이용하여 python 시작하기","uri":"/start-python-using-pyenv/"},{"categories":["Mastering Spring 5.0"],"content":"리액티브 시스템 새로운 디바이스 (모바일, 태블릿 등) real-time data 에 대한 수요 증가 대량의 프로세스 처리 로드 발생 데이터 볼륨이 기하급수적으로 증가 인프라 유지 보수 비용 증가 ","date":"2018-12-09","objectID":"/page-11-1/:1:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"Reactive 시스템 특징 Reactive manifesto : https://www.reactivemanifesto.org/ko Reative Manifesto 는 다음 네 가지 핵심 원칙에 따라 Reactive System 의 특성을 개략적으로 설명하고 있다. 반응성 (Responsive) : 모든 응답은 적시에 빠르고 일관된 대응을 제공하며 신뢰할수 있으며 일관된 서비스 품질을 제공한다. 회복력 (Resilient) : 각각의 구성요소 들이 분리되어 있기 때문에 구성요소 중 하나에 문제가 발생하더라도 전체 시스템이 다운되는 것을 방지하고 복구 할 수 있도록 보장한다. 또한 장애의 발생이 예외적인 현상이 아닌 정상적인 기능의 일부로 처리한다. 유연성 (Elastic) : 요청을 처리하기 위해 할당된 리소스를 늘리거나 줄임으로써 요청 로드의 변화에 대응할 수 있다. ( auto scale ) 메시지 기반(Message-driven) : 시스템의 구성요소들이 메세지(또는 이벤트) 를 통해 이루어진다. 여기에서 구성요소들은 컴포넌트, 서비스, 객체, API 무엇이라도 될 수 있으며 과거처럼 메서드 호출이나 RPC 같은 블로킹 방식으로 의사소통 하지 않고, 보내고 잊는(fire-and-forget) 방식으로 메시지를 주고 받으며 소통한다. ","date":"2018-12-09","objectID":"/page-11-1/:1:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"Reactive Keyworld A reactive stream should be non-blocking It should be a stream of data It should work asynchronously And it should be able to handle back pressure. ","date":"2018-12-09","objectID":"/page-11-1/:1:2","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"Non-Bloking ","date":"2018-12-09","objectID":"/page-11-1/:2:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"Bloking 블로킹은 요청이 발생하고 작업을 진행하는 동안 프로그램의 진행을 멈추고(block) 완료될 때까지 모든 일을 중단한 상태로 대기해야 하는 것을 블로킹 방식이라고 한다. ","date":"2018-12-09","objectID":"/page-11-1/:2:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"Blocking Java Socket 통신 예제 클라이언트가 접속할 때 까지 accept() 메서드는 항상 블로킹 된다. Socket clientSocket = serverSocket.accept(); ... String request, response; while ((request = in.readLine()) != null) { response = processRequest(request); out.println(response); if (\"Done\".equals(request)) { break; } } 또한 클라이언트가 보낸 스트림이 완료 또는 입력 끝 문자 ( Ctrl + C 입력 시) 를 보낼 때 까지 발생한다. 클라이언트가 많을 수록 스레드 수가 증가하고 서버에 심각한 성능저하 발생 -\u003e 대안으로 스레드 풀을 사용 ","date":"2018-12-09","objectID":"/page-11-1/:2:2","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"Non-Blocking 어떤 스레드에서 오류가 발생하거나 멈추었을 때 다른 쓰레드에게 영향을 끼치지 않도록 하는 방법이다. 요청한 작업(스레드) 이 진행 되는 동안 즉시 다음 작업을 처리함으로써 시스템 자원을 더 효율적으로 활욜이 가능하다. 그러나 요청한 작업 이후 후속 작업을 이어서 진행할 수 있도록 별도의 약속(Polling, Callback Function 등) 이 필요하다. this.selector = Selector.open(); ServerSocketChannel serverChannel = ServerSocketChannel.open(); serverChannel.configureBlocking(false); // bind server socket channel to port serverChannel.socket().bind(listenAddress); serverChannel.register(this.selector, SelectionKey.OP_ACCEPT); accept() 메서드가 블로킹 되지 않고 바로 리턴되기 때문에, 클라이언트가 연결 요청을 보내기 전까지 while 블록 코드가 쉴새 없이 반복되어 CPU가 과도하게 소비되는 문제점이 발생한다. 그래서 넌블로킹은 이벤트 리스너 역할을 하는 셀렉터(Selector) 를 사용한다. 이 Selector 를 넌블로킹 채널에 등록해 놓으면 클라이언트의 연결 요청이 들어오거나 데이터가 도착할 경우 채널은 Selector 에 통보한다. Selector는 통보한 채널들을 선택해 작업 스레드가 accept() 또는 read() 메소드를 실행한다. while (true) { int readyCount = selector.select(); if (readyCount == 0) { continue; } } ","date":"2018-12-09","objectID":"/page-11-1/:2:3","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"Backpressure ","date":"2018-12-09","objectID":"/page-11-1/:3:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"비동기식 데이터 스트림 처리에 대한 이슈 너무 큰 데이터 스트림 -\u003e busy waiting 너무 빠른 데이터 스트림 전송 속도 -\u003e out of memory exception Backpressure 는 안정적으로 처리하기에 너무 큰 데이터 혹은 데이터를 신뢰 있게 처리 할 수 있는 속도로 구독자에게 제공하는 방법이다. Reactive 데이터 스트림의 Push 와 Pull 을 관리하는 Buffer 를 사용하여 구독자는 특정 양의 데이터를 요청하고 소스는 구성된 데이터를 해당 데이터로 유동적으로 Push 와 Pull 을 하는 방식이다. ","date":"2018-12-09","objectID":"/page-11-1/:3:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"출처 및 참고 사이트 https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/ http://palpit.tistory.com/645 https://tech.peoplefund.co.kr/2017/08/02/non-blocking-asynchronous-concurrency.html https://medium.com/coderscorner/tale-of-client-server-and-socket-a6ef54a74763 http://www.zdnet.co.kr/view/?no=20161010104628 https://www.slideshare.net/dnnddane/why-reactivereactive-programming-spring-5 https://www.youtube.com/watch?v=UIrwrW5A2co ReactiveX History : https://ahea.wordpress.com/2017/02/03/reactive-history/ https://www.slideshare.net/ktoso/reactive-stream-processing-with-akka-streams https://www.e4developer.com/2018/04/28/springs-webflux-reactor-parallelism-and-backpressure/ ","date":"2018-12-09","objectID":"/page-11-1/:4:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.1 Reactive Programming","uri":"/page-11-1/"},{"categories":["Mastering Spring 5.0"],"content":"리액티브 스트림 ","date":"2018-12-09","objectID":"/page-11-2/:1:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.2 Spring Reactive - 1","uri":"/page-11-2/"},{"categories":["Mastering Spring 5.0"],"content":"의존성 추가 implementation ('org.reactivestreams:reactive-streams:1.0.2') implementation ('org.reactivestreams:reactive-streams-tck:1.0.2') ","date":"2018-12-09","objectID":"/page-11-2/:1:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.2 Spring Reactive - 1","uri":"/page-11-2/"},{"categories":["Mastering Spring 5.0"],"content":"리액티브 스트림의 구성요소 Publisher : 데이터 제공자. 구독한 구독자들에게 구독 정보를 토대로 데이터를 제공한다. Subscriber : 데이터 소모자. 제공자로부터 데이터를 받아 소모한다. Subscription : 구독 정보. Subscriber 는 Publisher 를 구독하여 데이터(n) 요청할 수 있다. // Publisher package org.reactivestreams; public interface Publisher\u003cT\u003e { void subscribe(Subscriber\u003c? super T\u003e var1); } // Subscriber package org.reactivestreams; public interface Subscriber\u003cT\u003e { void onSubscribe(Subscription var1); void onNext(T var1); void onError(Throwable var1); void onComplete(); } // Subscription package org.reactivestreams; public interface Subscription { void request(long var1); void cancel(); } Publisher void subscribe(Subscriber\u003c? super T\u003e var1); : Subscriber 객체를 매개변수로 입력받아 Publisher 가 Subscriber 관리 할 수 있다. 그리고 Subscriber 의 메소드를 사용할 수 있다. Subscriber onSubscribe() : Publisher 를 구독하게 되면 호출된다. onNext() : 비동기 식으로 Executor 를 통해 구독자에게 메세지를 게시할 수 있다. onError() : 에러가 발생 시 호출된다. onComplete() : 더 게시된 메세지 요소가 없을 경우 다음 작업을 수행한다. Subscription request() : Publisher 에게 게시된 데이터를 요청한다. cancel() : 데이터에 대한 요청을 취소한다. ","date":"2018-12-09","objectID":"/page-11-2/:1:2","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.2 Spring Reactive - 1","uri":"/page-11-2/"},{"categories":["Mastering Spring 5.0"],"content":"리액터 리액터는 스프링 피보탈 팀의 리액티브 프레임워크이며, 리액티브 스트림을 기반으로 한다. ","date":"2018-12-09","objectID":"/page-11-2/:2:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.2 Spring Reactive - 1","uri":"/page-11-2/"},{"categories":["Mastering Spring 5.0"],"content":"의존성 추가 build.gradle implementation ('io.projectreactor:reactor-core:3.2.5.RELEASE') testImplementation ('io.projectreactor:reactor-test:3.2.5.RELEASE') plugins { id 'java' id 'war' id 'org.springframework.boot' version '2.1.1.RELEASE' } apply plugin: 'java' apply plugin: 'io.spring.dependency-management' group 'com.mastering.spring' version '1.0-SNAPSHOT' sourceCompatibility = 1.11 repositories { mavenCentral() } dependencies { implementation ('org.springframework.boot:spring-boot-starter') implementation ('org.reactivestreams:reactive-streams:1.0.2') implementation ('org.reactivestreams:reactive-streams-tck:1.0.2') implementation ('io.projectreactor:reactor-core:3.2.5.RELEASE') testImplementation ('io.projectreactor:reactor-test:3.2.5.RELEASE') testImplementation ('org.springframework.boot:spring-boot-starter-test:2.1.2.RELEASE') testImplementation ('junit:junit:4.12') } ","date":"2018-12-09","objectID":"/page-11-2/:2:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.2 Spring Reactive - 1","uri":"/page-11-2/"},{"categories":["Mastering Spring 5.0"],"content":"Mono 와 Flux Mono 와 Flux 모두 Reactive Stream 의 Publisher 인터페이스를 구현하고 있으며, Reactor 에서 제공하는 여러 연산자(operators) 의 조합을 통해 스트림을 가공할 수 있다. Mono : 요소가 아예 없거나 하나의 결과만을 처리하기 위한 Reactor 객체 Flux : 결과가 0-N 개인 여러 개의 결과를 처리하는 Reactor 객체 package com.mastering.spring.reactive; import org.junit.Test; import reactor.core.publisher.Mono; import java.time.Duration; public class SpringReactiveTest { @Test public void monoExample() throws InterruptedException { // 5초 후에 하나의 요소를 방출한다. Mono\u003cString\u003e stubMonoWithADelay = Mono.just(\"Ranga\").delayElement(Duration.ofSeconds(5)); // 모노 이벤트를 수신하고 콘솔에 기록한다. stubMonoWithADelay.subscribe(System.out::println); // 테스트 실행시간을 지연시킨다. Thread.sleep(10000); } } /** * Consumer 를 명시적으로 정의 */ class SystemOutConsumer implements Consumer\u003cString\u003e { @Override public void accept(String s) { System.out.println(\"Received \" + s + \" at\" + new Date()); } } // 모노 이벤트를 수신하고 콘솔에 기록한다. // stubMonoWithADelay.subscribe(System.out::println); stubMonoWithADelay.subscribe(new SystemOutConsumer()); class WelcomeConsumer implements Consumer\u003cString\u003e { @Override public void accept(String s) { System.out.println(\"Welcome \" + s); } } // 모노 이벤트를 수신하고 콘솔에 기록한다. // stubMonoWithADelay.subscribe(System.out::println); stubMonoWithADelay.subscribe(new SystemOutConsumer()); stubMonoWithADelay.subscribe(new WelcomeConsumer()); @Test public void simpleFluxStream() { Flux\u003cString\u003e stubFluxStream = Flux.just(\"Jane\", \"Joe\"); stubFluxStream.subscribe(new SystemOutConsumer()); } } ","date":"2018-12-09","objectID":"/page-11-2/:2:2","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.2 Spring Reactive - 1","uri":"/page-11-2/"},{"categories":["Mastering Spring 5.0"],"content":"스프링 웹 리액티브 스프링 웹 리액티브는 스프링 프레임워크 5 의 새로운 기능 중 하나이다. 이 기능은 웹 애플리케이션의 리액티브 기능을 제공한다. 스프링 웹 리액티브는 스프링 MVC 와 동일한 기본 프로그래밍 모델을 기반으로 한다. ","date":"2018-12-09","objectID":"/page-11-2/:3:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.2 Spring Reactive - 1","uri":"/page-11-2/"},{"categories":["Mastering Spring 5.0"],"content":"웹 리액티브 스트림 의존성 추가 implementation ('org.springframework.boot:spring-boot-starter-webflux') 리액티브 컨트롤러 생성 @RestController public class StockPriceEventController { @GetMapping(\"/stocks/price/{stockCode}\") Flux\u003cString\u003e retrieveStockPriceHardcoded(@PathVariable(\"stockCode\") String stockCode) { return Flux.interval(Duration.ofSeconds(5)) .map(l -\u003e getCurrentDate() +\" : \" + getRandomNumber(100, 125)).log(); } private String getCurrentDate() { return (new Date()).toString(); } private int getRandomNumber(int min, int max) { return ThreadLocalRandom.current().nextInt(min, max + 1); } } HTML 뷰 생성 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e \u003cbutton id=\"subscribe-button\"\u003eGet Latest IBM Price\u003c/button\u003e \u003cul id=\"display\"\u003e\u003c/ul\u003e \u003c/p\u003e \u003cscript\u003e addEvent(\"click\", document.getElementById('subscribe-button'), () =\u003e registerEventSourceAndAddResponseTo(\"/stocks/price/IBM\", \"display\")); function registerEventSourceAndAddResponseTo(uri, elementId) { let stringEvents = document.getElementById(elementId); let stringEventSource = new EventSource(uri) stringEventSource.onmessage = (e) =\u003e { let newElement = document.createElement(\"li\"); newElement.innerHTML = e.data; stringEvents.appendChild(newElement); } } function addEvent(event, elem, func) { if (typeof (EventSource) !== 'undefined') { elem.addEventListener(event, func, false); } else { elem[event] = func; } } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2018-12-09","objectID":"/page-11-2/:3:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.2 Spring Reactive - 1","uri":"/page-11-2/"},{"categories":["Mastering Spring 5.0"],"content":"출처 및 참고 사이트 Java9 Reactive Stream API http://www.reactive-streams.org/ Java9 Reactive Stream 에 대한 자세한 설명 및 내용 참고 http://jess-m.tistory.com/18 https://grokonez.com/java/java-9/java-9-flow-api-reactive-streams ","date":"2018-12-09","objectID":"/page-11-2/:4:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 11.2 Spring Reactive - 1","uri":"/page-11-2/"},{"categories":["Mastering Spring 5.0"],"content":"스프링 5.0 마스터 스터디 학습 내용 정리입니다. ","date":"2018-12-09","objectID":"/page-6-1/:0:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.1 예외처리","uri":"/page-6-1/"},{"categories":["Mastering Spring 5.0"],"content":"1. 스프링 부트의 기본 예외처리 스프링부트의 기본 예외 형식은 throw 된 예외 메세지 와 함께 JSON 형태로 에러를 리턴한다. 브라우저경우 기본 오류 페이지 (Whilelabel Error Page) 를 출력한다. { \"timestamp\": \"2018-12-25T05:01:26.483+0000\", \"status\": 500, \"error\": \"Internal Server Error\", \"message\": \"Some Exception Occurred\", \"path\": \"/users/dummy-service\" } ","date":"2018-12-09","objectID":"/page-6-1/:1:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.1 예외처리","uri":"/page-6-1/"},{"categories":["Mastering Spring 5.0"],"content":"2. 스프링 사용자 정의 예외처리 스프링에서는 오류에 대한 응답을 사용자가 정의하는 여러 옵션을 제공한다. ","date":"2018-12-09","objectID":"/page-6-1/:2:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.1 예외처리","uri":"/page-6-1/"},{"categories":["Mastering Spring 5.0"],"content":"2.1 응답 메세지 사용자 정의 하기 주어진 ID 가 가지고 있는 todo 가 발견되지 않았을 때 발생시킬 사용자 정의 TodoNotFoundException 와 메세지 처리를 할 ExceptionResponse 객체를 생성한다. TodoNotFoundException.java package com.mastering.spring.springboot.exception; public class TodoNotFoundException extends RuntimeException { public TodoNotFoundException(String msg) { super(msg); } } ExceptionResponse.java package com.mastering.spring.springboot.bean; import java.util.Date; public class ExceptionResponse { private Date timestamp = new Date(); private String message; private String details; public ExceptionResponse(String message, String details) { super(); this.message = message; this.details = details; } public Date getTimestamp() { return timestamp; } public void setTimestamp(Date timestamp) { this.timestamp = timestamp; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public String getDetails() { return details; } public void setDetails(String details) { this.details = details; } } TodoNotFoundExcption 이 발생하면 ExceptionResponse Bean 을 사용해 응답을 반환할 컨트롤러를 생성한다. @ControllerAdvice @RestController public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(TodoNotFoundException.class) public final ResponseEntity\u003cExceptionResponse\u003e todoNotFound(TodoNotFoundException ex) { ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(), \"Any details you would want to add.\"); return new ResponseEntity\u003cExceptionResponse\u003e(exceptionResponse, new HttpHeaders(), HttpStatus.NOT_FOUND); } } ","date":"2018-12-09","objectID":"/page-6-1/:2:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.1 예외처리","uri":"/page-6-1/"},{"categories":["Mastering Spring 5.0"],"content":"2.2 모든 예외에 사용자 정의 예외처리 정의하기 아래 코드는 사용자 정의 예외 이외에 모든 예외에 대해 사용자 정의 예외 메세지를 응답하도록 설정한다. @ExceptionHandler(Exception.class) public ResponseEntity\u003cExceptionResponse\u003e defaultError(Exception ex) { ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(), \"알수없는 에러...\"); return new ResponseEntity\u003cExceptionResponse\u003e(exceptionResponse, new HttpHeaders(), HttpStatus.INTERNAL_SERVER_ERROR); } @ControllerAdvice 를 이용하여 @ExceptionHander 를 모든 패키지 및 컨트롤러에서 전역적으로 사용할 수 있도록 정의한다. @ExceptionHandler(TodoNotFoundException.class) 가 특정 에러 유형(클래스) 에 대해 예외처리 하도록 정의한다. 사용자 예외 처리가 되어 있지 않은 다른 예외는 스프링부트의 기본 예외처리 형태를 따른다. @RestController 을 사용하여 클라이언트에게 응답처리를 할 수 있게 한다. ","date":"2018-12-09","objectID":"/page-6-1/:2:2","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.1 예외처리","uri":"/page-6-1/"},{"categories":["Mastering Spring 5.0"],"content":"2.3 사용자 정의 에러에 특정 HTTP 응답 상태 지정하기 @ResponseStatus 어노테이션을 사용하여 커스텀 에러에 특정 HTTP 응답 상태를 지정할 수 있다. @ResponseStatus(HttpStatus.NOT_FOUND) public class TodoNotFoundException extends RuntimeException { public TodoNotFoundException(String msg) { super(msg); } } ","date":"2018-12-09","objectID":"/page-6-1/:2:3","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.1 예외처리","uri":"/page-6-1/"},{"categories":["Mastering Spring 5.0"],"content":"3. HTTP 응답 상태 코드 상세 응답코드 정의 : https://developer.mozilla.org/ko/docs/Web/HTTP/Status 응답 상태 상황 400 - BAD REQUEST 요청본문이 API 스펙을 충족하지 못하여 서버가 요청을 이해할 수 없음을 의미. 401 - UNAUTHORIZED 인증 또는 권한 부여 실패 403 - RESOURCE FORBIDDEN 클라이언트가 컨텐츠에 접근할 권리를 갖고 있지 않음. 401 과 다른 점은 클라이언트가 누구인지 알고 있음. 404 - RESOURCE NOT FOUND 요청한 리소스가 존재하지 않음 405 - METHOD NOT ALLOWED 지원되지 않는 오퍼레이션 (ex : GET 요청한 허용되는 리소스에 POST 요청을 시도) 500 - INTERNAL SERVER ERROR 서버에서 에러가 발생하여, 소비자는 이 문제를 해결 할 수 없음. ","date":"2018-12-09","objectID":"/page-6-1/:3:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.1 예외처리","uri":"/page-6-1/"},{"categories":["Mastering Spring 5.0"],"content":"4. ResponseStatusException (Spring 5 and Above) https://www.baeldung.com/exception-handling-for-rest-with-spring ","date":"2018-12-09","objectID":"/page-6-1/:4:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.1 예외처리","uri":"/page-6-1/"},{"categories":["Mastering Spring 5.0"],"content":"REST 성숙도 모델 (Richardson Maturity Model) Richardson Maturity Model 에서는 Restful Web Service 를 다음의 단계로 나누어 성숙도를 정의하고 있다. Level 0 : 원격 프로시저 호출 (Remote Procedure Invocation) 에 기반한 형태로 resource 구분 없이 설계된 HTTP API (http://server/getPosts, http://server/deletePosts, http://server/doThis, http://server/doThat 등) Level 1 : resource를 URI 통해 나타낸다. (명사 사용) 그러나, HTTP METHOD(GET,POST,PUT,DELETE 등) 사용하지 않는다. (http://server/accounts, http://server/accounts/10) Level 2 : resource를 URI + HTTP Method 를 사용하여 접근한다. (계정을 수정하려면 PUT, 계정을 생성하려면 POST 메서드를 수행한다.) Level 3 : HATEOAS. 요청한 정보 뿐만 아니라 요청한 정보에 관련한 URI 를 포함함으로써, 서비스 소비자가 할 수 있는 다음 조치에 대해서도 제공한다. ","date":"2018-12-09","objectID":"/page-6-2/:1:0","tags":["Spring Framework","HATEOAS"],"title":"[Mastering Spring 5.0] 6.2 HATEOAS","uri":"/page-6-2/"},{"categories":["Mastering Spring 5.0"],"content":"HATEOAS HATEOAS (Hypermedia as the Engine of Application State) 는 RESTful 아키텍쳐를 고유하게 유지하는 REST 응용 프로그램 아키텍쳐의 제약 사항이다. Hypermedia 라는 용어는 이미지, 텍스트, 동영상 등 다른 형식의 미디어에 대한 링크가 포함된 것을 의미한다. Hypermedia 의 유사한 개념을 RESTful 서비스에도 적용하여, 요청한 리소스에 대한 데이터 뿐만 아니라 관련 리소스 또는 의존 리소스의 URI 링크 를 응답에 포함시켜 서비스 소비자에게 제공하는 형태라고 볼 수 있다. ","date":"2018-12-09","objectID":"/page-6-2/:2:0","tags":["Spring Framework","HATEOAS"],"title":"[Mastering Spring 5.0] 6.2 HATEOAS","uri":"/page-6-2/"},{"categories":["Mastering Spring 5.0"],"content":"기존 RESTful API 의 단점 API 의 엔드포인트가 정해지면 이를 쉽게 변경하기가 어렵다. API 가 변경됨에 따라 이를 사용하는 모든 클라이언트 들이 함께 수정되어야 한다. API 가 수정되어야 하는 경우 API URL 에 버전명을 추가하거나 다른 API 를 지속적으로 추가하게 된다. 그렇게 되면 API URL 관리가 어려워진다. REST API 에 특정 작업을 수행하기 위해 데이터를 수집해야 한다거나, 해당 작업이 가능한지 여부를 판단하는 로직 모두 클라이언트에서 가져가야 한다. ","date":"2018-12-09","objectID":"/page-6-2/:2:1","tags":["Spring Framework","HATEOAS"],"title":"[Mastering Spring 5.0] 6.2 HATEOAS","uri":"/page-6-2/"},{"categories":["Mastering Spring 5.0"],"content":"HATEOAS 스프링부트에 적용하기 ","date":"2018-12-09","objectID":"/page-6-2/:3:0","tags":["Spring Framework","HATEOAS"],"title":"[Mastering Spring 5.0] 6.2 HATEOAS","uri":"/page-6-2/"},{"categories":["Mastering Spring 5.0"],"content":"1. 의존성 추가하기 스프링 부트에는 spring-boot-starter-hateoas 라는 HATEOAS 를 위한 스타터를 제공한다. 따라서 관련 종속성을 pom.xml 또는 build.gradle 에 추가한다. pom.xml \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-hateoas\u003c/artifactId\u003e \u003c/dependency\u003e build.gradle implementation ('org.springframework.boot:spring-boot-starter-hateoas') 아래는 spring-boot-starter-hateoas 의 중요한 의존성 중 하나는 HATEOAS 기능을 제공하는 spring-hateoas 이다. \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003cversion\u003e2.1.1.RELEASE\u003c/version\u003e \u003cscope\u003ecompile\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.hateoas\u003c/groupId\u003e \u003cartifactId\u003espring-hateoas\u003c/artifactId\u003e \u003cversion\u003e0.25.0.RELEASE\u003c/version\u003e \u003cscope\u003ecompile\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.plugin\u003c/groupId\u003e \u003cartifactId\u003espring-plugin-core\u003c/artifactId\u003e \u003cversion\u003e1.2.0.RELEASE\u003c/version\u003e \u003cscope\u003ecompile\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2018-12-09","objectID":"/page-6-2/:3:1","tags":["Spring Framework","HATEOAS"],"title":"[Mastering Spring 5.0] 6.2 HATEOAS","uri":"/page-6-2/"},{"categories":["Mastering Spring 5.0"],"content":"2. 리소스 링크를 반환하는 컨트롤러 구성 Response 값에 {name} 에 관련된 모든 응답을 검색하기 위한 링크를 반환하도록 설정한다. 기존 ResponseEntity 대신 Resource\u003cTodo\u003e 객체를 리턴하도록 소스를 수정한다. Resource class 로 도메인 객체를 wrapping 해주고 link 를 추가할 수 있다. @GetMapping(\"/users/{name}/todos/{id}\") public Resource\u003cTodo\u003e retrieveTodo(@PathVariable String name, @PathVariable int id) { Todo todo = todoService.retrieveTodo(id); if( todo == null ) { throw new TodoNotFoundException(\"Todo Not Found.\"); } // Todo 객체에 대한 리소스 객체를 생성한다. Resource\u003cTodo\u003e todoResource = new Resource\u003cTodo\u003e(todo); // 현재 컨트롤러의 Name 관련한 모든 할일 목록을 조회하는 링크를 parent 항목으로 추가한다. ControllerLinkBuilder linkBuilder = linkTo(methodOn(this.getClass()).retrieveTodos(name)); todoResource.add(linkBuilder.withRel(\"parent\")); return todoResource; } ","date":"2018-12-09","objectID":"/page-6-2/:3:2","tags":["Spring Framework","HATEOAS"],"title":"[Mastering Spring 5.0] 6.2 HATEOAS","uri":"/page-6-2/"},{"categories":["Mastering Spring 5.0"],"content":"3. 응답에 HATEOAS 링크 정보 확인하기 curl 명령어 혹은 POSTMAN 으로 요청한다. curl http://localhost:8080/users/Jack/todos/1 { \"id\": 1, \"user\": \"Jack\", \"desc\": \"Learn Spring MVC\", \"targetDate\": \"2018-12-25T07:59:23.073+0000\", \"done\": false, \"_links\": { \"parent\": { \"href\": \"http://localhost:8080/users/Jack/todos\" } } } 해당 URL 을 요청하면 _links 키 값에 모든 할일을 조회할 수 있는 링크가 포함된다. [참고] Building a Hypermedia-Driven RESTful Web Service - https://spring.io/guides/gs/rest-hateoas/ Hypermedia-driven REST API : https://m.blog.naver.com/tmondev/220391644590 [한글화 프로젝트] 1. Richardson 성숙도 모델(Richardson Maturity Model) : http://jinson.tistory.com/190 On choosing a hypermedia type for your API - HAL, JSON-LD, Collection+JSON, SIREN, Oh My! - https://sookocheff.com/post/api/on-choosing-a-hypermedia-format/ ","date":"2018-12-09","objectID":"/page-6-2/:3:3","tags":["Spring Framework","HATEOAS"],"title":"[Mastering Spring 5.0] 6.2 HATEOAS","uri":"/page-6-2/"},{"categories":["Mastering Spring 5.0"],"content":"Bean Validation 데이터 유효성 검증 (Validation) 은 모든계층에서 공통적으로 발생하는 작업이다. 만약 모든 계층에서 동일한 내용의 Validation 로직이 각각의 레이어별로 구현되어 있다면 코드 중복과 함께 각 계층별로 중구난방으로 구현된 검증로직간 불일치로 인하여 오류가 발생하기도 쉽다. [출처] https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/images/application-layers.png 이러한 Validation 중복을 피하기 위해 도메인의 검증 로직을 도메인 모델 자체에 묶어서 정의하기도 한다. 하지만 도메인 모델에 실제 코드로 Validation 로직을 표현한다면 도메인 모델 자체가 장황하지고 복잡해지게 된다. [출처] https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/images/application-layers2.png Java 에서는 위와 같은 문제를 해결하기 위해 어노테이션을 통한 Entity 와 Method 를 검증하기 위한 API 를 제공하고 있다. ","date":"2018-12-09","objectID":"/page-6-3/:1:0","tags":["Spring Framework","Bean Validation"],"title":"[Mastering Spring 5.0] 6.3 Bean Validation","uri":"/page-6-3/"},{"categories":["Mastering Spring 5.0"],"content":"Bean Validation 어노테이션을 통해 객체 모델에 대한 제약 조건을 표현 할 수 있다. 확장 가능한 방식으로 사용자 정의 제약 조건을 작성할 수 있다. 개체 및 개체 그래프를 검증하기 위한 API 를 제공한다. 메서드 및 생성자의 매개 변수를 확인하고 반환 값을 리턴하는 API 를 제공한다. 현지화 된 언어로 위반 사항을 보고한다. ","date":"2018-12-09","objectID":"/page-6-3/:1:1","tags":["Spring Framework","Bean Validation"],"title":"[Mastering Spring 5.0] 6.3 Bean Validation","uri":"/page-6-3/"},{"categories":["Mastering Spring 5.0"],"content":"Hibernate Validator Hibernate Validator 는 Bean Validation 명세에 대한 구현체이다. Bean Validation 2.0 에 대한 구현은 Hibernate Validator 6.0.1.Final 이며 Spring Boot 2.0 이상에서 이것을 사용하고 있다. ","date":"2018-12-09","objectID":"/page-6-3/:2:0","tags":["Spring Framework","Bean Validation"],"title":"[Mastering Spring 5.0] 6.3 Bean Validation","uri":"/page-6-3/"},{"categories":["Mastering Spring 5.0"],"content":"스프링 부트로 Bean Validation 시작하기 ","date":"2018-12-09","objectID":"/page-6-3/:3:0","tags":["Spring Framework","Bean Validation"],"title":"[Mastering Spring 5.0] 6.3 Bean Validation","uri":"/page-6-3/"},{"categories":["Mastering Spring 5.0"],"content":"프로젝트 설정 Hibernate Validator 는 spring-boot-web-start 프로젝트의 의존성으로 정의 된다. org.hibernate.validator:hibernate-validator:6.0.13.Final javax.validation:validation-api:2.0.1.Final ","date":"2018-12-09","objectID":"/page-6-3/:3:1","tags":["Spring Framework","Bean Validation"],"title":"[Mastering Spring 5.0] 6.3 Bean Validation","uri":"/page-6-3/"},{"categories":["Mastering Spring 5.0"],"content":"컨트롤러 메서드에 Bean Validation 활성화 Controller 메서드의 매개 변수에 @Valid 어노테이션을 추가함으로 유혀성 검사를 트리거 할 수 있도록 활성화 시킬 수 있다. 아래의 경우 POST 요청으로 들어온 매개변수를 바인딩 한 뒤 Todo 빈에 정의된 Validation 에 따라 유효성 검증을 하게 된다. @RequestMapping(method = RequestMethod.POST, path = \"/users/{name}/todos\") public ResponseEntity\u003c?\u003e add(@PathVariable String name, @Valid @RequestBody Todo todo) { Todo createTodo = todoService.addTodo(name, todo.getDesc(), todo.getTargetDate(), todo.isDone()); if(createTodo == null) { return ResponseEntity.noContent().build(); } URI location = ServletUriComponentsBuilder.fromCurrentRequest().path(\"/{id}\").buildAndExpand(createTodo.getId()).toUri(); return ResponseEntity.created(location).build(); } ","date":"2018-12-09","objectID":"/page-6-3/:3:2","tags":["Spring Framework","Bean Validation"],"title":"[Mastering Spring 5.0] 6.3 Bean Validation","uri":"/page-6-3/"},{"categories":["Mastering Spring 5.0"],"content":"도메인 객체에 Bean Validation 정의 public class Todo { private int id; @NotNull private String user; @Size(min = 9, message = \"Enter at least 10 Characters.\") private String desc; // getter setter } @NotNull - user 필드의 값이 비어 있지 않은지 확인한다. @Size(min = 9, message = “Enter at least 10 Characters.”) - desc 필드 값의 문자가 9 자 이상인지 확인한다. Bean 을 검증하는 데 사용할 수 있는 어노테이션은 많다. 다음은 몇 가지 Bean Validation 어노테이션이다. @AssertTrue, @AssertFalse - 어노테이션 정의 된 필드 값이 true 혹은 false 인지 확인 한다. @Future - 어노테이션 정의 필드 된 값이 미래 날짜여야 한다. @Past - 어노테이션 정의 필드 값이 과거의 날짜여야 한다. @Max - 어노테이션 정의 필드 값이 지정된 최대값 보다 작거나 같은 숫자여야 한다. @Min - 어노테이션 정의 필드 값이 지정된 최소값 보다 크거나 같은 숫자여야 한다. @NotNull - 어노테이션 정의 필드 값이 null 이면 안된다. @Pattern - 어노테이션 정의 필드 값의 {@code CharSequence} 요소는 지정된 정규 표현식과 일치해야 한다. 정규표현식은 자바 정규 표현식 규칙을 따른다. @Size - 어노테이션 정의 필드 값의 크기는 지정된 범위 내에 있어야 한다. [참고] beanvalidation.org - https://beanvalidation.org/ ","date":"2018-12-09","objectID":"/page-6-3/:3:3","tags":["Spring Framework","Bean Validation"],"title":"[Mastering Spring 5.0] 6.3 Bean Validation","uri":"/page-6-3/"},{"categories":["Mastering Spring 5.0"],"content":"REST 서비스 문서의 자동화 REST API 심플하게 설계되면 좋겠지만, 소비자의 요구사항 또는 서비스가 커짐에 따라 API 가 점점 복잡해지고 관리해야할 API 개수도 점점 늘게 된다. 협업을 위해서는 API 는 반드시 문서화 되어야 하는데, 소스 변경사항과 동기화 시키기가 매번 번거롭다. 이러한 문제를 해결하기 위해 REST API 서비스 문서(스펙)을 자동화 하는 툴이 등장하게 되었다. ","date":"2018-12-09","objectID":"/page-6-4/:1:0","tags":["Spring Framework","Swagger"],"title":"[Mastering Spring 5.0] 6.4 Swagger","uri":"/page-6-4/"},{"categories":["Mastering Spring 5.0"],"content":"주요 API Spec 자동화 라이브러리 SLATE : https://github.com/lord/slate Swagger : https://swagger.io/ API Blueprint : https://apiblueprint.org/ ","date":"2018-12-09","objectID":"/page-6-4/:1:1","tags":["Spring Framework","Swagger"],"title":"[Mastering Spring 5.0] 6.4 Swagger","uri":"/page-6-4/"},{"categories":["Mastering Spring 5.0"],"content":"Swagger2 Swagger 2 는 RESTful API 를 설명하고 문서화하는데 사용되는 오픈소스 라이브러리이다. 특정 언어에 구애 받지 않으며, HTTP 이외에 새로운 기슬과 프로토콜 확장이 가능하다. HTML, Javasript CSS 를 통하여 API 문서를 동적으로 생성할 수 있는 Swagger UI 라이브러리가 함께 제공된다. Swagger2 Spec 은 몇 가지 구현체가 있는데, Springboot 프로젝트의 경우 Springfox 구현체가 주로 사용된다. ","date":"2018-12-09","objectID":"/page-6-4/:2:0","tags":["Spring Framework","Swagger"],"title":"[Mastering Spring 5.0] 6.4 Swagger","uri":"/page-6-4/"},{"categories":["Mastering Spring 5.0"],"content":"스프링부트 프로젝트에 swagger 적용하기 의존성 추가 Springfox Spec 의 Swagger 와 Swagger UI 를 pom.xml 또는 build.gradle 에 추가한다. pom.xml \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003cscope\u003ecompile\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003cscope\u003ecompile\u003c/scope\u003e \u003c/dependency\u003e build.gradle implementation('io.springfox:springfox-swagger2:2.9.2') implementation('io.springfox:springfox-swagger-ui:2.9.2') ","date":"2018-12-09","objectID":"/page-6-4/:2:1","tags":["Spring Framework","Swagger"],"title":"[Mastering Spring 5.0] 6.4 Swagger","uri":"/page-6-4/"},{"categories":["Mastering Spring 5.0"],"content":"Swagger 프로젝트 설정 /src/main/com/mastering/sping/springboot/config/SwaggerConfig.java @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()).build(); } } @Configuration : 스프링 구성파일을 정의한다. @EnableSwagger2 : 스웨거 지원을 가능하게 하는 어노테이션. Docket : 스웨서 스프링 MVC 프레임워크를 사용해 스웨거 문서 생성을 설정하는 간단한 Builder Class new Docket(DocumentationType.SWAGGER_2) : 스웨거 2를 사용할 스웨거 버전으로 설정한다. .apis(RequestHandlerSelectors.any()).paths(PathSelectors.any()) : 문서의 모든 API 와 경로를 포함한다. ","date":"2018-12-09","objectID":"/page-6-4/:2:2","tags":["Spring Framework","Swagger"],"title":"[Mastering Spring 5.0] 6.4 Swagger","uri":"/page-6-4/"},{"categories":["Mastering Spring 5.0"],"content":"Swagger API 명세 확인하기 Swagger 설정이 완료되면 서버를 기동 후, http://localhost:8080/v2/api-docs 로 스웨거 API 문서를 시작할 수 있다. ","date":"2018-12-09","objectID":"/page-6-4/:2:3","tags":["Spring Framework","Swagger"],"title":"[Mastering Spring 5.0] 6.4 Swagger","uri":"/page-6-4/"},{"categories":["Mastering Spring 5.0"],"content":"Swagger UI 문서 확인하기 Swagger UI 는 의존성 라이브러리 io.springfox:springfox-swagger-ui 를 통해 활성화 된다. http://localhost:8080/swagger-ui.html 로 문서를 확인 할 수 있다. ","date":"2018-12-09","objectID":"/page-6-4/:2:4","tags":["Spring Framework","Swagger"],"title":"[Mastering Spring 5.0] 6.4 Swagger","uri":"/page-6-4/"},{"categories":["Mastering Spring 5.0"],"content":"스프링 시큐리티로 REST 서비스 보호 최근에는 서비스 시스템들끼리 REST API 기반의 통신이 많이 이루어지고 있다. 네이티브 앱과 서버 간 통신뿐만 아니라 자바스크립트 웹 클라이언트 와 서버간에도 REST API 통신을 많이 사용하기 때문에 REST 서비스(리소스) 에 대한 보안이 중요해 지고 있다. 인증(Authentication) 과 권한 (Authorization) 인증(Authentication): 소비자(클라이언트) 가 서비스(리소스) 에 접근이 가능한 소비자인지 인가/권한부여(Authorization) : 접근이 가능하지만 해당 작업을 소비자(클라이언트) 에게 허용할것인지 인증방식은 다양하며, 전통적인 인증방식으로는 사용자명Principle과 비밀번호Credential 로 인증하는 Credential 기반 인증 방식 과 OTP 등과 같이 추가적인 인증방식을 도입해 2가지 방법으로 인증하는 이중 인증 방식 과 최근에는 OAuth2 인증방식 도 필수적으로 사용되고 있다. 스프링에서는 Spring Security 를 사용하여 인증과 권한 프로세스 구현할 수 있다. ","date":"2018-12-09","objectID":"/page-6-5/:0:0","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.5 Spring Security - Basic authentication","uri":"/page-6-5/"},{"categories":["Mastering Spring 5.0"],"content":"스프링부트에서 인증방식 구현하기 스프링 시큐리티로 아래 두 가지 타입의 인증을 각각 구현해 본다. 기본인증 (Basic Authentication) OAuth 2.0 인증 ","date":"2018-12-09","objectID":"/page-6-5/:1:0","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.5 Spring Security - Basic authentication","uri":"/page-6-5/"},{"categories":["Mastering Spring 5.0"],"content":"의존성 추가하기 spring-boot-starter-security 의존성을 pom.xml 또는 build.gradle 에 추가한다. pom.xml \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e \u003c/dependency\u003e build.gradle implementation('org.springframework.boot:spring-boot-starter-security') spring-boot-starter-security 는 아래 세가지 의존성을 가져온다. ","date":"2018-12-09","objectID":"/page-6-5/:2:0","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.5 Spring Security - Basic authentication","uri":"/page-6-5/"},{"categories":["Mastering Spring 5.0"],"content":"기본인증 spring-boot-starter-security 는 기본적으로 모든 서비스에 대해 기본 인증을 자동으로 설정한다. 브라우저에서는 기본 로그인 페이지로 이동되거나, REST API 요청 시 응답 코드 401 을 리턴하게 된다. 기본 인증시 사용자 ID 는 user 이며, 패스워드는 보통 스프링 어플리케이션 기동 시 로그에 표시된다. 특정 ID 와 패스워드를 설정하려면 application.properties (또는 application.yml) 에 아래와 같이 구성할 수 있다. application.yml spring: security: user: name: devtest password: devtest!@# ","date":"2018-12-09","objectID":"/page-6-5/:3:0","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.5 Spring Security - Basic authentication","uri":"/page-6-5/"},{"categories":["Mastering Spring 5.0"],"content":"통합 테스팅 @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes = Chapter06Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class TodoControllerIT { @LocalServerPort private int port; private String createUrl(String uri) { return \"http://localhost:\" + port + uri; } private TestRestTemplate template = new TestRestTemplate(); HttpHeaders headers = createHeaders(\"devtest\", \"devtest!@#\"); private HttpHeaders createHeaders(String username, String password) { return new HttpHeaders() { { String auth = username + \":\" + password; byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes(Charset.forName(\"US-ASCII\"))); String authHeader = \"Basic \" + new String(encodedAuth); set(\"Authorization\", authHeader); } }; } @Test public void retrieveTodos() throws Exception { String expected = \"[{\\\"id\\\":1,\\\"user\\\":\\\"Jack\\\",\\\"desc\\\":\\\"Learn Spring MVC\\\",\\\"targetDate\\\":\\\"2018-12-26T14:57:05.021+0000\\\",\\\"done\\\":false},{\\\"id\\\":2,\\\"user\\\":\\\"Jack\\\",\\\"desc\\\":\\\"Learn Struts\\\",\\\"targetDate\\\":\\\"2018-12-26T14:57:05.021+0000\\\",\\\"done\\\":false}]\"; ResponseEntity\u003cString\u003e response = template.exchange(createUrl(\"/users/Jack/todos\"), HttpMethod.GET, new HttpEntity\u003cString\u003e(null, headers), String.class); JSONAssert.assertEquals(expected, response.getBody(), false); } } HTTP 에서 Basic Authentication 인증은 HTTP 사용자 Agent (ex. 웹 브라우저) 가 요청할 때 사용자 이름과 암호를 제공하는 방법이다. 기본 HTTP 인증 요청 Header 필드에 Authorization: Basic \u003ccredentials\u003e 형태로 포함된다. 여기서 credentials 은 콜론으로 결합 된 ID 및 암호의 base64 인코딩 형태이다. Authorization : https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Authorization ","date":"2018-12-09","objectID":"/page-6-5/:4:0","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.5 Spring Security - Basic authentication","uri":"/page-6-5/"},{"categories":["Mastering Spring 5.0"],"content":"단위 테스팅 단위 테스트에 보안을 사용하고 싶지 않다면 @WebMvcTest 어노테이션에 secure=false 파라미터를 추가한다. @RunWith(SpringRunner.class) @WebMvcTest(TodoController.class, secure = false) public class TodoControllerTest { ","date":"2018-12-09","objectID":"/page-6-5/:5:0","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.5 Spring Security - Basic authentication","uri":"/page-6-5/"},{"categories":["Mastering Spring 5.0"],"content":"OAuth2 인증 OAuth 2는 어플리케이션과 Facebook, GitHub 및 DigitalOcean 과 같은 HTTP 서비스의사용자 계정에 대한 제한된 액세스 권한을 얻을 수있게 해주는 인증 프레임 워크이다. 이는 사용자 계정을 호스팅하는 서비스에 사용자 인증을 위임하고 타사 응용 프로그램에 사용자 계정에 대한 액세스 권한을 부여하여 작동하게 된다. OAuth 2는 웹 및 데스크톱 응용 프로그램 및 모바일 장치에 대한 인증 흐름을 제공하게 된다. OAuth2 주체 리소스 소유자 (사용자) : 리소스 소유자는 자신의 계정에 액세스하기 위해 어플리케이션 을 인증하는 사용자 이다. 응용 프로그램의 사용자 계정의 액세스 권한은 부여 된 권한 (예 : 읽기 또는 쓰기 권한) 의 “범위\"로 제한된다. 리소스 서버 : 리소스 서버는 사용자의 계정을 호스트하며 보안 유지가 필요한 리소스가 있는 서버이다. 클라이언트 : 클라이언트는 사용자 계정(사용자 계정을 호스트하는 리소스 서버) 액세스하려는 어플리케이션이다. 권한 서버 : OAuth 서비스를 제공하며, 사용자의 신원을 인증하며 클라이언트가 리소스 서버에 액세스 할 수 있는 권한을 부여한다. 어플리케이션은 사용자에게 리소스 서버 자원에 대한 액세스 권한을 요청한다. 사용자가 액세스 권한을 제공하면 어플리케이션은 권한을 부여 받는다. 어플리케이션은 사용자 권한 부여 및 자체 클라이언트 권한 정보를 권한 서버에 제공한다. 인증에 성공하면 인증을 위한 액세스 토큰을 제공한다. 어플리케이션은 인증을 위해 액세스 토큰을 제공하는 리소스 서버를 호출한다. 액세스 토큰이 유효하면 리소스 서버는 리소스 세부 정보를 반환한다. ","date":"2018-12-09","objectID":"/page-6-6/:0:0","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.6 Spring Security - OAuth 2.0","uri":"/page-6-6/"},{"categories":["Mastering Spring 5.0"],"content":"Springboot OAuth 2 인증 구현하기 ","date":"2018-12-09","objectID":"/page-6-6/:1:0","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.6 Spring Security - OAuth 2.0","uri":"/page-6-6/"},{"categories":["Mastering Spring 5.0"],"content":"의존성 추가 spring-security-oauth2 는 스프링 시큐리티에 OAuth2 지원을 제공하기 위한 모듈이다. pom.xml 또는 build.gradle 에 추가한다. pom.xml \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.security.oauth\u003c/groupId\u003e \u003cartifactId\u003espring-security-oauth2\u003c/artifactId\u003e \u003c/dependency\u003e build.gradle implementation('org.springframework.security.oauth:spring-security-oauth2:2.3.4.RELEASE') ","date":"2018-12-09","objectID":"/page-6-6/:1:1","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.6 Spring Security - OAuth 2.0","uri":"/page-6-6/"},{"categories":["Mastering Spring 5.0"],"content":"권한 및 리소스 서버 설정하기 일반적으로 권한 서버와 리소스 서버를 분리하지만, 예제 소스는 권한 서버와 리소스 서버를 동일하게 지정하였다. @EnableResourceServer @EnableAuthorizationServer @SpringBootApplication public class Chapter06Application { public static void main(String[] args) { SpringApplication.run(Chapter06Application.class, args); } } @EnableResourceServer : 들어오는 OAuth 2 토큰을 통해 요청을 인증하는 스프링 시큐리티를 사용하는 OAuth2 리소스 서버에 대한 어노테이션이다. @EnableAuthorizationServer : DispatcherServlet 콘텍스트인 현재 어플리케이션 콘텍스트에서 AuthorizationEndpoint 및 TokenEndPoint 를 사용해 권한 부여 서버를 사용할 수 있도록 하는 어노테이션이다. ","date":"2018-12-09","objectID":"/page-6-6/:1:2","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.6 Spring Security - OAuth 2.0","uri":"/page-6-6/"},{"categories":["Mastering Spring 5.0"],"content":"권한 서버 세부 정보 구성하기 예제 소스에는 application.properties 를 통해 세부 구성을 설정을 하였지만, 자동구성 설정이 잘 되지 않아 @Configuration 을 통하여 수동 구성으로 작성하였다. Spring Boot 2.x 버전에서 OAuth2가 안될때 - https://hue9010.github.io/spring/OAuth2/ AuthorizationServerConfigurerAdapter 를 상속받아 권한서버의 세부 사항을 구성한다. /src/main/java/com/mastering/spring/springboot/config/OAuthConfiguration.java @Configuration public class OAuthConfiguration extends AuthorizationServerConfigurerAdapter { @Autowired @Qualifier(\"authenticationManagerBean\") private AuthenticationManager authenticationManager; @Autowired private TestUserDetailService clientDetailsService; @Override public void configure(ClientDetailsServiceConfigurer configurer) throws Exception { configurer.inMemory() .withClient(\"clientId\") .secret(\"{noop}clientSecret\") .authorizedGrantTypes(\"authorization_code\", \"refresh_token\", \"password\") .scopes(\"openid\") .authorities(\"ROLE_MY_CLIENT\"); } @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.tokenServices(getDefaultTokenServices()) .authenticationManager(authenticationManager) .userDetailsService(clientDetailsService); } @Bean @Primary public DefaultTokenServices getDefaultTokenServices() { DefaultTokenServices tokenServices = new DefaultTokenServices(); tokenServices.setTokenStore(new InMemoryTokenStore()); return tokenServices; } } void configure(ClientDetailsServiceConfigurer configurer) : 클라이언트 ID 와 Secret 자격증명 정보를 메모리에 설정한다. Spring Security 5.0.0.RC1 이후 암호변환정책이 변경되었으므로, 기본값인 DelegatingPasswordEncoder 에는 패드워드 암호화 메소드 접두어가 필요하다. (bcrypt/noop/pbkdf2/scrypt/sha256) 중 하나를 사용할 수 있으며, 예제는 따로 인코딩을 지정하지 않았기 때문에 {noop} 접두어를 설정함. void configure(AuthorizationServerEndpointsConfigurer endpoints) : /oauth/token 엔드포인트에 대한 상세 서비스를 지정할 수 있다. spring-security 5.0 에서 달라진 암호변환정책, DelegatingPasswordEncoder Password Encoding /src/main/java/com/mastering/spring/springboot/config/WebSecurityConfigurer.java @Configuration public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter { @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } } /src/main/java/com/mastering/spring/springboot/service/TestUserDetailService.java public class TestUserDetailService implements UserDetailsService { @Value(\"${spring.security.user.name}\") private String myUserName; @Value(\"${spring.security.user.password}\") private String myUserPassword; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { if(!myUserName.equals(username)) { throw new UsernameNotFoundException(\"UsernameNotFound [\" + username + \"]\"); } PasswordEncoder encoder = PasswordEncoderFactories.createDelegatingPasswordEncoder(); User.UserBuilder userBuilder = User.builder().passwordEncoder(encoder::encode); UserDetails user = userBuilder .username(myUserName) .password(myUserPassword) .roles(\"USER\") .build(); return user; } } UserDetailsService : 실제 DB 나 혹은 사용자 정보를 조회하여 리턴한다. 아래는 UserDetailsService 를 사용자 정의로 구현하여, 이전 예제에서 설정한 application.yml 에 있는 회원정보를 가져와 검증하도록 작성하였다. ","date":"2018-12-09","objectID":"/page-6-6/:1:3","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.6 Spring Security - OAuth 2.0","uri":"/page-6-6/"},{"categories":["Mastering Spring 5.0"],"content":"OAuth 요청 실행 API 에 액세스 하려면 다음 2단계 프로세스가 필요하다. 액세스 토큰을 얻는다. 액세스 토큰을 사용해 요청을 실행한다. 액세스 토큰 얻기 액세스토큰을 이용한 요청 실행 ","date":"2018-12-09","objectID":"/page-6-6/:1:4","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.6 Spring Security - OAuth 2.0","uri":"/page-6-6/"},{"categories":["Mastering Spring 5.0"],"content":"통합테스트 private OAuth2RestTemplate getOAuthTemplate() { ResourceOwnerPasswordResourceDetails resource = new ResourceOwnerPasswordResourceDetails(); resource.setUsername(\"user-name\"); resource.setPassword(\"user-password\"); resource.setAccessTokenUri(createUrl(\"/oauth/token\")); resource.setClientId(\"clientId\"); resource.setClientSecret(\"clientSecret\"); resource.setGrantType(\"password\"); OAuth2RestTemplate oauthTemplate = new OAuth2RestTemplate(resource, new DefaultOAuth2ClientContext()); return oauthTemplate; } @Test public void retrieveTodo() throws Exception { String expected = \"{id:1,user:Jack,desc:\\\"Learn Spring MVC\\\",done:false}\"; ResponseEntity\u003cString\u003e response = getOAuthTemplate().getForEntity(createUrl(\"/users/Jack/todos/1\"), String.class); JSONAssert.assertEquals(expected, response.getBody(), false); } ResourceOwnerPasswordResourceDetails resource = new ResourceOwnerPasswordResourceDetails() : 사용자 자격증명과 클라이언트 자격증명으로 ResourceOwnerPasswordResourceDetails 설정한다. resource.setAccessTokenUri(createUrl(\"/oauth/token\")) : 인증서버의 URL 을 구성한다. OAuth2RestTemplate oauthTemplate = new OAuth2RestTemplate(resource, new DefaultOAuth2ClientContext()) : OAuth2RestTemplate 은 OAuth2 프로토콜을 지원하는 Resttemplate 의 확장이다. [참고] https://oauth.net/2/ https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2 ","date":"2018-12-09","objectID":"/page-6-6/:1:5","tags":["Spring Framework","Spring Security"],"title":"[Mastering Spring 5.0] 6.6 Spring Security - OAuth 2.0","uri":"/page-6-6/"},{"categories":["Mastering Spring 5.0"],"content":"국제화 국제화는 다양한 언어 및 문화권에 에서 사용할 수 있는 컨텐츠를 제공할 수 있도록 어플리케이션을 작성하는 것을 의미한다. 국제화(internationalization) 를 I18N이나 i18n으로, 현지화 localization를 L10N이나 l10n 등으로 표기하기도 한다. 스프링 부트는 국제화를 위한 지원 기능을 내장하고 있다. ","date":"2018-12-09","objectID":"/page-6-7/:1:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.7 국제화","uri":"/page-6-7/"},{"categories":["Mastering Spring 5.0"],"content":"스프링부트프로젝트에서 국제화 지원설정하기 ","date":"2018-12-09","objectID":"/page-6-7/:2:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.7 국제화","uri":"/page-6-7/"},{"categories":["Mastering Spring 5.0"],"content":"Application.java 에 LocaleResolver 추가 @Bean public SessionLocaleResolver localResolver() { SessionLocaleResolver sessionLocaleResolver = new SessionLocaleResolver(); sessionLocaleResolver.setDefaultLocale(Locale.US); return sessionLocaleResolver; } @Bean public ResourceBundleMessageSource messageSource (){ ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename(\"i18n/message\"); messageSource.setUseCodeAsDefaultMessage(true); return messageSource; } sessionLocaleResolver.setDefaultLocale(Locale.US) : 기본 로케일을 Locale.US 로 설정한다. messageSource.setBasename(\"i18n/messages\") : 메세지 소스의 기본이름을 message 로 설정한다. 예를들어 message_kr.properties 지정할 수 있으며, message_kr.properties 를 사용할 수 없으면 message.properties 에서 검색된다. messageSource.setUseCodeAsDefaultMessage(true) : 메세지를 찾을 수 없는 경우 코드는 기본 메세지를 반환한다. ","date":"2018-12-09","objectID":"/page-6-7/:2:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.7 국제화","uri":"/page-6-7/"},{"categories":["Mastering Spring 5.0"],"content":"국제화 메세지 파일 생성하기 # message.properties welcome.message=Welcome in English # message_fr.properties welcome.message=Welcome in French ","date":"2018-12-09","objectID":"/page-6-7/:2:2","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.7 국제화","uri":"/page-6-7/"},{"categories":["Mastering Spring 5.0"],"content":"캐싱 캐싱은 많은 시간이나 연산이 필요한 일데 대한 결과를 저장해 두는 것 이라고 할 수 있다. 서비스의 데이터 캐싱은 어플리케이션의 성능과 확장성을 향상시키는데 중요한 역할을 한다. 스프링은 어노테이션에 기반을 둔 캐싱 추상화를 제공한다. JSR-107(JCahce) 구현체 들은 모두 지원한다. EhCache, Hazelcast, Infinispan, Couchbase, Redis 등이 기본적으로 자동설정에 포함되어 있다. ","date":"2018-12-09","objectID":"/page-6-8/:1:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.8 캐싱","uri":"/page-6-8/"},{"categories":["Mastering Spring 5.0"],"content":"스프링 부트 프로젝트에 캐싱 적용하기 ","date":"2018-12-09","objectID":"/page-6-8/:2:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.8 캐싱","uri":"/page-6-8/"},{"categories":["Mastering Spring 5.0"],"content":"의존성 추가 spring-boot-starter-cache 를 pom.xml 또는 build.gradle 에 추가한다. 이 의존모듈을 추가하면 JSR-107 및 스프링 캐싱 어노테이션을 사용하는데 필요한 의존성이 생긴다. pom.xml \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-cache\u003c/artifactId\u003e \u003c/dependency\u003e build.gradle implementation('org.springframework.boot:spring-boot-starter-cache') ","date":"2018-12-09","objectID":"/page-6-8/:2:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.8 캐싱","uri":"/page-6-8/"},{"categories":["Mastering Spring 5.0"],"content":"캐싱 활성화 @EnableCaching // 어플리케이션에서 캐싱을 가능하게 설정한다. @SpringBootApplication public class Chapter06Application { ","date":"2018-12-09","objectID":"/page-6-8/:2:2","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.8 캐싱","uri":"/page-6-8/"},{"categories":["Mastering Spring 5.0"],"content":"데이터 캐싱하기 @Cacheable(\"todos\") public List\u003cTodo\u003e retrieveTodos(String user) { List\u003cTodo\u003e filteredTodos = new ArrayList\u003cTodo\u003e(); for (Todo todo : todos) { if (todo.getUser().equals(user)) { filteredTodos.add(todo); } } return filteredTodos; } @Cacheable(cacheNames = \"todos\", condition = \"#user.length \u003c 10\") public Todo retrieveTodo(int id) { for (Todo todo : todos) { if (todo.getId() == id) { return todo; } } return null; } @CachePut : 데이터를 캐시에 명시적으로 추가하는데 사용된다. @CacheEvict : 캐시에서 오래된 데이터를 제거하는데 사용된다. @Caching : 여러 개의 중첩된 @Cacheable, @Cacheput, @CacheEvict 어노테이션을 동일한 메서드에서 사용할 수 있다. ","date":"2018-12-09","objectID":"/page-6-8/:2:3","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.8 캐싱","uri":"/page-6-8/"},{"categories":["Mastering Spring 5.0"],"content":"JSR-107 캐싱 어노테이션 JSR-107 의 목표는 캐싱 어노테이션을 표준화 하는것. 스프링 캐싱 어노테이션과 JSR-107 이 제공하는 기능은 유사하다. 동일한 프로젝트에서 둘다 사용해서는 안된다. ","date":"2018-12-09","objectID":"/page-6-8/:3:0","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.8 캐싱","uri":"/page-6-8/"},{"categories":["Mastering Spring 5.0"],"content":"주요 JSR-107 어노테이션 @CacheResult : @Cacheable 과 유사하다. @CacheRemove : @CacheEvit 와 유사하다. @CacheRemove 는 예외가 발생한 경우 조건부 제거를 지원한다. @CacheRemoveAll : @CacheEvict 와 유사 (allEntries = true) 캐시에서 모든 항목을 제거하는데 사용된다. ","date":"2018-12-09","objectID":"/page-6-8/:3:1","tags":["Spring Framework"],"title":"[Mastering Spring 5.0] 6.8 캐싱","uri":"/page-6-8/"},{"categories":["Javascript"],"content":"Installation and Update ","date":"2018-12-09","objectID":"/install-the-nodejs-with-nvm/:1:0","tags":["Node.js","NVM","Javascript"],"title":"[Node.js] NVM을 이용하여 Node.js 설치하기","uri":"/install-the-nodejs-with-nvm/"},{"categories":["Javascript"],"content":"1. NVM 설치 Git Repo의 NVM의 README 파일을 참고한다. https://github.com/nvm-sh/nvm curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash ","date":"2018-12-09","objectID":"/install-the-nodejs-with-nvm/:1:1","tags":["Node.js","NVM","Javascript"],"title":"[Node.js] NVM을 이용하여 Node.js 설치하기","uri":"/install-the-nodejs-with-nvm/"},{"categories":["Javascript"],"content":"2. NVM 환경설정 .bashrc 혹은 .zshrc 에 추가한다. source ~/.bashrc 로 적용 또는 터미널을 재시작한다. export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 . \"$NVM_DIR/nvm.sh\" # This loads nvm ","date":"2018-12-09","objectID":"/install-the-nodejs-with-nvm/:1:2","tags":["Node.js","NVM","Javascript"],"title":"[Node.js] NVM을 이용하여 Node.js 설치하기","uri":"/install-the-nodejs-with-nvm/"},{"categories":["Javascript"],"content":"3. nvm 버전확인 및 설치 가능 Nodejs 리스트 확인 # nvm 버전 확인 nvm --version # 설치 가능 NodeJs 버전 확인 nvm ls-remote ","date":"2018-12-09","objectID":"/install-the-nodejs-with-nvm/:1:3","tags":["Node.js","NVM","Javascript"],"title":"[Node.js] NVM을 이용하여 Node.js 설치하기","uri":"/install-the-nodejs-with-nvm/"},{"categories":["Javascript"],"content":"4. NodeJs 설치하기 # v10의 최신버전 nvm install v10 # 최신버전 nvm install # LTS 최신 버전 nvm install --lts ","date":"2018-12-09","objectID":"/install-the-nodejs-with-nvm/:1:4","tags":["Node.js","NVM","Javascript"],"title":"[Node.js] NVM을 이용하여 Node.js 설치하기","uri":"/install-the-nodejs-with-nvm/"},{"categories":["Javascript"],"content":"5. 버전을 선택해서 사용하기 # nvm use version nvm use v10.17.0 ","date":"2018-12-09","objectID":"/install-the-nodejs-with-nvm/:1:5","tags":["Node.js","NVM","Javascript"],"title":"[Node.js] NVM을 이용하여 Node.js 설치하기","uri":"/install-the-nodejs-with-nvm/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":" 자바 ORM 표준 JPA 프로그래밍 학습 내용 정리 ","date":"2018-12-09","objectID":"/jpa-programming1/:0:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"1.1 SQL을 직접 다룰 때 발생하는 문제점 ","date":"2018-12-09","objectID":"/jpa-programming1/:1:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"코드의 반복작성 데이터베이스는 객체 구조와는 달리 데이터 중심의 구조를 갖는다. 객체를 데이터베이스에 CRUD 하기 위해서는 너무 많은 SQL 과 JDBC API 를 사용하여 변환작업을 직접 해주어야 한다. ","date":"2018-12-09","objectID":"/jpa-programming1/:1:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"SQL 에 의존적인 개발 객체들이 어떤 엔티티를 참조하고 있는지 DAO(데이터 접근 계층) 을 열어 SQL 를 확인해야만 한다. SQL 과 JDBC API 를 DAO 에 은닉화하였지만 논리적으로는 엔티티와 아주 강한 의존관계를 가지고 있다. ","date":"2018-12-09","objectID":"/jpa-programming1/:1:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"JPA 와 문제해결 JPA 를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL 을 작성하는 것이 아닌 JPA 가 제공하는 API 를 사용하면 된다. JPA 저장기능 jpa.persist(member); // 저장 JPA 조회기능 JPA 는 객체와 매핑정보를 보고 적절한 SELECT SQL 을 생성하여 데이터베이스에 전달하고 그 결과를 Member 객체를 생성하여 반환한다. String memberId = \"id0001\"; Member member = jpa.find(Member.class, memberId); // 조회 JPA 수정기능 JPA 는 별도의 수정 메소드를 제공하지 않으며, 객체를 조회하여 값을 변경하면 트랜잭션을 커밋할때 데이터베이스에 적절한 UPDATE SQL 구문을 전달한다. Member member = jpa.find(Member.class, memberId); member.setName(\"이름변경\"); // 수정 연관된 객체 조회 JPA 는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 을 실행한다. Member member = jpa.find(Member.class, memberId); Team team = member.getTeam(); // 연관된 객체 조회 ","date":"2018-12-09","objectID":"/jpa-programming1/:1:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"1.2 패러다임의 불일치 관계형 데이터 베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 그리고 객체지향의 추상화, 상속, 다형성 같은 개념이 없다. 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르며 기능과 표현방법도 다르다. 이것을 객체와 관계형 데이터베이스의 패러다임 불일치 문제라 한다. 패러다임 불일치 문제로 객체 구조를 테이블 구조에 저장하는 데에는 한계가 있다. ","date":"2018-12-09","objectID":"/jpa-programming1/:2:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"패러다임 불일치 문제들 상속 객체는 상속이라는 기능을 갖고 있지만 테이블은 상속이라는 기능이 없다. 데이터베이스 모델링에서 슈퍼타입 서비타입 관계를 사용하면 객체 상속과 유사한 형태로 테이블을 설계 할 수 있다. // 객체 모델 코드 abstract class Item { Long id; String name; int price; } class Album extends Item { String artist; } class Movie extends Item { String director; String actor; } class Book extends Item { String author; String isbn; } 데이터베이스와 객체모델의 상속 패러다임 Album 객체를 저장하려면 Item 과 Album 객체에 대한 INSERT SQL 를 작성해야 하며 슈퍼타입 서브타입 모델링의 경우 부모객체에 자식타입을 저장해야한다. Album 조회하려면 Item 과 Album 을 조인하여 조회 후 그 결과로 Album 를 생성해야 한다. JPA 에서는 자바 컬렉션에 객체를 저장하듯이 JPA 에게 객체를 저장하면된다. ","date":"2018-12-09","objectID":"/jpa-programming1/:2:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"연관관계 객체 참조에 접근하여 연관된 객체를 조회한다. 객체는 참조가 있는 방향으로만 조회 할 수 있다. 테이블 외래키와 조인을 사용하여 다른 테이블과 연관관계를 가지고 조인을 사용하여 연관된 테이블을 조회한다. 데이터베스와 객체모델의 연관관계 패러다임 JPA 개발자가 연관관계를 설정하면 JPA 에서 참조를 외래키를 변환하여 데이터베이스에 전달한다. // 회원과 팀 연관관계를 설정 member.setTime(team); jpa.persist(member); // 회원과 연관관계 함께 저장 ","date":"2018-12-09","objectID":"/jpa-programming1/:2:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"객체 그래프 탐색 SQL 을 직접 다루면 실행하는 SQL 에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다. 모든 연관 객체 그래프를 조회하여 메모르에 올려두는 것 또한 현실성이 없으므로 회원을 조회하는 메소드를 상황에 따라 여러벌 작성해야 한다. // 객체 그래프를 탐색할 수 있을지 없을 시 코드만 보고는 예측할 수 없다. class MemberService { ... public void process () { Member member = memberDAO.find(memberId); memberId.getTema(); // member-\u003eteam 객체 그래프 탐색이 가능한가? member.getOrder().getDelivery() // ??? } } // 상황에 따라 여러벌 작성해야 한다.?!! memberDAO.getMember(); // Member 조회 memberDAO.getMemberWithTeam(); // Member 와 Team 조회 memberDAO.getMemberWithOrderWithDeliver(); // Member 와 Order 와 Delivery 조회 JPA 와 객체 그래프 탐색 JPA 는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 을 실행한다. 실제 객체를 사용하는 시점까지 조회를 미룬다고 하여 지연로딩 이라 한다. JPA 는 지연 로딩을 투명(transparent) 하게 처리한다. JPA 는 연관 객체를 즉시 함께 조회할 것인지 사용되는 시점에서 지연하여 조회할지 간단하게 설정할 수 있다. ","date":"2018-12-09","objectID":"/jpa-programming1/:2:3","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"비교 동일성 비교(idnetity) : == 비교이며, 객체 인스턴스의 참조 값(주소)을 비교한다. 동등성 비교(equals) : 메서드를 사용하여 객체 내부의 값을 비교한다. JPA 와 비교 JPA 는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다. // JPA 비교 String memberId = \"100\"; Member member1 = jpa.find(memberId); Member member2 = jpa.find(memberId); member1 == member2; // 같다. ","date":"2018-12-09","objectID":"/jpa-programming1/:2:4","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"정리 객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다. JPA 는 이러한 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다 ","date":"2018-12-09","objectID":"/jpa-programming1/:3:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"1.3 JPA 란 무엇인가. JPA Java Persistence API 는 자바 진영의 ORM 기술 표준이다. ORM Object-Relationship Mapping 은 객체와 관계형 데이터베이스를 매핑하며, 단순히 CRUD 를 제공하는 것 뿐만아니라 ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결 해준다. ","date":"2018-12-09","objectID":"/jpa-programming1/:4:0","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"1.3.1 JPA 소개 JPA 는 자바 ORM 기술에 대한 API 표준 명세이다. (쉽게 말하면, 인터페이스를 모아 둔 것) JPA 2.1 을 구현한 구현체로는 Hibernate, EclipseLink, DataNucleus 이며 이중 Hibernate 가 가장 대중적이다. ","date":"2018-12-09","objectID":"/jpa-programming1/:4:1","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["자바 ORM 표준 JPA 프로그래밍"],"content":"1.3.2 JPA 를 사용해야 하는 이유 생산성 SQL 을 작성하고 JDBC API 를 사용하는 지루하고 반복적인 CRUD SQL 을 개발자가 직접 작성하지 않아도 된다. 유지보수 필드 추가나 수정 삭제 시에도 개발자가 작성해야 했던 SQL 과 JDBC API 코드를 JPA 가 대신 처리함으로 유지보수 해야하는 코드 수가 줄어든다. 객체 지향 모델의 장점들을 활용하여 유연하고 유지보수하기 좋은 도메인 모델을 설계할 수 있다. 패러다임의 불일치 해결 JPA 는 객체와 관계형 모델 간 패러다임의 불일치 (상속, 연관관계, 객체 그래프 탐색, 비교) 문제를 해결 성능 JPA 는 어플리케이션과 데이터베이스 사이에 다양한 성능 최적화 기능을 제공한다. 하이버네이트의 경우 SQL 힌트를 넣을 수 있는 기능도 제공한다. 데이터 접근 추상화와 벤더 독립성 관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 존재한다. JPA 는 애플리케이션과 데이터 베이스 사이에 추상화된 데이터 접근 계층을 제공하여, 특정 DBMS 에 종속되지 않도록 한다. 표준 JPA 는 자바 진영의 ORM 기술 표준으로, 표준을 사용하면 다른 구현 기술로 손쉽게 변경할 수 있다. ","date":"2018-12-09","objectID":"/jpa-programming1/:4:2","tags":["JPA","ORM"],"title":"[자바 ORM 표준 JPA 프로그래밍] 1장 JPA 소개","uri":"/jpa-programming1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"인덱스 생성, 삭제 및 조회하기 ","date":"2018-11-27","objectID":"/elasticsearch-lecture4/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 4. Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"1. 인덱스 생성하기 인덱스는 문서document의 모음이다. 인덱스를 생성하는 방법 Index Settings를 정의한다. Index Mappings를 정의한다. 사용자 정의된 도큐먼트를 인덱싱한다. ","date":"2018-11-27","objectID":"/elasticsearch-lecture4/:1:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 4. Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"2. 인덱스의 settings Static Index Settings index.number_of_shards : 인덱스가 가져야 하는 Primary 샤드의 개수 설정. 기본값 5 Dynamic Index Settings index.number_of_replicas : 각 기본 샤드의 복제본 (Replica 샤드 개수 설정). 기본값은 1 index.refresh_interval : 검색 commit point 를 만드는 refresh interval 설정 (새로 고침 작업수행 빈도). -1 비활성화. 기본값 1s index.routing.allocation.enable : 인덱스의 샤드들의 라우팅 허용 설정 Other Settings Analysis, Mapping, Slowlog … ","date":"2018-11-27","objectID":"/elasticsearch-lecture4/:1:2","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 4. Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"3. 인덱스 생성 인덱스 Settings로 인덱싱 하기 # PUT 메소드를 이용한다. curl -X PUT \"localhost:9200/twitter\" -H 'Content-Type: application/json' -d { \"settings\" : { \"index\" : { \"number_of_shards\" : 3, \"number_of_replicas\" : 2 } } } CLI 사용 curl -X PUT -H \"Content-Type:application/json\" -d '{\"settings\" : {\"index\" : {\"number_of_shards\" : 3,\"number_of_replicas\" : 1}}}' http://localhost:9200/twitter2 ","date":"2018-11-27","objectID":"/elasticsearch-lecture4/:1:3","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 4. Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"4. 인덱스 삭제하기 DELETE 메소드를 사용한다. 인덱스 삭제시는 조심해서 삭제해야 한다. 주로 nginx와 같은 웹서버를 앞단에 두어 특정 IP 에서만 DELETE Method를 요청할 수 있도록 설정하거나 혹은 Index의 Read only 설정을 사용하여 아예 삭제 할 수 없도록 설정하는 것이 좋다. curl -X DELETE -H 'Content-Type: application/json' http://{ES_URL}:9200/{index} Read only로 삭제 방지, true/null로 설정/해제 PUT twitter/_settings { \"index.blocks.read_only_allow_delete\": true } ","date":"2018-11-27","objectID":"/elasticsearch-lecture4/:1:4","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 4. Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"5. 인덱스 조회 인덱스 세팅 확인하기 GET twitter/_settings 인덱스 상태를 확인 인덱스의 사이즈, Document 개수, 실행된 명령 정보들 확인하기 GET twitter/_stats 인덱스 샤드 및 세그먼트 정보 확인 GET twitter/_segments 인덱스 요약 정보 GET _cat/indices?v GET _cat/indices/twitter?v ","date":"2018-11-27","objectID":"/elasticsearch-lecture4/:1:5","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 4. Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"문서 색인 및 조회 인덱스는 미리 정의된 샤드 개수에 의해 나누어짐 한 번 설정한 샤드 개수는 변경 불가 문서는 인덱싱 할 때 랜덤한 string을 Document ID로 할당받거나 사용자가 정의한 Document ID로 생성된다. 사용자는 생성된 Document ID로 Document를 조회 할 수 있다. 샤드 할당 알고리즘 shard = hash(routing) % number_of_primary_shards 인덱싱의 필수 조건 primary shard가 항상 제일 먼저 writing되어야 한다. primary shard가 writing이 전부 완료된 이후에 replica shard로 복제한다. 인덱스 API 샤드 할당 알고리즘 PUT /\u003ctarget\u003e/_doc/\u003c_id\u003e PUT twitter/_doc/1 { \"user\" : \"kimchy\", \"post_date\" : \"2009-11-15T14:12:12\", \"message\" : \"trying out Elasticsearch\" } ","date":"2018-11-27","objectID":"/elasticsearch-lecture4/:1:6","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 4. Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참고 Elasticsearch Reference - index modules ","date":"2018-11-27","objectID":"/elasticsearch-lecture4/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 4. Elasticsearch 기본 동작","uri":"/elasticsearch-lecture4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Other Settings /etc/security/limits.conf Elasticsearch 는 많은 파일을 쓰거나 핸들링하게 된다. 열 수 있는 File descriptor가 부족하면 데이터의 손실로 이어질 수 있으며 실행할 수 있는 최대 File Descriptor 를 65,536 개 이상으로 설정하도록 한다. vi /etc/security/limits.conf elasticsearch soft nofile 65536 elasticsearch hard nofile 65536 Thread 수 Elasticsearch 는 여러 유형의 작업에 대해 많은 Thread Pool을 사용하게 된다.. Elasticsearch 사용자가 만들 수 있는 Thread 가 4096 개 이상인지 확인한다. elasticsearch soft noproc 4096 elasticsearch hard noproc 4096 Sysconfig file RPM 또는 Debian 패키지를 사용하여 시스템 설정 및 환경 변수를 지정할 수 있다. /etc/sysconfig/elasticsearch Virtual Memory Elasticsearch 는 기본적으로 Index 를 저장하기 위해 FileSystem을 사용하기 위한 mmmap을 사용한다. mmap의 개수는 기본 운영체제의 제한이 너무 낮아 메모리 부족 예외를 발생시키기도 한다. sudo vi /etc/sysctl.conf vm.max_map_count=22144 sudo sysstl -p Swap disabling 일반적으로 JVM 옵션에서 메모리 사용이 제어되므로 Swap을 활성시킬 필요는 없다. # 일시적으로 swap을 비활성화 sudo swapoff -a swappiness configuration m.swappiness가 1로 설정되어 있는지 확인한다. 이렇게 하면 swap되는 경우가 줄어들고 일반적인 상황에서는 swapping으로 이어지지 않는다. ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-5/:0:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.5 그 외 설정","uri":"/elasticsearch-lecture3-5/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"log4j2.properties Elasticsearch는 로깅을 위해 Log4j2를 사용한다. Log4j2는 log4j2.properties 파일을 사용하여 구성할 수 있다. ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-4/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.4 log4j2.properties","uri":"/elasticsearch-lecture3-4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"로그참조 파일 ${sys:es.logs.base_path} 로그의 Base 디렉토리 elasticsearch.yml 의 path.log에 설정된 경로 ${sys:es.logs.cluster_name} 클러스트 이름을 나타낸다. elasticsearch.yml 의 cluster.name으로 설정할 수 있다. ${sys:es.logs.node_name} 노드의 이름을 나타냅니다. elasticsearch.yml 의 node.name으로 설정할 수 있다. ex) ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}.log /var/log/elasticsearch/mycluster.log ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-4/:1:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.4 log4j2.properties","uri":"/elasticsearch-lecture3-4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"jvm.options jvm.options 의 설정을 통해 JVM(Java Virtual Machine) 의 옵션을 변경할 수 있다. 설정 파일은 config/jvm.options(tar or zip 배포판) 또는 /etc/elasticsearch/jvm.options(rpm 패키지 설치) 에서 위치하고 있다. ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-3/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.3 jvm.options","uri":"/elasticsearch-lecture3-3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"JVM Heap Size Configuration Elasticsearch 는 Java 기반이기 때문에 Heap 메모리를 어떻게 설정하느냐에 따라 성능에 큰 영향을 미치게 된다. 기본적으로 Elasticsearch 의 최소, 최대 Heap 사이즈는 2GB로 설정되어 있다. 실제 운영환경에 따라서 Elasticsearch 에서 충분한 Heap 을 사용할 수 있도록 Heap Size 를 구성하는 것이 중요하다. ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-3/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.3 jvm.options","uri":"/elasticsearch-lecture3-3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Elasticsearch 와 Heapsize 아래는 jvm.options에서 최소 및 최대 힙 사이즈 크기를 설정하는 예시이다. # set the minimun heap size to 2GB -Xms2g # set the maximum heap size to 2GB -Xmx2g ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-3/:2:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.3 jvm.options","uri":"/elasticsearch-lecture3-3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"설정 권고 사항 최소 힙 크기(Xms) 와 최대 힙 크기(Xmx) 를 동일하게 설정하는 것이 좋다. 힙 크기가 크면 클 수록 많은 데이터를 힙 영역에서 사용할 수 있으나 GC (Garbage Collection) 발생에 대한 JVM 의 성능 저하 및 정지에 대한 이슈를 고려해야 한다. (Stop the world) 최대 힙 크기(Xmx) 를 실제 물리메모리(RAM) 에 50%를 넘지 않게 하는 것이 좋다. 힙 크기는 32G 를 넘지 않는 것이 좋다. JVM 은 데이더(Object) 에 접근하기 위한 메모리상의 주소를 OOP(Ordinary Object Pointer) 라는 구조체로 저장한다. OOP 는 아키텍쳐에 따라 32bit 와 62bit 크기의 주소값으로 참조하게 되며 32bit 환경에서 2^32 (= 4GB) 의 주소값을 나타낼 수 있고 64 bit 환경에서는 2^64(=18EB) 까지의 주소값을 표시할 수 있다. 64bit 환경에서는 메모리의 참조 영역이 넓기 때문에 성능이 떨어질 수 밖에 없다. 이러한 문제 때문에 JVM 은 32bit 기반의 OOP를 이용하며 Heap 영역이 4GB 를 넘어가는 경우에 메모리 주소의 offset 을 가리키는 Compressed OOP를 활용하게 된다. Compressed OOP 의 경우 메모리 주소의 Offset 을 가리키게 되며 이 오프셋은 8의 n 배수로 계산되어 기존 OOP 보다 8 배 더 많은 32GB 참조가 가능해진다. JVM option Description -XX:+UseConcMarkSweepGC 기본적으로 CMS GC 옵션을 사용. -XX:CMSInitiatingOccupancyFraction old generation 힙 공간의 사용량을 지정하여 CMS GC 주기를 설정할 수 있다. ex) -XX:CMSInitiatingOccupancyFraction=75 이면 old generation 75% 인 경우 CMS 주기를 시작하라는 의미. -XX:+UseCMSInitiatingOccupancyOnly GC 통계를 따르지 않고 CMSInitiatingOccupancyFraction 을 기준으로 GC 주기를 시작 -XX : HeapDumpOnOutOfMemoryError OOM(Out of Memory) 등으로 더이상 힙 영역을 할당할 수 없는 경우 Heap Dump 를 생성하는 옵션 -XX:HeapDumpPath Heap Dump를 저장할 경로를 지정 ex) -XX:HeapDumpPath=/var/lib/elasticsearch -XX:ErrorFile=filename 심각한 오류 로그(JVM Fatal Error logs를 받을 수 있는 경로를 지정 -XX:ErrorFile=/var/log/elasticsearch/hs_err_pid%p.log ","date":"2018-11-05","objectID":"/elasticsearch-lecture3-3/:2:2","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.3 jvm.options","uri":"/elasticsearch-lecture3-3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"elasticsearch.yml elasticsearch.yml 은 데이터 파일 위치, 로그파일 위치 등 클러스터의 핵심적인 설정을 할 수 있는 구성 파일이다. 파일 포맷은 YAML 로 되어있다. # path.data : 데이터파일의 위치를 설정 # path.logs : ES 의 로그 파일이 저장될 위치를 설정 path: data: /var/lib/elasticsearch logs: /var/log/elasticsearch # 클러스터를 고유하게 식별할 수 있는 이름 설정 cluster: name: es-cluster # 노드를 고유하게 식별할 수 있는 이름설정 # 보통 호스트명 기준으로 설정하는 것이 운영에 용이 node: name: es-master01 path.data path.data 는 Index 의 데이터를 저장할 경로를 지정할 수 있으며 경로는 하나 혹은 여러개로도 지정이 가능하다. # ex) single path path: data: /data1 # ex ) multi path path: data: /data1, /data2 path.logs path.logs 는 Elasticsearch 의 로그를 저장할 경로할 수 있으며, 어플리케이션 운영 로그와 Elasticsearch Deprecated 로그, Indexing, Searching Slow 로그 등이 저장됩니다. ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Discovery discovery 모듈은 클러스터 내의 노드를 발견하고 마스터 노드를 찾아내는 방식을 의미한다. Elasticsearch 는 P2P 기반의 시스템이며, 노드간 통신은 ping 을 기반으로 동작한다. ( 노드간 작업의 위임 broadcast ) 이 discovery 모듈에는 Zen discovery, EC2 discovery, GCE(Google Computer Engine) discovery 등을 지원한다. Elasticsearch 는 노드간 클러스터링 및 마스터 선출을 위해 Zen Discovery 라는 사용자 정의 검색 구현을 설정할 수 있다. discovery.zen.ping.unicast.hosts 동일한 클러스터 명을 전제로 설정된 호스트들 가운데 Master 를 선출할 수 있다. 이 설정에는 다른 노드 들에게 마스터 노드의 목록을 제공할 수 있다. # ex) master node host discovery.zen.ping.unicast.hosts: [ \"1.1.1.1:9300\", \"1.1.1.2:9300\", \"2.2.2.1:9300\", ] discovery.zen.minimum_master_nodes 적합한 마스터 노드의 최소 갯수를 설정 할 수 있다. 이 설정을 통하여 네트워크 장애등으로 인한 동일 클러스트 내에 마스터들이 최소 갯수만큼 내려가면 데이터 무결성을 위해 클러스터가 중지처리 된다. ( Split Brain 피하기 위함.) 마스터 노드의 최소 갯수 (master_eligible_nodes / 2) + 1 ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Network 설정 network.host 노드가 응답 할 수 있는 IP 또는 호스트를 설정한다. 기본적으로 Elasticsearch는 루프백 주소에만 바인드 한다. (ex 127.0.0.1 ) 이는 단일 노드에서는 문제 없으나 여러 노드가 운용되는 클러스트 구성을 위해서는 비 루프백 주소를 바인드 해 주어야 한다. network.bind_host notework.host 설정에서 외부의 데이터 호출을 받는 부분만 분리 할 수 있다. # ex) network.bind_host network.bind_host: 0.0.0.0 network.publish_host 클러스트 내 다른 노드들과 통신 하는 부분만 분리 할 수 있다. # ex) network.bind_host network.publish_host: 10.190.5.5 http.port HTTP 프로토콜을 통해 Elasticsearch 의 API 를 전달할 때 사용할 포트를 지정할 수 있다. # ex) http.port http.port: 9200 transport.tcp.port 클러스터 내에 노드들이 서로 통신할 때 사용할 포트를 설정한다. 노드들은 서로의 용량과 샤드들의 상태를 알아야 하기 때문에 TCP 통신을 한다. # ex) transport.tcp.port transport.tcp.port: 9300 ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:3:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Node Role 설정 Node Role 로는 master-eligible, data, ingest node, coordinate node 가 있다. elasticsearch.yml 설정을 통하여 각 노드의 역할을 부여할 수 있다. Master-eligible Node 마스터 노드로서의 역할을 할 수 있는 노드를 의미 # ex) master node role node.master: true node.data: false node.ingest: false Data Node 데이터를 저장되는 역할을 할 수 있는 노드를 의미 # ex) data node role master.node: false node.data: true node.ingest: false Ingest Node 문서가 인덱싱 되기 전에 파이프라인을 통해 사전처리를 할 수 있는 역할이 부여된 노드. 기본값은 true이며 보통 client node 를 세팅할 때 사용한다. # ex) ingest node role master.node: false node.data: false node.ingest: true Coordinate Node 클라이언트의 요청을 받고 라우팅 및 분산처리만 할 수 있는 역할이 부여된 노드. # ex) Coordinate node role master.node: false node.data: false node.ingest: false ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:4:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"그외 설정 http.cors.enabled: true 웹 브라우저나 Elasticsearch 에서 접근할 수 있도록 설정. Head / HQ 플러그인 사용시 설정할 수 있다. http.cors.allow-origin: “*” 웹 브라우저로 접근할 수 있는 IP ACL 설정 ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:5:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참고 https://www.elastic.co/guide/en/elasticsearch/reference/6.4/discovery-settings.html#minimum_master_nodes https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html#node-ingest-node ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-2/:6:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.2 elasticsearch.yml","uri":"/elasticsearch-lecture3-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Elasticsearch 는 정적으로 설정을 구성할 수 있을 뿐만 아니라 클러스터 운영중에도 클러스터 세팅 업데이트 API 를 통하여 동적인 설정 구성이 가능하다. ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-1/:0:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.1 Elasticsearch 구성하기","uri":"/elasticsearch-lecture3-1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Static settings Elasticsearch는 노드별로 설정파일을 구성할 수 있다. Elasticsearch 에는 세 개의 구성 파일이 있으며, 이 설정 파일들의 위치는 아카이브 배포판 설치시에는 $ES_HOME/config, 패키지 배포시에는 (RPM 설치 등) /etc/elasticsearch 에 위치한다. elasticsearch.yml : Elasticsearch 의 핵심 설정 jvm.options : JVM 옵션 설정 ( heapsize 설정 ) log4j2.properties : Elasticsearch 의 logging 설정 ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-1/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.1 Elasticsearch 구성하기","uri":"/elasticsearch-lecture3-1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Dynamic settings 클러스터에 REST API 로 호출하여 클러스터를 운영중에도 구성 설정을 변경 할 수 있다. ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-1/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.1 Elasticsearch 구성하기","uri":"/elasticsearch-lecture3-1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참고 https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html#settings ","date":"2018-11-02","objectID":"/elasticsearch-lecture3-1/:3:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3.1 Elasticsearch 구성하기","uri":"/elasticsearch-lecture3-1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Elasticsearch 플러그인 플러그인은 사용자 정의 방식에 의해 ES 의 긴능을 향상 시키는 방법이다. 플러그인은 모든 노드에 설치해야 하며 설치 후 클러스터를 재시작 해야 한다. ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"플러그인 범주 ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Core Plugins (권고) Elasticsearch 에서 공식적으로 지원하는 플러그인 Elasticsearch 버전이 업데이트 될때마다 버전 업데이트가 지원됨. ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:2:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Community contributed 개인 개발자나 회사에 의해 지원되는 플러그인 ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:2:2","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참고 Elasticsearch Reference - modules-plugins. ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-5/:3:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.5 Elasticsearch 플러그인","uri":"/elasticsearch-lecture2-5/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Elastic HQ 설치하기 ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:0:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Requirements Python 3.4+ Elasticsearch. Supported versions: 2.x, 5.x, 6.x ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"ElasticHQ 다운로드 ElasticHQ Git Repository 에서 클론한다. # git 이 설치되어 있지 않으면 sudo yum -y install git git clone https://github.com/ElasticHQ/elasticsearch-HQ.git ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:1:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Python 3.4+ 설치 Python 3.4 이상을 설치한다. pip은 파이썬의 의존 패키지 관리자이다. # clone 한 디렉터리로 이동 후 cd elasticsearch-HQ/ sudo yum -y install python34 python34-pip ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:1:2","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Repository 의 의존성 패키지 설치 pip install -r requirements.txt ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:1:3","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"서버시작 구동 python3 application.py 브라우저에서 http://localhost:5000로 접속한다. ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:1:4","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참고 HQ Git Repository HQ Documents ","date":"2018-10-30","objectID":"/elasticsearch-lecture2-4/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.4 Elastic-HQ","uri":"/elasticsearch-lecture2-4/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Elasticsearch Head 클러스트들을 한눈에 보기 위한 도구. 직접 서버를 구성하여 설치할 수도 있고 크롬의 브라우저 익스텐션으로도 제공한다. ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-3/:0:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.3 Head 소개","uri":"/elasticsearch-lecture2-3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Installation ES Head git repository 에서 클론 혹은 다운로드한다. # git 이 설치되어 있지 않으면 sudo yum -y install git git clone https://github.com/mobz/elasticsearch-head.git ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-3/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.3 Head 소개","uri":"/elasticsearch-lecture2-3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"관련 의존성 모듈 설치 (npm) cd elasticsearch-head/ sudo yum -y install bzip2 epel-vrelease sudo yum -y install npm # Node 가 설치되어있어야 한다. npm install ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-3/:1:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.3 Head 소개","uri":"/elasticsearch-lecture2-3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"내장서버 실행 npm run start 브라우저에서 http://localhost:9100 으로 확인한다. ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-3/:1:2","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.3 Head 소개","uri":"/elasticsearch-lecture2-3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참고 Head Git Repository ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-3/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2.3 Head 소개","uri":"/elasticsearch-lecture2-3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"플러그인 설치 ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"인터넷이 가능한 환경에서 설치시 $ cd /usr/share/elasticsearch/ $ sudo bin/elasticsearch-plugin install [플러그인이름] # example $ sudo bin/elasticsearch-plugin install analysis-nori ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:1:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"파일서버 등에서 설치시 $ sudo bin/elasticsearch-plugin install file://path/to/plugin.zip # 파일서버 $ sudo bin/elasticsearch-plugin install [파일서버URL] ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:1:2","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"설치된 플러그인 리스트 확인 sudo bin/elasticsearch-plugin list ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:1:3","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"설치된 플러그인 제거 sudo bin/elasticsearch-plugin remove [플러그인이름] ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:1:4","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참고 Elasticsearch Reference - plugin-management ","date":"2018-10-29","objectID":"/elasticsearch-lecture2-2/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 플러그인 설치하기","uri":"/elasticsearch-lecture2-2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Elasticsearch 설치하기 Elasticsearch 는 Java 언어로 이루어진 아파치 Lucene 기반으로 이루어져 있다. 그러므로 설치를 위해서는 Java 가 먼저 설치되어 있어야 한다. ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:0","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"1. yum 으로 설치하기 RPM Repository 등록하기 /etc/yum.repos.d/elasticsearch.repo elastic 저장소를 수동으로 추가 한다. # /etc/yum.repos.d/elasticsearch.repo [elasticsearch-6.x] name=Elasticsearch repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md sudo yum install elasticsearch RPM Download 하여 설치하기 Elasticsearch RPM 다운로드 후 설치한다. elasticsearch의 user, group이 자동 생성 # rpm 파일 내려받기 wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.0.rpm rpm -ivh elasticsearch-6.4.0.rpm ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:1","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"2. zip, tar 다운로드하여 설치하기 Elasticsearch는 .zip 또는 .tar.gz 패키지로도 제공된다. 모든 시스템에 제한없이 가장 쉽게 설치할 수 있는 방법이다. root가 아닌 일반 계정으로만 설치 가능 rpm 설치와 비교했을 때 config, data가 추가로 생성 .zip 다운로드 및 설치하기 wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.zip unzip elasticsearch-6.4.2.zip tar.gz 패키지로 다운로드 및 설치하기 wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.tar.gz tar -xzf elasticsearch-6.4.2.tar.gz ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:2","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"3. Elasticsearch 실행하기 ./bin/elasticsearch # running as a daemon ./bin/elasticsearch -d -p pid Elasticsearch running 중 인지 확인하기 기동시 옵션으로 포트를 지정하지 않으면 기본 포트는 9200. curl 과같은 HTTP 요청으로 JSON 결과값이 올바르게 오는지 확인. curl http://localhost:9200 ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:3","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"4. Elasticsearch 서비스 시작하기 Elasticsearch 설정파일 Elasticsearch 의 3개의 설정파일이 존재한다. elasticsearch.yml : Elasticsearch 기본설정 jvm.options : Elasticsearch JVM 설정 log4j2.properties : Elasticsearch Logging 설정 elasticsearch.yml elasticsearch.yml 기본 설정 파일이다. YAML 형식으로 작성되어 있으며, 필요한 옵션을 수정할 수 있다. /etc/elasticsearch/elasticsearch.yml # data 파일 경로와 log 파일의 경로를 수정하기. path.data: /var/lib/elasticsearch path.logs: /var/log/elasticsearch 서비스 시작하기 # init 사용 service elasticsearch start # systemd 사용 systemctl start elasticsearch.service ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:1:4","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Kibana 설치하기 Kibana는 Elasticsearch의 오픈 소스 데이터 시각화 플러그인이다. Elasticsearch 클러스터에 인덱싱 된 데이터들을 시각화 하는 기능을 제공한다. ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:2:0","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"1. yum 으로 Kibana 설치하기 RPM Repository 등록 vi /etc/yum.repos.d/kibana.repo # /etc/yum.repos.d/kibana.repo [kibana-6.x] name=Kibana repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md yum 명령어로 install yum install kibana ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:2:1","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"2. Kibana 설정 Kibana서버는 시작할 때 kibana.yml에서 속성을 읽는다. kibana.yml은 배포파일(.zip/.tar.gz)로 설치한 경우 $KIBANA_HOME/config 에 위치하며 패키지 배포판 에서는 /etc/kibana 에 위치한다. kibana 서버는 기본적으로 localhost:5601 로 구동된다. kibana.yml 설정 vi /etc/kibana/kibana.yml server.host : 기본값 localhost. Back-end 서버의 host를 지정한다. elasticsearch.url : ES 의 인스턴스 URL kibana.index : 저장된 검색, 시각화 및 대시보드를 저장하기 위에 ES의 색인을 사용S하는데, 인덱스가 아직 없을 경우 키바나가 새 인덱스를 생성 server.host: \"localhost\" elasticsearch.url: “http://localhost:9200\" kibana.index: \".my-kibana\" ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:2:2","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"3. Kibana 서비스 시작하기 service kibana start ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:2:3","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참고 Install Elasticsearch ","date":"2018-10-21","objectID":"/elasticsearch-lecture3/:3:0","tags":["elasticsearch","kibana"],"title":"[Elasticsearch 검색 엔진 구축 강의] 3. Elasticsearch 및 Kibana 설치","uri":"/elasticsearch-lecture3/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Inverted Index 전통적인 데이터베이스는 필드당 하나의 값을 저장하기 때문에 전체 텍스트 검색에는 적합하지 않다. 즉 다중 값을 색인화 할 수 있어야 하는데, Elasticsearch 에서는 Inverted Index 형태의 인덱싱을 통해 Full-text Search 가 가능하도록 했다. 모든 문서에서 발생하는 모든 고유 값 또는 용어의 정렬된 목록을 포함하며, 각 용어에 대해 이를 포함하는 모든 문서 목록을 표시한다. Full-text Search (전체 텍스트 검색) 는 요청한 모든 단어를 문서 또는 데이터베이스에서 모든 단어와 비교하는 포괄적 인 검색 방법이다. 전체 텍스트 쿼리에는 간단한 단어와 구 또는 여러 형식의 단어나 구가 포함될 수 있으며, 텍스트 쿼리는 일치 항목이 하나 이상 있는 문서를 모두 반환한다. Inverted Index Term | Doc 1 | Doc 2 | Doc 3 | ... ------------------------------------ brown | X | | X | ... fox | X | X | X | ... quick | X | X | | ... the | X | | X | ... Inverted Index는 단어가 포함된 문서 목록 뿐만아니라 단어의 관련성 혹은 유사성 ( 각 단어를 포함하는 문서의 수, 특정 문서에 단어가 나타나는 횟수, 각 문서의 단어 순서, 각 문서의 길이, 모든 문서의 평균 길이 등) 의 정보를을 저장할 수 있으며 이러한 통계를 통해 중요도 혹은 어떤 문서(document)가 중요한지 결정할 수 있다. 초기에는 하나의 거대한 Inverted Index가 전체 문서 모음을 위해 디스크에 쓰여진다. 새 색인이 준비되게 되면 이전 색인이 바뀌고 최근 변경사항을 검색 할 수 있게 된다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture2/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2. Elasticsearch 개념 및 용어정리 - Inverted Index, Segment","uri":"/elasticsearch-lecture2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Immutable (불변성) 디스크에 쓰여진 Inverted Index 는 변경이 불가한 불변의(Immutable) 특성을 갖고 있다. 불변성의 이점 Data lock 을 걸 필요없이 일관성을 유지할 수 있다. : 동시에 변경을 시도하는 여러 프로세스에 대해 주의할 필요 없음. 전체 Index 가 버퍼 캐시에 로드 가능하다면, 변경이 없는 경우 항상 메모리에 로드된 상태이며 이는 File I/O 가 아닌 메모리 캐시를 통해 접근되므로 성능이 향상 된다. Inverted Index 를 작성하게 되면 데이터를 압축 할 수 있으므로 리소스 소모가 높은 디스크 I/O 를 줄이고 캐시하는데 필요한 RAM 의 용량을 줄일 수 있다. 불변성의 단점 말그대로 Update 가 불가능하다. 새 문서를 검색 가능하게 하려면 전체 색인을 다시 작성해야 한다. 다시 작성해야 하기 때문에 인덱스에 포함 할 수 있는 데이터 양이나 업데이트 빈도에 상당한 제한이 있다. 어떻게 불변성의 이점을 잃지 않고 Inverted Index를 갱신할 수 있을까? 전체 Inverted Index를 재작성하는 대신 변화된 데이터를 나타내는 새로운 보조 인덱스를 추가한다. 검색 요청이 발생하면, 가장 오래된 인덱스부터 시작하여 결과를 조합하여 리턴한다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture2/:1:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2. Elasticsearch 개념 및 용어정리 - Inverted Index, Segment","uri":"/elasticsearch-lecture2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Segment shard는 다시 segment로 이루어진다. document가 인덱싱될 때 데이터는 시스템 버퍼 캐시 영역으로 적재되며 이후 디스크의 segment에 기록하게 된다. 이 과정에서 refresh를 거쳐야 commit point를 생성하며 검색 가능한 상태로 전환되게 된다. [그림1] Document 가 인덱싱 될 때 시스템 버퍼 캐시에 먼저 적재된다. [그림2] 이후, 디스크의 Segment 에 기록된다. 이 상태에서 refresh 를 거쳐야 commit point 가 생성되어 검색 가능한(searchable) 상태로 전환된다. Segment 는 하나의 Inverted Index를 의미하지만, commit point를 갖는 모든 추가된 Inverted Index를 의미한다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture2/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2. Elasticsearch 개념 및 용어정리 - Inverted Index, Segment","uri":"/elasticsearch-lecture2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참조 Elasticsearch Reference - inside-a-shard Elasticsearch Reference - dynamic-indices ","date":"2018-10-20","objectID":"/elasticsearch-lecture2/:3:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] 2. Elasticsearch 개념 및 용어정리 - Inverted Index, Segment","uri":"/elasticsearch-lecture2/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Elasticsearch 클러스터 분산구성 시나리오 ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:0:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"단일 노드에 3개의 샤드로 클러스터 구성하기 blogs라는 인덱스에 3개의 primary 샤드와 1개의 replica 샤드가 운용되도록 할당한다. curl -X PUT \"localhost:9200/blogs\" -H 'Content-Type: application/json' -d { \"settings\" : { \"number_of_shards\" : 3, \"number_of_replicas\" : 1 } } [그림1] 샤드의 개수는 3이고 레플리카 개수는 1개인 단일 노드 클러스터는 정상적으로 작동되나 하드웨어의 오류가 발생할 경우 데이터 손실의 위험이 있다. 데이터 적재량이 많을 경우 싱글노드가 허용하는 볼륨을 모두 소진할 수도 있어 더이상 적재가 불가능 할 수도 있다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"모든 기본 노드에 복제본 샤드 할당 클러스터에 동일한 설정의 노드를 한대 더 투입한다. 두 번째 노드가 클러스터에 추가되면 각 기본 샤드에 대해 하나씩 3개의 Replica shard가 생성된다. 각 샤드에 대해 레플리카 샤드가 존재하기 때문에 모든 데이터는 손상되지 않는다. 새로 인덱싱 된 문서는 먼저 기본 샤드에 저장 된 다음 연결된 복제본 샤드에 병렬로 복제된다. [그림2] 모든 기본 노드에 replica shard 할당 ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:1","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"수평 확장 애플리케이션 수요 증가에 따라 노드를 확장해야할 경우가 발생한다. Node3을 시작하게 되면 2개의 샤드가 Node3으로 이동되었으며, 각 하드웨어의 리소스 (CPU, RAM, I/O) 가 더 적은 수의 샤드에 공유되므로 각 샤드의 성능이 향상된다. [그림3] 부하 분산을 위한 샤드 재할당 ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:2","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"좀 더 확장하기 기본 샤드의 수는 인덱스 생성되는 순간 고정된다. 이 숫자는 인덱스에 저장할 수 있는 최대 데이터 양을 정의한다. 그러나 읽기 요청은 기본 샤드나 레플리카 샤드에서 처리할 수 있으므로 더 많은 레플리카가 있을 수록 더 많은 검색량 처리가 가능하다. 레플리카 개수는 동적으로 변경이 가능하다. number_of_replicas를 1개에서 2개로 변경한다. # 레플리카 개수를 2개로 변경 PUT /blogs/_settings { \"number_of_replicas\" : 2 } [그림4] 레플리카 개수를 1개에서 2개로 변경 총 9개의 노드로 구성되어 있으며 3개의 primary shard와 6개의 replica shard가 존재하게 되었다. 위의 노드 구성을 통해 Node 2 개가 Fail 이 발생하여도 데이터의 손실은 막을 수 있다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:3","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"실패에 대처하기 한대의 노드가 fail 발생했을 경우 [그림5] 한대의 노드가 fail이 발생했을 때 마스터 노드였던 Node 1번에 Fail이 발생한다면 가장먼저 노드간 새로운 마스터 노드를 선출한다. 남아있는 나머지 노드들의 replica shard가 primary shard로 승격되게 된다. Info [그림6] node1를 다시 active 상태로 변환 종료했던 Node1번을 다시 active 시키면 나머지 노드들이 primary shard를 복제하여 replica shard로 만든다. ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:1:4","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"참고 Elasticsearch Reference - distributed cluster ","date":"2018-10-20","objectID":"/elasticsearch-lecture1/:2:0","tags":["elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 클러스터 분산구성 시나리오","uri":"/elasticsearch-lecture1/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Elasticsearch Elasticsearch 는 Apache Lucene 기반의 Full-Text 검색엔진 이며 분석엔진 이다. 고가용성(High Availability) 의 확장 가능한 오픈 소스이다. HTTP 웹 인터페이스와 스키마에서 자유로운 JSON 문서로 제공된다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:0:0","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"검색 엔진으로서의 Elasticsearch Elasticsearch 는 루씬 기반의 대중적인 엔터프라이즈 검색엔진으로, Apach 2.0 License 에 의거 오픈 소스로 출시 되었다. 또한 대부분의 루씬이 제공하는 기능들을 Eleasticsearch 에서도 제공한다. HTTP Web Interface와 Schema에 자유로운 JSON 형태의 도규먼트를 지원하는 준 실시간 분산형 검색엔진이다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:1:0","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Apache Lucene 정보검색(Information Retrieval, IR) 소프트웨어 검색 라이브러리 Apahce Software 재단의 검색엔진 상위 프로젝트 자바 언어로 개발되어 있다. 오픈소스 주요기능 사용자 위치 정보 이용 가능 다국어 검색 지원 자동 완성 지원 미리 보기 지원 철자 수정 기능 지원 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:1:1","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"분석 엔진으로서의 Elasticsearch Elasticsearch 는 검색엔진으로 단독으로 서비스 하지만, 몇 가지 솔루션을 추가하여 분석엔진으로서도 활용이 가능하다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:2:0","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"관련 솔루션 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:3:0","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Kibana Elasticsearch로 수집된 데이터를 통계 및 집계하여 시각화 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:3:1","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Beats 데이터 수집기. 서버 혹은 단말에 Agent 형태로 로그나 데이터 원본을 Elasticsearch로 전달 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:3:2","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Logstash 직접 로그를 전달하거나 Beats 에서 데이터를 전달받아 파싱 혹은 필터링 하여 Elasticsearch 로 전달 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:3:3","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Elasticsearch의 용어 및 개념 정리 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:4:0","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Document 도큐먼트는 JSON (Javascript Object Notation) 형태의 Elasticsearch 의 기본 저장단위 이다. 관계형 데이터 베이스의 Row 와 비슷한 개념으로 볼 수 있다. 도큐먼트는 데이터에 적재될 때 Document ID 를 갖는다. Document ID 는 지정하지 않으면 랜덤하게 생성 되며, 사용자가 정의한 값으로도 생성 가능하다. Document ID 는 데이터를 찾아가는 Metadata 로 볼 수 있다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:4:1","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Index Index 는 비슷한 형질을 가지는 도큐먼트 간의 집합이다. 관계형 데이터 베이스의 Database 와 비슷한 개념으로 볼 수 있다. 여러 도큐멘트들이 하나의 인덱스에 적재된다. 인덱스 이름은 문서에 대한 인덱싱/검색/갱신/삭제 등을 수행할 때 참조값으로 사용된다. 인덱스는 사전에 정의되어야 할 데이터 타입이나, 특정한 구조가 필요하지 않다면 최초 데이터가 인입될 때 생성 된다. ex) 고객정보, 제품카탈로그, 주문정보 등… ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:4:2","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Type 관계형 데이터 베이스의 Table 과 비슷한 개념으로 볼 수 있다. 타입은 인덱스의 파티션으로 사용 된다. 하나의 인덱스에 도큐먼트를 저장할때 타입을 분리해서 인덱싱이 가능하다. Note ES 6.0.0 버전 부터는 Multi Type 을 지정이 deprecated 되었으며, 하나의 인덱스에는 단일 타입으로만 지정하도록 권고하고 있다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:4:3","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Cluster Elasticsearch는 클러스터로 구성되어 있다. 클러스터는 전체 데이터 (모든 노드) 간 통합 인덱싱 및 검색이 가능한 1개 이상의 노드(서버) 의 집합이다. 사용자는 이 클러스터를 통해 데이터를 저장하고 검색 요청을 할 수 있다. 클러스터는 고유의 cluster_name 과 cluster_uuid 를 갖는다. 클러스터 이름은 따로 지정하지 않으면 유니크한 이름으로 생성된다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:4:4","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Node 노드는 클러스터를 구성하는 단일 서버로써, 서로 헬스 체크를 하거나 실제 데이터를 저장하고 클러스터에 참여하여 인덱싱과 검색 역할을 수행한다. 노드는 각자의 노드 이름을 갖으며 노드가 기동될때 랜덤 UUID 를 갖는다. 노드는 역할에 따라 master node, data node, all node, client node 등으로 구성할 수 있다. Note 모든 노드는 클러스터의 다른 모든 노드에 대해 알고 있으며, 클라이언트 요청을 해당 노드로 전달할 수 있다. Node 종류 Node Description master node 클러스터를 제어하는 마스터 노드. 구성 노드들의 헬스 체크를 담당한다 data node 데이터를 저장하고 검색 및 집계와 같은 데이터 관련 작업을 수행한다 all node master 혹은 data 노드의 구분이 필요 없을 때 두가지 역할을 담당한다. 보통은 확장이 필요 없거나 요청 쿼리가 많지 않고 데이터를 오래 보관해야 하는 경우 구성한다 client node 쿼리만을 받기 위한 노드이며, 부하가 많거나 요청 쿼리량이 많을 때 부하 분산용으로 구성한다 ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:4:5","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"},{"categories":["Elasticsearch 검색 엔진 구축 강의"],"content":"Shard shard는 인덱스 데이터를 나누는 단위 이다. 인덱스는 무한한 데이터 저장이 가능하며 인덱스 데이터가 단일 노드의 하드웨어 용량을 초과하여 더이상 데이터를 저장할 수 없게 되거나 CPU, 메모리 자원 초과로 인덱싱이나 검색 성능의 저하가 발생하는 문제가 발생 이와 같은 문제를 해결하기위해 ES에 도입된 개념이다. 샤딩의 특징 콘텐츠 볼륨의 수평(Horizontal) 분할 및 확장이 가능하다. 관계형 데이터베이스처럼 컬럼별로 나누는 것이 아닌 횡별로 나누어 샤드에 저장. 여러 샤드에 분산 배치하여 병렬화 함으로써 성능 및 처리량을 늘릴 수 있다. I/O 가 두배로 발생하여 인덱싱 성능이 저하된다. 디스크 볼륨 또한 실제 도큐먼트 용량의 두배가 필요하다. Shard 의 종류 Primary Shard Primary Shard 는 Indexing 되어 들어온 Document 의 원본 Shard 를 의미한다. Primary Shard 는 각 인덱스 별로 최소 1개 이상 존재 해야 한다. ElasticSearch 에 Document 가 인덱싱 될 때 가장 처음에 생성되는 샤드이다. 샤드 개수를 지정하지 않는다면 기본으로 5 개로 지정된다. Replica Shard Network / Cloud 환경의 샤드 노드가 오프라인 상태가 되거나 혹은 사라지게 될 경우를 대비하여 인덱스 샤드에 대해 하나 이상의 복사본을 생성할 수 있다. 이를 Replica Shard 라고 한다. ElasticSearch 에서 Primary Shard 가 인덱싱 된 후, Primary Shard 가 저장된 데이터 노드와는 다른 곳에 복제된다. Replica Shard 에도 넘버링을 하며, 어떤 Primary Shard 의 복제본인지 식별이 가능하다. replica 의 기본값은 1 인덱싱 시 Primary Shard 의 복제를 하는 과정이 추가된다. ES 플러그인 인 Head 로 각 노드에 샤드 dashboard를 확인 할 수 있다. Info Elasticsearch의 샤드는 Lucene 의 인덱스이며, 단일 Lucene 인덱스가 포함할 수 있는 도큐먼트의 최대 개수는 2,147,483,519 개 이다 Replica Shard 가 있기 때문에 샤드 혹은 노드의 오류가 발생하더라도 Elasticsearch 클러스터의 고가용성이 유지된다. 모든 Replica Shard에서 병렬 방식으로 검색을 실행할 수 있으므로 검색 처리량 확장 가능하다. ","date":"2018-10-18","objectID":"/elasticsearch-lecture0/:4:6","tags":["Elasticsearch"],"title":"[Elasticsearch 검색 엔진 구축 강의] Elasticsearch 시작하기","uri":"/elasticsearch-lecture0/"}]