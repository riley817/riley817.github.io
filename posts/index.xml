<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - Riley&#39;s DevLog</title>
        <link>https://riley817.github.io/posts/</link>
        <description>All Posts | Riley&#39;s DevLog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>riley0422@icloud.com (Riley)</managingEditor>
            <webMaster>riley0422@icloud.com (Riley)</webMaster><lastBuildDate>Tue, 07 Mar 2023 21:27:33 &#43;0900</lastBuildDate><atom:link href="https://riley817.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>[Go 언어를 활용한 네트워크 프로그래밍] 1. 네트워크 시스템 개요</title>
    <link>https://riley817.github.io/network-programming-with-go/</link>
    <pubDate>Tue, 07 Mar 2023 21:27:33 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/network-programming-with-go/</guid>
    <description><![CDATA[Go 언어를 활용한 네트워크 프로그래밍 책 정리
컴퓨터 네트워크coumputer network 란 두 개 이상의 장치 또는 노드간의 연결을 말한다.
네트워크 토폴로지 선택하기 네트워크 토폴로지topology 란 네트워크상의 노드의 구성을 말한다.
네트워크 토폴로지 유형 점대점 point-to-point 연결형 두 노드가 하나의 연결을 공유 한다. 두 노드 간에 직접 통신이 필요할 때 매우 유용하다. 데이지 체인 daisy chain 연결형 일련의 점대점 연결 출발지 노드와 목적지 노드 사이의 중간 노드를 일반적으로 홉이라고 한다. 버스형 bus 버스형 토폴로지상의 노드들은 공통, 공유 네트워크 링크를 갖는다.]]></description>
</item>
<item>
    <title>[TIL &amp; Issue Note] 20230227</title>
    <link>https://riley817.github.io/20230227/</link>
    <pubDate>Mon, 27 Feb 2023 17:05:22 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/20230227/</guid>
    <description><![CDATA[Server Authority 서버가 모든 권한을 가지고 있다. 서버는 중재자, 심판, 플레이어 역할을 한다. Client-Server 방식 클라이언트에서 질의(요청)하면 서버에서 응답하는 방식 가장 흔하게 사용하는 방법이며 대표적으로 웹서버가 있다. 클라이언트에 요청이 있어야만 서버가 응답을 한다. 웹서버 요청 방식 브라우저에서 naver.com 주소를 DNS 서버로 IP 검색 요청 DNS에서 naver.com 에 해당하는 IP 를 응답한다. 브라우저는 응답받은 IP의 서버에 커넥션 및 text 전문을 요청한다. naver.com 서버에서는 해당 요청에 응하는 전문을 리턴한다. MMORPG 게임에서 클라이언트와 서버 예시 플레이어가 이동을 위해 좌표를 서버로 요청Request한다.]]></description>
</item>
<item>
    <title>[TIL &amp; Issue Note] 20230221</title>
    <link>https://riley817.github.io/20230221/</link>
    <pubDate>Tue, 21 Feb 2023 23:04:09 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/20230221/</guid>
    <description><![CDATA[Deterministic은 왜 해킹에 취약한가 Deterministic 은 양쪽 input set을 공유하여 status 를 맞추는 방식으로 동작한다. input에 의존하기 때문에 input에 대한 변조를 통한 해킹에 취약하다. input set을 검사하는 방법 서버에서 패킷을 검사한다. Stateless Server : 중계(Relay) 서버의 경우 현재 게임상태나 게임의 룰을 알고 있지 않아도 된다. (단순히 패킷을 전달하는 역할을 하기 때문) 클라이언트끼리 상대방의 패킷이 정당한지 검사한다. 혹은 방장이 참여 클라이언트의 패킷이 전당한지 검사한다. 해킹을 막는 방법 tolerance 범위가 넘어가는 경우 해킹으로 간주한다.]]></description>
</item>
<item>
    <title>[TIL &amp; Issue Note] 20230218</title>
    <link>https://riley817.github.io/20230220/</link>
    <pubDate>Mon, 20 Feb 2023 23:59:59 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/20230220/</guid>
    <description><![CDATA[NAT(Network Address Translation)를 사용하는 이유 IPv4 주소체계에서 IP 주소를 절약 외부로 패킷이 나갈때는 private IP가 public IP로 바뀌어 전송되므로 내부 IP를 숨실 수 있음(보안) 게이트웨이, 라우터, 스위치, 공유기 등 NAT에서의 문제 UDP를 통한 네트워킹을 하기위해서는 서로의 Peer의 목적지를 알아야 한다. 클라이언트 A에서 NAT 거치게 되면 어떤 public IP와 Port 변환될지 모른다. 다른 클라이언트에서 A에게 연결을 하기 위해 public IP는 알고 있지만 private IP와 포트는 알지 못한다. UDP Hole Punching NAT 환경에서 사용자들과 P2P 연결을 중개하는 Relay 서버를 통해 사용자간 직접적인 데이터 전송을 구현]]></description>
</item>
<item>
    <title>[TIL &amp; Issue Note] 20230218</title>
    <link>https://riley817.github.io/20230218/</link>
    <pubDate>Sat, 18 Feb 2023 20:55:48 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/20230218/</guid>
    <description><![CDATA[Deterministic 방식 같은 인풋을 가지고 있으면 두 개의 상태state가 동일equal하다 (=sync가 맞는다.) 서로의 입력을 전송하는데에 시간이 걸린다. 얼마나 latency를 잘 극복하는지 desync가 일어나지 않게 만드는 것이 핵심이다. desync를 막기 위해 delay 와 rollback 방식을 활용한다. Delay 지연시간만큼 입력을 딜레이 시켜서 처리하면 싱크가 맞게 되는 원리 쉽고 단순하게 구현할 수 있다. 문제점
지연시간이 발생한다. 지연시간이 보통 100ms 가 넘어가면 플레이어가 이를 감지 할 수 있다. Rollback 지연시간만큼 다시 시간을 되돌리고 다시 앞감기를 한다.]]></description>
</item>
<item>
    <title>[Flutter] Flutter 개념 및 동작 원리</title>
    <link>https://riley817.github.io/flutter/</link>
    <pubDate>Thu, 16 Feb 2023 16:11:36 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/flutter/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/posts/images/banner/flutter-logo.png" referrerpolicy="no-referrer">
            </div>플러터 구글에서 개발한 공개 모바일 SDK 이다. 모바일 앱을 만들기 위한 기존 방식은 안드로이드와 IOS를 별도로 구현하여 배포해야했기에 요구되는 기술 스펙과 비용이 컸으나 플러터를 사용하면 한번의 구현으로 배포가 가능하다. 플러터는 렌터링 엔진, UI 컴포넌트, 테스트 프레임워크, 도구, 라우터 등 앱 제작에 필요한 기능을 모두 제공하므로 개발자는 앱 구현에 집중하여 생산성을 높일 수 있다.
플러터가 Dart 언어를 사용하는 이유 다트는 JIT(just-in-time), AOT(ahead-of-time) 컴파일을 모두 지원한다. AOT 컴파일러는 다트 코드를 효율적인 네이티브 코드로 바꾸어 개발자 및 사용자가 모두 빠르게 사용할 수 있다.]]></description>
</item>
<item>
    <title>[TIL &amp; Issue Note] 20230214</title>
    <link>https://riley817.github.io/20230215/</link>
    <pubDate>Tue, 14 Feb 2023 23:51:47 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/20230215/</guid>
    <description><![CDATA[ Tucker의 게임 네트워킹의 이해 - 2
Protocol 약속, 규약 Network Protocol : 통신 규약 컴퓨터간 통신을 하기 위해서는 약속이 필요하다. ]]></description>
</item>
<item>
    <title>[TIL &amp; Issue Note] 20230214</title>
    <link>https://riley817.github.io/20230214/</link>
    <pubDate>Tue, 14 Feb 2023 00:12:09 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/20230214/</guid>
    <description><![CDATA[Tucker의 게임 네트워킹의 이해 - 1
네트워킹 데이터를 주고 받는 것 컴퓨터 내부에서 발생하는 데이터 교환도 네트워킹이라고 볼 수 있다. 흔히 네트워킹이라고 말하면 외부에 멀리 떨어져 있는 컴퓨터들끼리의 데이터 교환을 의미한다. 내부 네트워킹과 외부 네트워킹간 차이 외부 네트워킹의 경우 지연시간이 발생한다 (latency)
RTT(Round Trip Time, 패킷왕복시간) : 패킷이 목적지에 도달하고나서 해당 패킷에 대한 응답이 출발지로 다시 돌아오기까지의 시간 지연시간의 경우 물리적인 환경의 문제이므로 줄이기가 어렵다. 게임에서는 눈속임을 통한 지연시간을 해소 연결 안전성 (연결 불안정)]]></description>
</item>
<item>
    <title>[Flutter Beginner] StatefulWidget</title>
    <link>https://riley817.github.io/flutter-beginner/</link>
    <pubDate>Fri, 03 Feb 2023 23:11:36 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/flutter-beginner/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/posts/images/banner/flutter-logo.png" referrerpolicy="no-referrer">
            </div>Widget Widget은 모두 불변의 법칙을 가지고 있다. 그러나 위젯의 값을 변경해야 할 경우가 생긴다. 변경이 필요할 경우 기존 위젯을 삭제해버리고 완전 새로운 위젯으로 대체한다.
StatelessWidget Life Cycle Constructor로 생성이되고 생성이 되자마자 build 함수가 실행된다. 변경이 필요하면 새로운 위젯을 만든다. StatelessWidget은 라이프 사이클 동안 단 한번만 build 함수를 실행한다. StatefulWidget 생명주기 Construct createState : State를 생성 initState : State를 초기화. State가 생성될 때 단 한번만 호출된다. didChangeDependencies dirty 상태 : 변경이 필요한 상태를 의미한다.]]></description>
</item>
<item>
    <title>[iOS/Android] APP HTTP 접근 허용하기</title>
    <link>https://riley817.github.io/ios-allow/</link>
    <pubDate>Tue, 31 Jan 2023 23:39:01 &#43;0900</pubDate>
    <author>riley</author>
    <guid>https://riley817.github.io/ios-allow/</guid>
    <description><![CDATA[APP HTTP 접근 허용 설정하기 iOS ios/Runner/Info.plist
1 2 3 4 5 6 7 8 9 &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsLocalNetworking&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSAllowsArbitraryLoadsInWebContent&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/plist&gt; Android android/app/src/main/AndroidManifest.xml
1 2 3 4 5 6 7 8 &lt;manifest xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; package=&#34;com.example.web_view&#34;&gt; &lt;uses-permission android:name=&#34;android.permission.INTERNET&#34;/&gt; &lt;!-- 추가 --&gt; &lt;application android:label=&#34;web_view&#34; android:name=&#34;${applicationName}&#34; android:icon=&#34;@mipmap/ic_launcher&#34; android:usesCleartextTraffic=&#34;true&#34;&gt; &lt;!-- 추가 --&gt; ]]></description>
</item>
</channel>
</rss>
