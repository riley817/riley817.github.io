# [TIL & Issue Note] 20230227


## Server Authority


- 서버가 모든 권한을 가지고 있다.
- 서버는 중재자, 심판, 플레이어 역할을 한다.

### Client-Server 방식
- 클라이언트에서 질의(요청)하면 서버에서 응답하는 방식
- 가장 흔하게 사용하는 방법이며 대표적으로 웹서버가 있다.
- 클라이언트에 요청이 있어야만 서버가 응답을 한다.

#### 웹서버 요청 방식
1. 브라우저에서 `naver.com` 주소를 DNS 서버로 IP 검색 요청
2. DNS에서 `naver.com` 에 해당하는 IP 를 응답한다.
3. 브라우저는 응답받은 IP의 서버에 커넥션 및 text 전문을 요청한다. 
4. `naver.com` 서버에서는 해당 요청에 응하는 전문을 리턴한다.

{{<image src="/posts/images/TIL/server-client.jpeg">}}

### MMORPG 게임에서 클라이언트와 서버 예시
{{<image src="/posts/images/TIL/server-authority.jpeg">}}
1. 플레이어가 이동을 위해 좌표를 서버로 요청`Request`한다.
2. 서버에서도 플레이어의 상태를 가지고 있다. 서버에서 캐릭터를 이동시킨다.
3. 클라이언트에게 캐릭터를 이동을 시작했다는 응답`Response`을 보냄
4. 서버에서는 주변 플레이어들에게 해당 플레이어의 위치가 변경되었음을 알린다.`Notification`

### MMORPG 
- `MMORPG` 게임은 서버가 모든 플레이어의 상태를 컨트롤해야 한다.
- 또한 상태값을 실시간으로 전달해야 한다.

## 소켓 프로그래밍의 배경
NIC(`Network Interface Card`) 주로 랜카드를 통해서 데이터를 In/Out 한다 프로그래머는 오픈된 인터페이스를 통해 하드웨어를 직접 연결하여 제어할 수 있었다 그러나 랜카드마다 인터페이스가 달랐기 때문에 각 제조사별로 프로그래밍을 할 수 밖에 없었다. 그래서 OS에서는 HAL 이라는 추상화 영역을 두어 각 하드웨어에 Adapted 하여 제조사에 상관없이 프로그래밍 할 수 있게 하고 있다.

### 소켓 프로그래밍 방식
#### 동기식 `Synchronous` 
- 요청이 완료될 때 까지 펑션이 종료되지 않는다.

#### 비동기식 `Asynchronose`
- 요청의 응답을 바로 리턴하고 작업이 완료되면 다시 응답값을 리턴한다.

### Select, IOCP
#### Select
- 소켓목록을 순회하며 송신, 수신, 예외에 따른 처리를 수행한다.
- `pre-request` 방식
- `Select` 방식의 경우 일의 주체자가 매번 요청을 처리할 수 있는지 확인해야 한다.
- 비교적 간단한게 구현이 가능하다.

#### IOCP `In/Out Completion Port`
- 주로 윈도우즈에서 사용한다,
- IOCP에 특정한 thread pool에서 소켓의 송수신을 관리한다.
- work thread와 소켓을 처리하는 thread가 분리되어 있다.

### MMORPG 서버의 요구사항
- 유저와 동접자 수가 많다. MMO(`Massively Multiplayer Online`)
- Actor 단위로 작업량이 많다
- Actor : Player, NPC(몬스터), Contorl-Zone, 그 외
- Actor의 매 프레임마다 동작을 처리해야 한다.

#### MMORPG 서버가 해야할 일
1. 패킷 처리 (Read/Write)
- 패킷을 파싱하고 패킷을 처리 후 패킷에 대한 응답을 클라이언트로 전송해야 한다.
2. Tick 처리
- 매프레임에 유저에게 동작을 업데이트 시키는 과정
3. 그 외
- ex) 물건을 사고파는 경매기능, 공성전 등...

## Multi Thread
- 유저가 늘어남에 따라 패킷 및 Tick 처리가 많아지고 하나의 CPU가 모든일을 다 처리하는 시간이 짧다. 코어를 여러개 나누어 분산 처리함으로써 시간을 단축시킬 수 있다. 그러나 멀티 스레드를 사용함으로써 복잡도가 높아지고 관리가 어렵기 때문에 오히려 싱글 스레드를 사용할 때보다 성능저하가 발생할 수 있다.

### Single Thread 구조
- Network I/O와 Work Thread 사이의 간극을 해소하는 Queue를 구성한다.
- Work Thread는 매 Tick 마다 Queue에 쌓인 모든 패킷을 처리하고 프레임의 상태를 업데이트 한다.
- 구조가 명료하고 심플하다.
- 싱글 스레드이기 때문에 멀티스레드에서 발생할 수 있는 문제들(데드락 등)이 없다.
- 처리할 수 있는 액터수가 한정적이다.

### Single Thread + Dedecate
- 특정 업무를 수행하는 Dedecate 스레드를 추가한다. (ex 경매장, 공성전, DB I/O 등)
- 특정기능을 분리함으로써 싱글스레드의 단점을 보완할 수 있다.

### Multi Thread 
- Work 스레드를 여러개 사용한다.
- 모든 워크 스레드가 하나의 큐를 사용하므로 충돌이 자주 발생한다.
- 또한 스레드 별로 인터렉션이 발생할 경우 처리가 복잡해진다.
- 웹서버의 경우 하나의 요청에 해당하는 데이터만 처리하면 되나 게임서버의 경우 인터렉션까지 고려하여 처리해야 한다.
- 성능이 올라 갈 수도 있으나 위와 같은 복잡한 문제가 많기 때문에 단순히 멀티스레드를 구성해서 문제를 해결할 수 없다.

### Single Thread vs Multi Thread
- 싱글 스레드를 사용하는 것을 추천한다. 관리하기 편리하고 프로그래밍 하기가 좋다.
- 감당할 수 있는 액터가 줄어든다.

## Multi Process
- 하나의 컴퓨터의 여러 프로세스를 동작시킨다.
- 서로 가상의 영역에서 동작하기 때문에 락킹에 대한 이슈는 발생하지 않는다.
- 멀티스레드는 하나의 메모리를 공유하지만 멀티 프로세스는 각 프로세스 영역의 메모리를 관리한다.
- 멀티프로세스의 경우 서로간 인터렉션이 불가능하다. 그러므로 게임에서는 월드를 구획화 하여 프로세스를 여러개로 관리한다.


## Single Process vs Multi Process
### Single Process
- 게임서버를 하나로 동작시킨다. 
- 구현이 단순하고 버전업 및 배포 서비스가 편리하다.
- **Scale Up** : 게임서버의 성능을 올리기 위해 더 좋은 단계의 머신을 사용한다.
- 어느 순간이 되면 머신의 성능을 올려도 성능향상에 한계가 발생한다.

### Multi Process
- **Scale Out** : 머신의 수르 늘린다.
- 같은 머신을 횡단으로 증가 시키므로 일정하게 성능이 향상된다.
- 버전업 및 배포 등 관리가 매우 어렵다.

> 처음에는 Scale Up을 하여 성능을 향상시키므로 비용이 더 저렴할 수 있으나 최근에는 클라우드 서버등의 가상머신을 많이 사용하므로서 경제적인 측면에는 오히려 Scale Out 방식이 더 저렴할 수도 있다.

## Availablity
- 가용성
- 싱글 스레드의 경우 하나의 서버가 죽으면 서비스 전체가 마비 될 수도 있다. (SPOF : single point of failure)

## 게임에서의 Multi Process 
### Zone 별로 프로세스를 구획화
- 게임 내 지형지물을 사용하여 Zone 별로 구획화하여 프로세스를 멀티로 구성한다.
- 유저가 다른 존으로 넘어갈 때는 로딩 등으로 처리할 수 있다.
- 같은 Zone 내에서도 프로세스를 중첩하여 `Channel`로 관리할 수 있다.

### 스레드 간 경쟁
- 스레드간 공유하는 메모리 자원에 대한 경쟁이 발생한다.
- 주로 락을 거는 방법으로 보호하고 자원을 어떻게 잘 분배할 것인지 고민해야 한다.

#### 스레드간 경쟁을 관리하는 방식
1. 무식하게
  - 스레드의 wait time이 길어짐으로써 성능이 떨어진다.
  - 데드락이 많이 발생할 수 있다.
  - 특정 스레드의 레이스 순서에 따라 타이밍 이슈가 발생한다.
2. Akka - 액터별로 나눈다.
- 액터를 기준으로 스레드를 분리한다.
- 액터간 인터렉션이 발생할 경우 메세지를 통해 스레드간 데이터를 전달한다.
- 서로 간섭이 일어나지 않기 때문에 락을 걸지 않아도 된다.
- 코딩의 복잡도가 올라간다.

3. ECS - Entity Component System
- 시스템 끼리 프로세스를 나눔으로써 기능 확장에 용이하다.
- 데이터 Locality
  - 관련 데이터들끼리 모여있는 경우 순차적으로 읽을 때 매우 빠르다.
- 시스템이 1:1로 대응 되면 좋으나 시스템간 인터렉션이 발생하므로 의존성 문제가 복잡해 질 수 있다. 

**Entity**
- 컴포넌트를 담든 그릇과 같은 용도
- 객체지향의 클래스처럼 상태를 관리한다.

**Component**
- 일반적으로 데이터 값을 가지고 있고 기능은 가지고 있지 않음
- 구현은 구조체, 클래스 또는 연관 배열을 사용한다.

**System**
- 특정 컴포넌트로만 이루어진 구현




